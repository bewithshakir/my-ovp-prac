{"version":3,"sources":["ovpApp/guide/guide-channel-row-directive.js"],"names":[],"mappings":"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","file":"ovpApp/guide/guide-channel-row-directive.js","sourcesContent":["/* globals $ */\n(function () {\n    'use strict';\n\n    var template = `\n        <a id='{{::channelIndex}}-{{::showKey}}' class='channel-content {{onnow}} {{::timeZoneClass}}\n            {{iconClasses}} {{paddingClass}}'\n            href='{{link}}'\n            data-show-id='{{::showKey}}'\n            style=\"width:{{::width}}px; left:{{::left}}px; padding-left: {{contentShiftPadding}}px;\"\n            tabindex='-1'\n            aria-describedby='rowheader-{{::channelIndex}} {{::timeColumn}}'\n            ng-style='showstyle'>\n                <div class='title-line event-off flex-box'>\n                    <div class='title truncate'>{{::show.title}}</div>\n                    <span class='restart {{(ondemandLink)?'':'hide'}}' aria-label='Available on demand'></span>\n                </div>\n                <div class='show-details truncate event-off'>\n                    <span class='recording-status'>{{show.recordingElement}}</span>\n                    <span class='new-status'>New</span>\n                    <span class='subtitle'>{{::show.metadata.title || show.shortDesc }}</span>\n                </div>\n        </a>\n    `;\n\n    angular.module('ovpApp.guide')\n        .directive('guideChannelRow', guideChannelRowDirective)\n        .factory('guideChannelRowCoordinator', guideChannelRowCoordinator);\n\n    /* @ngInject */\n    function guideChannelRowDirective($compile, $animate, $interpolate, $state, $window, rx, $q,\n        guideChannelRowCoordinator, profileService) {\n        return {\n            restrict: 'E',\n            replace: true,\n            require: '^guide-scroll-container',\n            template: `<div class='channel-listings-row'>\n                <span id='{{::id()}}' class='accessibilityhidden'>\n                    {{::description()}}\n                </span>\n                </div>`,\n            link: function ($scope, $element, $attr, $ctrl) {\n                var cachedWatchers = null;\n                var content = {};\n                var pixPerHour = $ctrl.getPixelsPerHour();\n                var interpolateFn = $interpolate(template);\n                var deRegisterWatch = null;\n                var scrollOffset = 0;\n                var injectCallback;\n                var selfFocus = false;\n                var delayedInvalidate = false;\n                var focusRestore = false;\n\n                //If this channel is not included in the 'displayZone' then\n                //prevent the watchers from being executed in the digest cycle\n                $scope.$on('displayZone', function (event, channelZones) {\n                    // manageShowElements(timeZones);\n\n                    if ((channelZones.indexOf($scope.zone.zoneIndex) >= 0) ||\n                        ($ctrl.adjacentZone($scope.zone.zoneIndex, channelZones))) {\n                        if (delayedInvalidate) {\n                            wipeData();\n                        }\n                        $element.show();\n                        if (cachedWatchers) {\n                            $scope.$$watchers = cachedWatchers;\n                            cachedWatchers = null;\n                        }\n                        $scope.channel.displayed = true;\n                        mergeStaged();\n                    } else if (deRegisterWatch !== null) {\n                        $scope.channel.displayed = false;\n                        // This causes a repaint, and may be counter productive\n                        deRegisterWatch();\n                        deRegisterWatch = null;\n                    }\n                });\n\n                $scope.$on('guide:invalidateData', function () {\n                    //This will get picked up in next digest cycle\n                    delayedInvalidate = true;\n                    $scope.channel.staged = [];\n                });\n\n                $scope.$on('guide:updateRecordings', function () {\n                    if ($scope.channel.recordings) {\n                        Object.keys(content).forEach(showKey => {\n                            let show = content[showKey];\n                            let currentRecordingElement = show.recordingElement;\n                            setRecordingElement(show);\n                            if (show.recordingElement !== currentRecordingElement) {\n                                $element\n                                    .find(`.channel-content[data-show-id='${showKey}'] .recording-status`)\n                                    .html(show.recordingElement);\n                            }\n                        });\n                    }\n                });\n\n                $scope.$on('guide:clearRecordings', function () {\n                    $element.find('.recording-status').removeClass('recording series');\n                    $scope.channel.recordings = null;\n                    Object.keys(content).forEach(showKey => {\n                        content[showKey].recordingElement = null;\n                    });\n                });\n\n                //This is kind of a nasty solution, but the alternative is a:\n                // $scope.$on('guide:focus', focusShow); which is more of a shotgun approach that\n                // seemed to be causing issues on slow devices;\n                if ($scope.channel) {\n                    $scope.channel.focusIn = (time, show) => {\n                        return focusShow(time, show);\n                    };\n                }\n\n                guideChannelRowCoordinator.getDebouncedAdjustOffsetSource($scope)\n                    .subscribe(function (data) {\n                        scrollOffset = data[1];\n                        if ($scope.channel.displayed) {\n                            if ($window.requestAnimationFrame) {\n                                $window.requestAnimationFrame(function () {\n                                    adjustShowPadding(scrollOffset);\n                                });\n                            } else {\n                                adjustShowPadding(scrollOffset);\n                            }\n                        }\n                    });\n\n                $scope.id = function () {\n                    if (!$scope.channel) {\n                        return '';\n                    }\n\n                    return 'rowheader-' + $scope.channel.globalIndex;\n                };\n\n                $scope.description = function () {\n                    const chan = $scope.channel;\n                    if (!chan) {\n                        return '';\n                    }\n\n                    const hasChannelNumber = !profileService.isSpecU() && angular.isDefined(chan.channelNumber);\n                    const number = hasChannelNumber ? chan.channelNumber : '';\n\n                    return `Channel ${number} ${chan.networkName || chan.callSign}`;\n                };\n\n                $scope.getShow = function (showId) {\n                    var show = content[showId];\n                    if (!show) {\n                        return content[showId.replace($scope.channel.globalIndex + '-', '')];\n                    }\n                    return show;\n                };\n\n                $element.on('focusin', '.channel-content', function (e) {\n                    if (!selfFocus) {\n                        let focusScope = angular.element(e.target).scope();\n                        let show = focusScope.getShow(angular.element(e.target).attr('id'));\n                        $scope.vm.setFocus(focusScope.zone, focusScope.channel, show);\n                    }\n                });\n\n                $element.on('click', '.channel-content', function (e) {\n                    let anchorScope = angular.element(e.target).scope();\n                    let show = anchorScope.getShow(angular.element(e.target).attr('id'));\n                    anchorScope.$root.$emit('Analytics:selectContent', {\n                        showFromGuide: show,\n                        channel: $scope.channel,\n                        elementType: 'cell',\n                        pageSectionName: 'guideArea',\n                        pageSubSectionName: 'programCell'\n                    });\n                });\n\n                function wipeData() {\n                    delayedInvalidate = false;\n                    content = {};\n                    let focus = $element.find('.channel-content:focus');\n                    if (focus.length > 0) {\n                        focusRestore = focus.data('show-id');\n                    }\n                    $element.find('.channel-content').remove();\n                }\n\n                /**\n                 * Pull any content out of the staged variable. This helps ensure that - if the watcher is not active\n                 * (due to the above caching of the watcher)\n                 * then we don't accidentally merge it into an unwatched array.\n                 */\n                function mergeStaged() {\n                    if ($scope.channel.staged && $scope.channel.staged.length > 0) {\n                        let staged = $scope.channel.staged\n                            .reduce((memo, show) => {\n                                let showKey = getShowKey(show);\n                                if (!content[showKey] && !memo[showKey]) {\n                                    memo[showKey] = show;\n                                    setRecordingElement(show);\n                                }\n                                return memo;\n                            }, {});\n                        $scope.channel.staged = [];\n                        //Attempt to render these elements in an animation frame\n                        if ($window.requestAnimationFrame) {\n                            $window.requestAnimationFrame(function () {\n                                injectShows(staged);\n                            });\n                        } else {\n                            injectShows(staged);\n                        }\n                        // adjustShowPadding(scrollOffset);\n                    }\n                    if (deRegisterWatch === null) {\n                        deRegisterWatch = $scope.$watch('channel.staged', function (nv) {\n                            if (nv && nv.length > 0) {\n                                mergeStaged();\n                            }\n                        });\n\n                    }\n                }\n\n                /**\n                 * Generate template data and apply it against the template.\n                 * @param  {Object[]} shows to create template from\n                 */\n                function injectShows(shows) {\n                    var added = '';\n                    var foundFocus = false;\n\n                    Object.keys(shows).map(showKey => shows[showKey])\n                    .sort((a, b) => a.startTimeOffset - b.startTimeOffset)\n                    .forEach(show => {\n                        let showKey = getShowKey(show);\n                        if (showKey === focusRestore && !foundFocus) {\n                            foundFocus = true;\n                        }\n                        let data = calculateShowPostion(show);\n                        data.showKey = showKey;\n                        data.show = show;\n                        data.link = generateLink(show);\n                        data.iconClasses = show.icons.map(s => s.toLowerCase()).join(' ');\n                        data.channelIndex = $scope.channel.globalIndex;\n                        data.ondemandLink = (show.vodProviderAssetId) ? true : false;\n                        added += interpolateFn(data);\n                        content[showKey] = show;\n                    });\n                    $animate.enter(added, $element).then(function () {\n                        if (injectCallback) {\n                            injectCallback(shows);\n                            injectCallback = null;\n\n                        }\n                        if (foundFocus && focusRestore) {\n                            $element.children(`.channel-content[data-show-id='${focusRestore}']`).focus();\n                            foundFocus = false;\n                            focusRestore = false;\n                        }\n                    });\n                }\n\n                /**\n                 * Gerenarete a 'unique' key based on the show data. The key is only unique within the channel - it\n                 * may not be unique in the entire page since channels may be duplicated.\n                 * @param  {Object} show\n                 * @return {String}\n                 */\n                function getShowKey(show) {\n                    return show.startTimeSec + '-' + show.tmsProgramId;\n                }\n\n                /**\n                 * Calculate the absolute position and width based on the determined pixel width\n                 * @param  {Object} show\n                 * @return {Object} position class and style data\n                 */\n                function calculateShowPostion(show) {\n                    let durationPix = 0;\n                    let startPix;\n                    let zone = 0;\n                    let zoneWidthSeconds = 4 * 3600; //Zone is 4 hours wide ...\n                    let endTimeUtcSeconds = show.durationMinutes * 60 + show.startTimeSec;\n                    let onNow = '';\n                    let pad = 0;\n                    let paddingClass = '';\n\n                    if (show.startTimeOffset < 0) {\n                        startPix = 0;\n                        durationPix = Math.floor(((show.durationMinutes / 60) +\n                            (show.startTimeOffset / 3600)) * pixPerHour);\n                        zone = 'zone_' + Math.floor(show.startTimeOffset / zoneWidthSeconds);\n                    } else {\n                        startPix = Math.floor(((show.startTimeOffset) / 3600) * pixPerHour);\n                        durationPix = Math.floor((show.durationMinutes / 60) * pixPerHour);\n                        zone = 'zone_' + Math.floor(show.startTimeOffset / zoneWidthSeconds);\n                    }\n\n\n                    let now = Date.now();\n                    if (now > (show.startTimeSec * 1000) && now  < (endTimeUtcSeconds * 1000)) {\n                        onNow = 'onnow';\n                    }\n                    show.startPix = startPix;\n                    show.endPix = startPix + durationPix;\n\n                    if (show.startPix < scrollOffset && show.endPix > scrollOffset) {\n                        pad = scrollOffset - show.startPix + 20;\n                    } else {\n                        paddingClass = 'normal-pos';\n                    }\n\n                    return {\n                        contentShiftPadding: pad,\n                        paddingClass: paddingClass,\n                        left: startPix,\n                        width: durationPix,\n                        timeZoneClass: zone,\n                        onnow: onNow,\n                        timeColumn: 'timecol_' + Math.floor(show.startTimeOffset / (60 * 30))\n                    };\n                }\n\n                /**\n                 * Generate the text url to display\n                 * @param  {Object} show show element\n                 * @return {String}      link to product page\n                 */\n                function generateLink(show) {\n                    var productState = 'product.event';\n                    var productStateOptions = {\n                        tmsId: show.tmsProgramId,\n                        tmsProgramId: show.tmsProgramId,\n                        airtime: show.startTimeSec,\n                        app: 'guide',\n                        tmsGuideServiceId: $scope.channel.tmsGuideId,\n                        displayChannel: $scope.channel.channelNumber || show.channelNumber\n                    };\n\n                    if (show.metadata && show.metadata.tmsSeriesId) {\n                        productState = 'product.series';\n                        productStateOptions.tmsSeriesId = show.metadata.tmsSeriesId;\n                    }\n                    show.state = productState;\n                    show.stateOptions = productStateOptions;\n\n                    return $state.href(productState, productStateOptions);\n                }\n\n                /**\n                 * Determine the recording status classes\n                 * @param {Object} show show object that might have\n                 */\n                function setRecordingElement(show) {\n                    if (show.cdvrSeries && show.cdvrState) {\n                        show.recordingElement =\n                            '<span class= \"twcicon-svg twcicon-svg-recording-series\"' +\n                            'aria-label=\"Scheduled to record\"></span>';\n                    } else if (show.cdvrState) {\n                        show.recordingElement =\n                            '<span class= \"twcicon-svg twcicon-svg-recording\"' +\n                             'aria-label=\"Scheduled to record\"></span>';\n                    } else if ($scope.channel.recordings && $scope.channel.recordings[show.tmsProgramId]) {\n                        show.recording = $scope.channel.recordings[show.tmsProgramId];\n                        if (show.recording.recordSeries) {\n                            show.recordingElement =\n                                '<span class= \"twcicon-svg twcicon-svg-recording-series\"' +\n                                'aria-label=\"Scheduled to record\"></span>';\n                        } else {\n                            show.recordingElement =\n                                '<span class= \"twcicon-svg twcicon-svg-recording\"' +\n                                 'aria-label=\"Scheduled to record\"></span>';\n                        }\n                        return true;\n                    } else {\n                        show.recording = null;\n                        show.recordingElement = '';\n                        return false;\n                    }\n                }\n\n                /**\n                 * Given the x-axis scroll offset - add padding inside the cell to position the contents in the\n                 * visible area\n                 * @param  {int} pixOffset the current pixel scroll offset of the container element\n                 * @return undefined\n                 */\n                function adjustShowPadding(pixOffset) {\n                    Object.keys(content).forEach(showKey => {\n                        if (content[showKey].startPix < pixOffset && content[showKey].endPix > pixOffset) {\n                            let padd = pixOffset - content[showKey].startPix + 20;\n                            getShowElement(showKey, $scope.channel.globalIndex)\n                                .removeClass('normal-pos').css('padding-left', padd);\n                        } else {\n                            getShowElement(showKey, $scope.channel.globalIndex).addClass('normal-pos');\n                        }\n                    });\n                }\n\n                /**\n                 * Get the element from the page and cache it in the show object, return the cached\n                 * element if it exists.\n                 * @param  {String} showKey the string key from 'getShowKey'\n                 * @return {jQuery element}\n                 */\n                function getShowElement(showKey, index) {\n                    let show = content[showKey];\n                    if (!show) {\n                        throw `Unable to find the show: ${showKey} on Channel:  ${index}`;\n                    }\n                    if (!show.el) {\n                        show.el = {};\n                    }\n                    if (!show.el[index]) {\n                        show.el[index] = $element.children(`.channel-content[data-show-id='${showKey}']`);\n                    }\n                    return show.el[index];\n                }\n\n                /**\n                 * Given a given time, find the show that appears during that time\n                 * @param  {event} event\n                 * @param  {int} channelNumber\n                 * @param  {int} timeSlot\n                 * @param  {function} onFocusCallback function to call when a show has been found and focused\n                 * @return undefined\n                 */\n                function focusShow(timeSlot, show, setInjectCallBack = true) {\n                    var showkey = null;\n                    if (show) {\n                        showkey = getShowKey(show);\n                    } else {\n                        showkey = Object.keys(content).find(showKey => {\n                            let showEndOffsetSeconds = content[showKey].startTimeOffset +\n                                content[showKey].durationMinutes * 60;\n                            return content[showKey].startTimeOffset <= timeSlot &&\n                                timeSlot < showEndOffsetSeconds;\n                        });\n                    }\n                    if (!showkey) {\n                        if (setInjectCallBack) {\n                            let defer = $q.defer();\n                            injectCallback = function () {\n                                focusShow(timeSlot, show, false).then(focusShow => {\n                                    defer.resolve(focusShow);\n                                });\n                            };\n                            return defer.promise;\n                        } else {\n                            return $q.resolve(false);\n                        }\n                    } else {\n                        let el;\n                        try {\n                            el = getShowElement(showkey, $scope.channel.globalIndex);\n                        } catch (e) {\n                            //The show likely hasn't been displayed yet\n                            return $q.reject(e);\n                        }\n                        selfFocus = true;\n                        el.focus();\n                        selfFocus = false;\n                        angular.element('#guide-channels-body').attr('aria-activedecendent', el.attr('id'));\n                        //Check to ensure the focus is not underneath the fixed header\n                        if (el.offset().top - angular.element($window).scrollTop() < 130) {\n                            $('html, body').animate({\n                                scrollTop: el.offset().top - 130\n                            }, 200);\n                        }\n                        return $q.resolve(content[showkey]);\n                    }\n                }\n            }\n        };\n    }\n\n    // Each channel row doing its own debouncing results in extraneous overhead in the form of timers.\n    // This coordinator service does the debouncing once, and shares it with all the channel rows.\n    /* @ngInject */\n    function guideChannelRowCoordinator() {\n        let observable;\n\n        const service = {\n            getDebouncedAdjustOffsetSource: function (scope) {\n                if (!observable) {\n                    observable = scope.$eventToObservable('guide:adjustOffset')\n                        .debounce(60)\n                        .share();\n                }\n                return observable;\n            }\n        };\n\n        return service;\n    }\n}());\n"],"sourceRoot":"/source/"}