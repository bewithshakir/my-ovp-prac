{"version":3,"sources":["ovpApp/components/edit-conflict/edit-conflict.js"],"names":[],"mappings":"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","file":"ovpApp/components/edit-conflict/edit-conflict.js","sourcesContent":["(function () {\n    'use strict';\n\n    angular.module('ovpApp.components.editConflict', [\n        'ovpApp.legacy.DateUtil',\n        'ovpApp.rdvr.rdvrService',\n        'ovpApp.messages',\n        'ovpApp.components.ovp.button',\n        'ovpApp.components.ovp.rating',\n        'ovpApp.components.ovp.channel',\n        'ovpApp.services.dateFormat',\n        'ovpApp.services.errorCodes',\n        'ovpApp.components.alert',\n        'ajoslin.promise-tracker',\n        'ovpApp.components.conflictItem'\n    ])\n    .directive('freezeheightuponfirstload', freezeheightuponfirstload)\n    .directive('stopbodyscrolling', stopbodyscrolling)\n    .component('editConflict', {\n        templateUrl: '/js/ovpApp/components/edit-conflict/edit-conflict.html',\n        bindings: {\n            resolve: '<',\n            modalInstance: '<'\n        },\n        controller: class EditConflictController {\n            /* @ngInject */\n            constructor($scope, dateUtil, stbService, rdvrService, $rootScope, $q,\n                alert, messages, $log, $timeout, $element,\n                dateFormat, promiseTracker, errorCodesService) {\n                angular.extend(this, {\n                    $scope,\n                    dateUtil,\n                    stbService,\n                    rdvrService,\n                    $rootScope,\n                    $q,\n                    alert,\n                    messages,\n                    $log,\n                    $timeout,\n                    $element,\n                    dateFormat,\n                    promiseTracker,\n                    errorCodesService\n                });\n            }\n\n            $onInit() {\n                this.dvrTracker = this.promiseTracker();\n                this.model = (this.resolve && this.resolve.model) || {};\n\n                this.resolveConflict(this.model.scheduledRecording, this.model.conflictingRecordings);\n            }\n\n            resolveConflict(primaryRecording, conflictingRecordings) {\n                this.done = false;\n                this.alreadyResolved = false;\n                this.confirmLabel = 'Confirm';\n\n                let conflictsPromise;\n                if (angular.isUndefined(conflictingRecordings) || conflictingRecordings.length === 0) {\n                    conflictsPromise = this.fetchConflicts(primaryRecording);\n                } else {\n                    conflictsPromise = this.$q.resolve(conflictingRecordings);\n                }\n\n                conflictsPromise.then(conflicts => {\n                    if (!conflicts || conflicts.length === 0) {\n                        // It's not in conflict after all. Move on to the next conflict, if able.\n                        let hasNextConflict = false;\n                        if (this.nextConflicts) {\n                            const index = this.nextConflicts.indexOf(primaryRecording);\n                            if (index >= 0 && index + 1 < this.nextConflicts.length) {\n                                hasNextConflict = true;\n                                this.resolveConflict(this.nextConflicts[index + 1]);\n                            }\n                        }\n\n                        if (!hasNextConflict) {\n                            this.alreadyResolved = true;\n                            this.getNextConflict();\n                        }\n                    } else {\n                        this.recordings = [primaryRecording].concat(conflicts);\n                        this.selections = this.recordings.map(() => 'undecided');\n                    }\n                });\n\n                this.dayDisplay = this.dateFormat.absolute.expanded(new Date\n                    (parseInt(this.model.scheduledRecording.startTime * 1000)));\n\n                this.oneTimeOnly = this.model.oneTimeOnly;\n                this.isNotYetScheduled = this.model.isNotYetScheduled;\n                this.onKeep = this.model.onKeep;\n                this.onCancel = this.model.onCancel;\n            }\n\n            maxToKeep() {\n                return this.recordings ? this.recordings.length - 1 : 2;\n            }\n\n            fetchConflicts(recording) {\n                let getConflictsPromise = this.stbService.getCurrentStb()\n                    .then(stb => this.rdvrService.getScheduledConflicts(stb, recording))\n                    .then(conflicts => {\n                        return conflicts;\n                    }, () => {\n                        this.alert.open({\n                            message: this.errorCodesService.getMessageForCode('WCM-9000'),\n                            title: this.errorCodesService.getHeaderForCode('WCM-1016'),\n                            buttonText: 'OK'\n                        }).result.then(() => this.modalInstance.dismiss());\n                    });\n                this.dvrTracker.addPromise(getConflictsPromise);\n                return getConflictsPromise;\n            }\n\n            recordingSelected($index, state) {\n                this.selections[$index] = state;\n                const saveCount = this.selections.filter(s => s === 'save').length;\n                if (saveCount === this.maxToKeep()) {\n                    // By process of elimination, we now know the rest should be deletes\n                    this.selections = this.selections.map(s => {\n                        if (s === 'undecided') {\n                            return 'delete';\n                        } else {\n                            return s;\n                        }\n                    });\n                } else if (saveCount > this.maxToKeep()) {\n                    // Too many marked to keep; need to unmark one of them\n                    this.selections[($index + 1) % this.selections.length] = 'delete';\n                }\n                this.confirmLabel = 'Confirm';\n            }\n\n            readyToSubmit() {\n                return this.selections && this.maxToKeep() === this.selections.filter(s => s === 'save').length;\n            }\n\n            headerMessage() {\n                if (this.alreadyResolved) {\n                    return '';\n                } else if (this.done) {\n                    return `These ${this.recordings.length} shows will be recorded`;\n                }\n\n                const max = this.maxToKeep();\n                if (this.selections === undefined || this.selections.every(s => s === 'undecided')) {\n                    return 'Click the ' + max + ' recording' + (max === 1 ? '' : 's') +\n                        ' you would like to keep. You can record up to ' + max + ' shows at a time.';\n                } else {\n                    const saveCount = this.selections.filter(s => s === 'save').length;\n                    if (saveCount < max) {\n                        const shortfall = max - saveCount;\n                        const plural = shortfall === 1 ? '' : 's';\n                        return `Please select ${shortfall} more recording${plural} you wish to keep`;\n                    } else {\n                        const delCount = this.selections.length - saveCount;\n                        const thePrograms = delCount === 1 ? 'this program' : 'these ' + delCount + ' programs';\n                        return `Click confirm if you want to cancel ${thePrograms} to resolve the recording conflict.`;\n                    }\n                }\n            }\n\n            confirm() {\n                if (this.readyToSubmit()) {\n                    return this.stbService.getCurrentStb().then(stb => {\n                        this.isDirty = true;\n\n                        let toCancel = [], promises = [];\n\n                        // First recording may or may not already be scheduled\n                        if (this.selections[0] === 'delete') {\n                            if (!this.isNotYetScheduled) {\n                                toCancel.push(this.recordings[0]);\n                            }\n\n                            if (this.onCancel) {\n                                promises.push(this.$q.when(this.onCancel()));\n                            }\n                        }\n\n                        // The rest are scheduled, so they just get cancelled.\n                        for (let i = 1; i < this.selections.length; i++) {\n                            if (this.selections[i] === 'delete') {\n                                toCancel.push(this.recordings[i]);\n                            }\n                        }\n\n                        promises.push(this.cancelRecordings(stb, toCancel)\n                            .then(() => {\n                                this.recordings = this.recordings.filter(r => toCancel.indexOf(r) < 0);\n                                this.selections = this.recordings.map(() => 'save');\n                                this.done = true;\n                                if (!this.oneTimeOnly) {\n                                    this.getNextConflict();\n                                }\n                            }, () => {\n                                this.confirmLabel = 'Retry';\n                            }));\n\n                        let promise = this.$q.all(promises);\n                        if (this.selections[0] === 'save' && this.onKeep) {\n                            promise = promise\n                                .then(() => this.$timeout(angular.noop, 500))\n                                .then(() => this.onKeep());\n                        }\n                        this.dvrTracker.addPromise(promise);\n                        return promise.finally(() => {\n                            if (this.oneTimeOnly) {\n                                this.modalInstance.close();\n                            }\n                        });\n                    });\n                }\n            }\n\n            cancelRecordings(stb, recordings) {\n                let promises = [];\n                recordings.forEach(r => {\n                    let promise = this.rdvrService.cancelScheduled(stb, r, true);\n\n                    this.$rootScope.$broadcast(\n                        'message:loading',\n                        promise,\n                        'Resolving...'\n                    );\n\n                    promises.push(promise.then(\n                        () => {},\n                        (reason) => {\n                            if (reason.status === 404) {\n                                // It's apparently already cancelled\n                                return this.$q.resolve();\n                            }\n\n                            this.alert.open({\n                                message: this.errorCodesService.getMessageForCode('WCM-9000'),\n                                title: this.errorCodesService.getHeaderForCode('WCM-1003'),\n                                buttonText: 'OK'\n                            });\n\n                            return this.$q.reject(reason);\n                        }));\n                });\n\n                return this.$q.all(promises);\n            }\n\n            getNextConflict() {\n                if (this.updateSubscription) {\n                    this.updateSubscription.dispose();\n                }\n\n                this.nextConflicts = undefined;\n                this.resolveNextLabel = 'Checking for other conflicts...';\n                this.resolveNextDisabled = true;\n                this.stbService.getCurrentStb().then(stb => {\n                    this.rdvrService.resetScheduledRecordings(stb);\n                    this.updateSubscription = this.rdvrService.getScheduledRecordings(stb)\n                        .map(({data, isComplete}) => {\n                            return {\n                                data: data.filter(recording => recording.conflicted),\n                                isComplete: isComplete\n                            };\n                        })\n                        .subscribe(\n                            ({data, isComplete}) => {\n                                this.nextConflicts = data;\n                                if (this.nextConflicts.length === 0) {\n                                    if (isComplete) {\n                                        this.resolveNextLabel = 'No more conflicts!';\n                                    }\n                                    // else, leave the label as it is\n                                } else {\n                                    this.resolveNextDisabled = false;\n                                    let countString;\n                                    if (this.nextConflicts.length > 99) {\n                                        countString = '99+';\n                                    } else {\n                                        countString = this.nextConflicts.length + (isComplete ? '' : '+');\n                                    }\n                                    this.resolveNextLabel = `Resolve Next Conflict (${countString})`;\n                                }\n                            },\n                            () => {\n                                if (this.nextConflicts === 0) {\n                                    this.resolveNextLabel = 'Error checking for other conflicts';\n                                }\n                                // Else, leave the label as it is\n                            }\n                        );\n                });\n            }\n\n            resolveNextConflict() {\n                if (this.nextConflicts && this.nextConflicts[0]) {\n                    this.resolveConflict(this.nextConflicts[0]);\n                }\n            }\n\n            cancelLabel() {\n                if (this.done || this.alreadyResolved) {\n                    return 'Done';\n                } else {\n                    return 'Cancel';\n                }\n            }\n        }\n    });\n\n    /* @ngInject */\n    function freezeheightuponfirstload() {\n        return {\n            link: function ($scope, $element) {\n                var listener = $scope.$watch('currentRecordingsInConflict', function () {\n                    var height = $element.height();\n                    if (height > 0) {\n                        //since the height of the modal will get smaller\n                        //once the conflict is resolved (1 less row)\n                        //explicitly set height of the list to first rendered height\n                        $element.css('height', height + 'px');\n                        listener();\n                    }\n                });\n            }\n        };\n    }\n\n    /* @ngInject */\n    function stopbodyscrolling($window) {\n        return {\n            link: function (scope) {\n                var body = angular.element($window.document).find('body');\n                body.addClass('body-stop-scrolling');\n                scope.$on('$destroy', function () {\n                    body.removeClass('body-stop-scrolling');\n                });\n            }\n        };\n    }\n}());\n"],"sourceRoot":"/source/"}