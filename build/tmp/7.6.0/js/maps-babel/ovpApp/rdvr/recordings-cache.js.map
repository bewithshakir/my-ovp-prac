{"version":3,"sources":["ovpApp/rdvr/recordings-cache.js"],"names":[],"mappings":"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","file":"ovpApp/rdvr/recordings-cache.js","sourcesContent":["(function () {\n    'use strict';\n\n    angular.module('ovpApp.rdvr.recordingsCache', [\n        'ovpApp.config',\n        'ovpApp.legacy.DateUtil'\n    ])\n\n    .constant('RecordingsCacheIntervals', {\n        DIRTY: 30,\n        EXPIRED: 120,\n        AGED: 15\n    })\n\n    .factory('RecordingsCache', RecordingsCache);\n\n    /* @ngInject */\n    function RecordingsCache(RecordingsCacheIntervals, $window, $timeout, dateUtil, $interval, $rootScope) {\n        var Cache = function (type, stb) {\n            this.type = type;\n            this.stb = stb;\n            this.timeCreatedUtcMsec = new Date().getTime();\n            this.lastRefreshTimeUtcMsec = null;\n            this.json = null;\n            this.lastDirtiedTimeUtcMsec = null;\n            this.deserializedTimeUtcMsec = null;\n            this.isFailed = false;\n            this.failureReason = null;\n            this.scheduledRemovalPromise = null;\n        };\n\n        Cache.prototype.scheduleRemoval = function () {\n            var self = this;\n            $interval.cancel(this.scheduledRemovalPromise);\n            this.scheduledRemovalPromise = $interval(function () {\n                if (self.shouldFetchFromService()) {\n                    $rootScope.$broadcast('recordings-cache-expired', self);\n                    $interval.cancel(self.scheduledRemovalPromise);\n                }\n            }, 1000);\n        };\n\n        Cache.prototype.getLastRefreshTimeUtcMsec = function () {\n            return this.lastRefreshTimeUtcMsec;\n        };\n\n        Cache.prototype.getType = function () {\n            return this.type;\n        };\n\n        Cache.prototype.setLastRefreshTimeUtcSec = function (time) {\n            this.lastRefreshTimeUtcMsec = time;\n        };\n\n        Cache.prototype.setDeserializedTimeUtcSec = function (time) {\n            this.deserializedTimeUtcMsec = time;\n        };\n\n        Cache.prototype.dirtyIntervalNotMet = function () {\n            return (this.lastDirtiedTimeUtcMsec) &&\n                (new Date().getTime() - this.lastDirtiedTimeUtcMsec < this.getDirtyIntervalMsec());\n        };\n\n        Cache.prototype.isExpired = function () {\n            return (this.lastRefreshTimeUtcMsec) &&\n                (new Date().getTime() - this.lastRefreshTimeUtcMsec > this.getExpiredIntervalMsec());\n        };\n\n        Cache.prototype.isAged = function () {\n            return (new Date().getTime() - this.lastRefreshTimeUtcMsec > this.getAgedIntervalMsec());\n        };\n\n        //1.  user has made an action that has dirtied the cache and has made it past dirty interval\n        //2.  user has made it past the expired interval\n        Cache.prototype.shouldFetchFromService = function () {\n            var shouldFetch = false;\n            if (this.isDirty() && !this.dirtyIntervalNotMet()) {\n                shouldFetch = true;\n            }\n\n            if (this.isExpired()) {\n                shouldFetch = true;\n            }\n            return shouldFetch;\n        };\n\n        Cache.createKey = function (type, stb) {\n            if (stb && stb.macAddressNormalized) {\n                return 'rdvr.' + type + '.' + stb.macAddressNormalized;\n            }\n        };\n\n        Cache.prototype.getKey = function () {\n            return Cache.createKey(this.type, this.stb);\n        };\n\n        Cache.prototype.getStb = function () {\n            return this.stb;\n        };\n\n        Cache.prototype.getAgedIntervalMsec = function () {\n            return RecordingsCacheIntervals.AGED * 1000;\n        };\n\n        Cache.prototype.getExpiredIntervalMsec = function () {\n            return RecordingsCacheIntervals.EXPIRED * 1000;\n        };\n\n        Cache.prototype.getDirtyIntervalMsec = function () {\n            return RecordingsCacheIntervals.DIRTY * 1000;\n        };\n\n        Cache.prototype.getIntervalUntilRefreshAllowedSec = function () {\n            var interval = this.getDirtyIntervalMsec() - (new Date().getTime() - this.lastDirtiedTimeUtcMsec);\n            if (interval < 0) {\n                interval = 0;\n            }\n            return interval;\n        };\n\n        Cache.prototype.deserialize = function (serializedjson) {\n            var json = angular.fromJson(serializedjson);\n            this.type = json.type;\n            this.stb = json.stb;\n            this.timeCreatedUtcMsec = json.timeCreatedUtcMsec;\n            this.lastRefreshTimeUtcMsec = json.lastRefreshTimeUtcMsec;\n            this.lastDirtiedTimeUtcMsec = json.lastDirtiedTimeUtcMsec;\n            this.deserializedTimeUtcMsec = new Date().getTime();\n            this.json = json.json;\n            this.scheduleRemoval();\n        };\n\n        Cache.prototype.isDirty = function () {\n            return this.lastDirtiedTimeUtcMsec !== null;\n        };\n\n        Cache.prototype.dirtied = function () {\n            this.lastDirtiedTimeUtcMsec = new Date().getTime();\n        };\n\n        Cache.prototype.update = function (json) {\n            this.json = json;\n            this.dirtied();\n        };\n\n        Cache.prototype.refreshCompleted = function (json) {\n            this.json = json;\n            this.lastRefreshTimeUtcMsec = new Date().getTime();\n            this.scheduleRemoval();\n        };\n\n        Cache.prototype.refreshFailed = function (failure) {\n            this.isFailed = true;\n            this.failureReason = failure;\n            this.json = null;\n            this.lastRefreshTimeUtcMsec = new Date().getTime();\n        };\n\n        Cache.prototype.getJson = function () {\n            return this.json;\n        };\n\n        Cache.prototype.toString = function () {\n            return 'type: ' + this.type +\n                '\\n stb: ' + this.stb ? this.stb.macAddressNormalized : 'undefined' +\n                '\\n time created: ' + dateUtil.formatDate(new Date(this.timeCreatedUtcMsec), 'mmm dd hh:nn:ss') +\n                '\\n last refresh: ' +\n                dateUtil.formatDate(new Date(this.lastRefreshTimeUtcMsec), 'mmm dd hh:nn:ss') +\n                '\\n last dirtied: ' +\n                dateUtil.formatDate(new Date(this.lastDirtiedTimeUtcMsec), 'mmm dd hh:nn:ss') +\n                '\\n last read from local storage: ' +\n                dateUtil.formatDate(new Date(this.deserializedTimeUtcMsec), 'mmm dd hh:nn:ss') +\n                '\\n dirty interval not met: ' + this.dirtyIntervalNotMet() +\n                '\\n is aged: ' + this.isAged() +\n                '\\n is expired: ' + this.isExpired() +\n                '\\n is failed: ' + this.isFailed +\n                '\\n failure reason: ' + this.failureReason;\n        };\n        return Cache;\n    }\n}());\n"],"sourceRoot":"/source/"}