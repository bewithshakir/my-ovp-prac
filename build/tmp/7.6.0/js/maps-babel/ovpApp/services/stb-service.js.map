{"version":3,"sources":["ovpApp/services/stb-service.js"],"names":[],"mappings":"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","file":"ovpApp/services/stb-service.js","sourcesContent":["(function () {\n    'use strict';\n\n    angular.module('ovpApp.services.stbService', [\n        'ovpApp.config',\n        'ovpApp.legacy.DateUtil',\n        'ovpApp.components.error.ServiceError',\n        'ovpApp.services.profileService',\n        'ovpApp.services.ovpStorage',\n        'rx'\n    ])\n    .factory('stbService', stbService)\n    .factory('realStbService', realStbService);\n\n    /* @ngInject */\n    function stbService($http, $q, ServiceError, config, dateUtil, $rootScope,\n            $log, profileService, ovpStorage, storageKeys, rx) {\n\n        let piHost = config.piHost,\n            nrsBase = config.nrsApi,\n            stbApi = config.nrs.stb,\n            headendDefer = $q.defer(),\n            // Initialize with the browser's timezone offset\n            // until we hear from STB.\n            offsetFromGMT = (new Date().getTimezoneOffset() / 60) * -1,\n            setTopBoxes = [],\n            stbDefer,\n            selectedStb;\n\n        let currentStbSubject = new rx.ReplaySubject(1);\n\n        let service = {\n            getHeadend,\n            setHeadend,\n            defaultDvrLanding,\n            getSTBs,\n            currentStbSource: createCurrentStbSource(),\n            getCurrentStbPromise,\n            getCurrentStb,\n            setCurrentStb,\n            postStbName,\n            getDate,\n            getOffsetFromGMT,\n            setOffsetFromGMT,\n            formatUnix,\n            getDayLabel,\n            selectDefaultDvr,\n            _handleHttpError\n        };\n\n        return service;\n\n        ////////////////////\n\n        function storeCurrentStb(stb) {\n            return $q.resolve(ovpStorage.setItem(storageKeys.currentStb, stb));\n        }\n\n        function retrieveCurrentStb() {\n            // use value from storage, otherwise use cookie\n            return $q.resolve(ovpStorage.getItem(storageKeys.currentStb));\n        }\n\n        function getHeadend() {\n            profileService.isIpOnlyEnabled().then(isEnabled => {\n                // If we are in IP only mode then the headend it irrelevant. Resolve the promise and return it.\n                if (isEnabled) {\n                    headendDefer.resolve();\n                } else {\n                    // getSTBs will call setHeadend() when the STB info\n                    // is obtained. which will resolve the promise returned\n                    // below.\n                    getSTBs();\n                }\n            });\n\n            return headendDefer.promise;\n        }\n        function setHeadend(headend) {\n            headendDefer.resolve(headend);\n        }\n        function defaultDvrLanding() {\n            let defer = $q.defer(),\n                resolve = stb => {\n                    if (stb && stb.rdvrVersion > 1) {\n                        defer.resolve('ovp.dvr.my-recordings');\n                    } else {\n                        defer.resolve('ovp.dvr.scheduled');\n                    }\n                };\n\n            getCurrentStb().then(stb => {\n                if (!stb) {\n                    selectDefaultDvr().then(() => {\n                        getCurrentStb().then(stb => {\n                            resolve(stb);\n                        });\n                    })\n                    .catch(() => {\n                        resolve({});\n                    });\n                }\n\n                resolve(stb);\n            });\n\n            return defer.promise;\n        }\n        function getSTBs() {\n            if (!stbDefer) {\n                stbDefer = $q.defer();\n\n                $q.all([profileService.isIpOnlyEnabled(),\n                    profileService.canUseGuide()]).then(params => {\n                    let isIpEnabled = params[0];\n                    let isGuideEnabled = params[1];\n\n                    if (!isIpEnabled && isGuideEnabled) {\n                        $http({\n                            method: 'GET',\n                            url: piHost + nrsBase + stbApi,\n                            withCredentials: true\n                        })\n                        .then(function (response) {\n                            var data = response.data;\n                            setTopBoxes = data.setTopBoxes || [];\n                            setHeadend({\n                                id: data.headend,\n                                offsetFromGMT: data.offsetFromGMT\n                            });\n\n                            if (setTopBoxes.length) {\n\n                                // make sure legacy \"isDvr\" prop is set\n                                angular.forEach(setTopBoxes, function (stb) {\n                                    stb.isDvr = stb.dvr;\n                                });\n\n                                getCurrentStb().then(currentStb => {\n                                    selectedStb = currentStb;\n                                    // select the first DVR box if no box already selected\n                                    if (!selectedStb) {\n                                        setTopBoxes.some(function (stb) {\n                                            if (stb.dvr) {\n                                                selectedStb = stb;\n                                                return true;\n                                            }\n                                        });\n                                    }\n\n                                    selectedStb = selectedStb || setTopBoxes[0];\n                                    setCurrentStb(selectedStb).finally(() => {\n                                        stbDefer.resolve(setTopBoxes);\n                                    });\n                                });\n                            } else {\n                                stbDefer.resolve(setTopBoxes);\n                            }\n                            setOffsetFromGMT(data.offsetFromGMT);\n                        }, function (data) {\n                            stbDefer.reject(data);\n                            // Use service prefix so unit test which references service can spy on this.\n                            service._handleHttpError('Error pulling STB.');\n                        });\n                    } else {\n                        stbDefer.resolve([]);\n                        headendDefer.resolve();\n                    }\n                }, () => {\n                    stbDefer.resolve([]);\n                    headendDefer.resolve();\n                });\n            }\n            return stbDefer.promise;\n        }\n\n        function _handleHttpError(msg) {\n            throw new ServiceError(msg);\n        }\n\n        function createCurrentStbSource() {\n            return currentStbSubject\n                .asObservable()\n                .distinctUntilChanged(x => x.macAddress, (a, b) => a === b);\n        }\n\n        function getCurrentStbPromise() {\n            return getSTBs()\n                .then(() => getCurrentStb())\n                .catch(() => undefined);\n        }\n        function getCurrentStb() {\n            return profileService.isIpOnlyEnabled()\n                .then(isEnabled => {\n                    if (isEnabled) {\n                        //If we are ipOnly enabled then the current STB is irrelevant. No STB with ipOnly mode.\n                        return undefined;\n                    } else {\n                        return retrieveCurrentStb().then(currentStb => {\n                            if (!currentStb || setTopBoxes.length === 0) {\n                                return undefined;\n                            }\n                            // Current stb comes from local storage. Match it with the latest data,\n                            //   since things such as the name may have changed.\n                            const match = setTopBoxes.find(stb => stb.macAddress === currentStb.macAddress);\n                            //legacy code names the dvr attribute isDvr\n                            if (match && angular.isDefined(match.isDvr)) {\n                                match.dvr = match.isDvr;\n                            }\n                            return match;\n                        });\n                    }\n                });\n        }\n        function setCurrentStb(stb) {\n            //write legacy isDvr attribute to cookie\n            if (angular.isDefined(stb) && angular.isObject(stb)) {\n                stb.isDvr = stb.dvr;\n            }\n\n            $rootScope.$broadcast('set-top-box-selected', stb);\n            currentStbSubject.onNext(stb);\n\n            // TODO: Analytics Event\n            // $rootScope.$emit('EG:stbSelected', {\n            //     name: stb.name,\n            //     deviceId: stb.macAddress,\n            //     isDvr: stb.dvr\n            // });\n            return storeCurrentStb(stb);\n        }\n        function postStbName(stb, newName) {\n            let url = config.piHost +\n                    config.nrsApi +\n                    config.nrs.stb + '/' +\n                    stb.macAddressNormalized + '/name';\n\n            const promise = $http({\n                method: 'POST',\n                url: url,\n                withCredentials: true,\n                data: { name : newName }\n            });\n\n            getCurrentStb().then(currentStb => {\n                if (currentStb && stb.macAddress === currentStb.macAddress) {\n                    setCurrentStb(stb);\n                }\n            });\n\n            return promise;\n        }\n        /**\n         * Get the date relative to the set top box\n         */\n        function getDate(date) {\n            let offset = date.getTimezoneOffset(),\n            stbOffset = getOffsetFromGMT() * 60;\n\n            return dateUtil.addMinutes(date, offset + stbOffset);\n        }\n        function getOffsetFromGMT() {\n            return offsetFromGMT;\n        }\n        function setOffsetFromGMT(offset) {\n            offsetFromGMT = offset;\n        }\n        function formatUnix(unixTimestampSeconds, format) {\n            let date = new Date(unixTimestampSeconds * 1000),\n                offset = date.getTimezoneOffset(),\n                stbOffset = getOffsetFromGMT() * 60;\n\n            return dateUtil.formatDate(dateUtil.addMinutes(date, offset + stbOffset), format);\n        }\n        function getDayLabel(date) {\n            let boxDate = getDate(new Date()),\n                itemDate = getDate(date),\n                dayLabel = '';\n\n            if (dateUtil.isToday(boxDate, itemDate)) {\n                dayLabel = 'Today';\n            } else if (dateUtil.isTomorrow(boxDate, itemDate)) {\n                dayLabel = 'Tomorrow';\n            } else if (dateUtil.isYesterday(boxDate, itemDate)) {\n                dayLabel = 'Yesterday';\n            } else {\n                dayLabel = dateUtil.formatDate(itemDate, 'eeee');\n            }\n            return dayLabel;\n        }\n\n        // select first non-DVR if there is one and selected device is not a DVR\n        function selectDefaultDvr() {\n            return getCurrentStb().then(currentStb => {\n                if (currentStb && !currentStb.dvr) {\n                    setTopBoxes.some(function (stb) {\n                        if (stb.dvr) {\n                            setCurrentStb(stb);\n                            return true;\n                        }\n                    });\n                }\n            });\n        }\n    }\n\n    // This function is here to allow this service to be mocked in test while\n    // allowing the stb-serviceSpec to reference the real thing here.\n    /* @ngInject */\n    function realStbService($http, $q, ServiceError, config, dateUtil, $rootScope,\n        $log, profileService,ovpStorage, storageKeys, rx) {\n        return stbService($http, $q, ServiceError, config, dateUtil, $rootScope,\n            $log, profileService, ovpStorage, storageKeys, rx);\n    }\n}());\n"],"sourceRoot":"/source/"}