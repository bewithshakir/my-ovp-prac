{"version":3,"sources":["ovpApp/guide/guide-scroll-container-directive.js"],"names":[],"mappings":"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","file":"ovpApp/guide/guide-scroll-container-directive.js","sourcesContent":["/*globals $*/\n(function () {\n    'use strict';\n\n    angular.module('ovpApp.guide')\n        .controller('GuideScrollContainerController', ContainerController)\n        .directive('guideScrollContainer', guideScrollContainerDirective);\n\n    /**\n     * The guideScrollContainer handles a large portion of the performance enhancements required to make the guide\n     * work. This includes using custom templating/compiling instead of ng-repeat. And calculating what is on screen\n     * at any given time to ensure that we don't attempty to do any calculations on anything that isn't currently\n     * visible.\n     *\n     * The high level operations\n     * - Calculate the size of the page and emit the results\n     * - Create zone containers in the page to help position the elements in the page\n     * - - Create the channel headers\n     * - - Create the channel rows\n     * - Check the scroll position to determine what zone should be displayed\n     * - broadcast the position and let channel-row-directive and guide-show-directive detemine if they should display\n     */\n    /* @ngInject */\n    function guideScrollContainerDirective($window, $compile, $interpolate, $timeout, $rootScope, favoritesService,\n        config, profileService) {\n\n        return {\n            restrict: 'E',\n            templateUrl: '/js/ovpApp/guide/guide.html',\n            controller: 'GuideScrollContainerController',\n            controllerAs: 'scroll',\n            replace: true,\n            compile: function (tElement) {\n                //Create templates from the underlying elements. This is to get around the usage of ng-repeat so that\n                //we can take some shortcuts for performance reasons.\n                let heading = tElement.find('.channel-heading');\n                //Using interpolate since the left hand channel row heading does not need need to have any active\n                //elements except the favorite 'checkbox'. This allows us to generate this only once and leave it\n                //on the page.\n                let channelHeaderTemplate = $interpolate(heading.html());\n                let channelRowContainer = tElement.find('.channel-content-list-body');\n\n                //This compiles the channel row container so that we can render each row on an as needed basis.\n                //ng-repeat was proving to be a performance bottleneck because it could only render the entire\n                //list. This helps to only execute the compiled template on rows that are currently in view.\n                let channelRowTemplate = $compile(channelRowContainer.html());\n                channelRowContainer.empty();\n                heading.empty();\n\n                return function ($scope, $element, $attr, $ctrl) {\n                    var $win = angular.element($window),\n                        viewportHeight,\n                        pixelsPerHour,\n                        pixelsPerChannel = 76,\n                        topPos = 0,\n                        lastTopPos = 0,\n                        lastTopTime = 0,\n                        allRowScopes = [],\n                        disableResize = false,\n                        pendingResize = false;\n\n                    if ($element.is(':visible')) {\n                        onceVisible();\n                    } else {\n                        $timeout(onceVisible, 50);\n                    }\n\n                    $win.on('scroll', onScroll);\n                    $win.on('resize', pixelsPerHourCalc);\n\n                    $scope.$on('$destroy', function () {\n                        $win.off('scroll', onScroll);\n                        $win.off('resize', pixelsPerHourCalc);\n                    });\n\n                    $element.find('.channel-heading').on('focus', (ev) => {\n                        //Pass the focus to the first channel header.\n                        ev.target.firstChild.firstChild.focus();\n                    });\n\n                    function focusNextChannelHeader(ev) {\n                        if (!ev.target.nextElementSibling) {\n                            if (ev.target.parentNode.nextElementSibling &&\n                                ev.target.parentNode.nextElementSibling.firstChild) {\n                                angular.element(ev.target.parentNode.nextElementSibling.firstChild).focus();\n                            }\n                        } else {\n                            angular.element(ev.target.nextElementSibling).focus();\n                        }\n                        ev.preventDefault();\n                        ev.stopPropagation();\n                    }\n\n                    function focusPrevChannelHeader(ev) {\n                        if (!ev.target.previousElementSibling) {\n                            if (ev.target.parentNode.previousElementSibling &&\n                                ev.target.parentNode.previousElementSibling.lastChild) {\n                                angular.element(ev.target.parentNode.previousElementSibling.lastChild).focus();\n                            }\n                        } else {\n                            angular.element(ev.target.previousElementSibling).focus();\n                        }\n                        ev.preventDefault();\n                        ev.stopPropagation();\n                    }\n\n                    function favoriteAria(chan) {\n                        const hasChanNumber = !profileService.isSpecU() && angular.isDefined(chan.channelNumber);\n                        const chanNumber = hasChanNumber ? `, Channel ${chan.channelNumber}` : '';\n                        const favorite = chan.favorite ? ' Favorite' : '';\n                        return `${chan.callSign}${chanNumber}${favorite}`;\n                    }\n\n                    //Click handler for the favorite icon, listens on the entire list and locates clock events\n                    $element.find('.channel-heading').on('click keydown', '.channel-header-row', (ev) => {\n                        const keys = {\n                            left: 37,\n                            up: 38,\n                            down: 39,\n                            right: 40,\n                            tab: 9,\n                            space: 32,\n                            enter: 13\n                        };\n                        let clickTarget = angular.element(ev.target);\n                        if (!clickTarget.is('.channel-header-row')) {\n                            clickTarget = clickTarget.parents('.channel-header-row');\n                        }\n                        let channelIndex = clickTarget.attr('channel-index');\n                        let el = clickTarget.find('.favorite');\n                        let chan = $scope.vm.channels.find(channel => channelIndex == channel.globalIndex);\n                        if (ev.keyCode === keys.down || ev.keyCode === keys.right) {\n                            focusNextChannelHeader(ev);\n                        } else if (ev.keyCode === keys.left || ev.keyCode === keys.up) {\n                            focusPrevChannelHeader(ev);\n                        } else if (ev.keyCode === keys.tab) {\n                            if (ev.shiftKey) {\n                                // Shift + tab handling\n                                angular.element('.channel-filter a.filter').last().focus();\n                            } else {\n                                //Move focus to first grid cell of that channel;\n                                $scope.vm.setFocus(null, chan);\n                            }\n                            ev.preventDefault();\n                            ev.stopPropagation();\n                        }\n                        // Enter and Space and Click handling\n                        if (ev.keyCode === keys.enter || ev.keyCode === keys.space || ev.type == 'click') {\n                            if (chan) {\n                                chan.favorite = !chan.favorite;\n                                favoritesService.toggleFavorite(\n                                   chan);\n                                el.toggleClass('favon');\n                                clickTarget.attr('aria-label', favoriteAria(chan));\n                            }\n                            ev.preventDefault();\n                        }\n                    });\n\n                    $scope.$on('guide:updateZones', function () {\n                        buildChannelZoneElements($scope.vm.zoneData);\n                        let count = $scope.vm.zoneData.reduce((mem, zone) => {\n                            return zone.zoneChannels.length + mem;\n                        }, 0);\n                        $('#guideAlert').html('<span >' + count + ' channels in filter</span>');\n                        $ctrl.forceFetchCurrent();\n                    });\n\n                    //Called when the guide data needs refreshing\n                    $scope.$on('guide:invalidateData', function () {\n                        $ctrl.forceFetchCurrent();\n                    });\n\n                    $scope.$on('guide:inactivate', function () {\n                        disableResize = true;\n                    });\n\n                    $scope.$on('guide:reactivate', function () {\n                        disableResize = false;\n                        if (pendingResize) {\n                            $timeout(pixelsPerHourCalc, 0);\n                        }\n                    });\n\n                    function onScroll() {\n                        topPos = $win.scrollTop();\n                        let scrollTime = Date.now();\n                        let currentVelocity = $ctrl.calculateVelocity(lastTopTime, lastTopPos, scrollTime, topPos);\n                        $ctrl.scrollHandler(null, topPos, currentVelocity);\n                        lastTopTime = scrollTime;\n                        lastTopPos = topPos;\n                    }\n\n                    /**\n                     * Calculate the sizes for different elements\n                     */\n                    function onceVisible() {\n                        pixelsPerHourCalc();\n                        buildChannelZoneElements($scope.vm.zoneData);\n                        pixelsPerChannel = $element.find('.channel-header-row').height() ||\n                        pixelsPerChannel;\n                        //initialize the channels that are in the display at start.\n                        topPos = $win.scrollTop();\n                        $ctrl.forceFetchCurrent();\n                    }\n\n                    function pixelsPerHourCalc() {\n                        if (disableResize) {\n                            pendingResize = true;\n                            return;\n                        } else {\n                            pendingResize = false;\n                        }\n\n                        viewportHeight = $win.height() - $element.offset().top;\n                        let containerWidth = $element.find('.channel-content-list-container').width();\n                        pixelsPerHour = containerWidth / 2;\n\n                        //Channels per zone\n                        $ctrl.setZoneSize(\n                            Math.ceil((viewportHeight / pixelsPerChannel) * config.guide.zoneHeightMultiplier),\n                            2 * config.guide.zoneWidthMultiplier,\n                            pixelsPerChannel,\n                            pixelsPerHour,\n                            2 * pixelsPerHour,\n                            viewportHeight\n                        );\n                    }\n\n                    function buildChannelZoneElements(channelZones) {\n                        var heading = $element.find('.channel-heading'),\n                            listContainer = $element.find('.channel-content-list-body'),\n                            zoneHtml = '',\n                            headingZoneHtml = '',\n                            genZoneWrapper = (zone, height, width) => {\n                                return `<div style=\"width:${width}px; height:${height}px;\"\n                                    id=\"${zone.zone_el_id}\" class=\"zone\" role=\"presentation\"></div>`;\n                            };\n                        //This clears and removes all old elements\n                        allRowScopes.forEach(cs => cs.$destroy());\n                        allRowScopes = [];\n\n\n                        channelZones.forEach((zone) => {\n                            /*\n                             * This compiles the each channel and appends it to the page. This only happens when the\n                             * filters are updated and causes the ng-repeat to not add a watcher - and keeps each row\n                             * relatively lightweight performance wise.\n                             */\n                            zone.zone_el_id = 'zone_idx_' + zone.zoneIndex;\n                            zoneHtml += genZoneWrapper(zone,\n                                zone.zoneChannels.length * pixelsPerChannel,\n                                pixelsPerHour * 24 * 14);\n\n                            headingZoneHtml += createChannelHeadersHtml(zone);\n                        });\n                        //Append static text, probably should use the requestAnimationFrame here\n                        listContainer.html(zoneHtml);\n                        heading.html(headingZoneHtml);\n\n                        channelZones.forEach((zone) => {\n                            zone.domElement = listContainer.find('#' + zone.zone_el_id);\n                            zone.elements = [];\n                            zone.scopes = [];\n                            zone.zoneChannels.forEach(function (channel) {\n                                let $childScope = $scope.$new();\n                                $childScope.channel = channel;\n                                $childScope.zone = zone;\n                                allRowScopes.push($childScope);\n                                channelRowTemplate($childScope, function (el, sc) {\n                                    zone.domElement.append(el);\n                                    zone.elements.push(el);\n                                    zone.scopes.push(sc);\n                                    channel.listingsElement = el;\n                                });\n                            });\n\n                        });\n                    }\n\n                    function createChannelHeadersHtml(zone) {\n                        //This builds the channel list as static html so there are _no_ watchers\n                        var channelsHtml = '';\n                        zone.zoneChannels.forEach(function (channel) {\n                            const noChannelNumber = profileService.isSpecU() ||\n                                !angular.isDefined(channel.channelNumber);\n                            const channelAria = channel.callSign +\n                                (noChannelNumber ? '' : ', Channel ' + channel.channelNumber) +\n                                (channel.favorite ? ', favorite set' : '');\n\n                            channelsHtml += channelHeaderTemplate({\n                                channel: channel,\n                                favOn: (channel.favorite) ? 'favon' : '',\n                                noChannelNumber: noChannelNumber ? 'no-channel-number' : '',\n                                channelAria: channelAria\n                            });\n                        });\n                        return `<div style=\"height: ${zone.zoneChannels.length * pixelsPerChannel};\"\n                            class=\"channel-header-zone zone\">${channelsHtml}</div>`;\n                    }\n                };\n            }\n        };\n    }\n\n    /* @ngInject */\n    function ContainerController($scope, $window, config, $timeout) {\n        var vm = this,\n            channelZoneSize, //Integer number of channels in a single zone\n            timeZoneSize, //Integer number of hours in a single zone\n            pixelsPerHour,\n            pixelsPerChannel,\n            viewportWidth = 0,\n            viewportHeight = 0,\n            timePos = 0,\n            topPos = 0,\n            lastFetchedZones,\n            lastScrollTime,\n            lastPixPerSecond,\n            adjacentZoneDistance = config.guide.prefetchDistance,\n            zoneUpdateData = debounce(fetchZoneData, 100, false),\n            zoneUpdateDisplay = debounce(fireZoneUpdateDisplay, 200, false),\n            virtualViewportWidth = 0,\n            virtualViewportHeight = 0;\n\n        vm.setZoneSize = setZoneSize;\n        vm.getZones = getZones;\n        vm.getPixelsPerHour = getPixelsPerHour;\n        vm.scrollHandler = scrollHandler;\n        vm.calculateVelocity = calculateVelocity;\n        vm.adjacentZone = adjacentZone;\n        vm.scrollingPaused = true;\n        vm.forceFetchCurrent = forceFetchCurrent;\n\n        $scope.getPos = function () {\n            return {\n                channelIndex: Math.ceil(topPos / pixelsPerChannel),\n                hour: Math.floor(timePos / pixelsPerHour),\n                scroll: {\n                    top: topPos,\n                    left: timePos\n                }\n            };\n        };\n\n        $scope.setPos = function (scroll) {\n            angular.element($window).scrollTop(scroll.top);\n            angular.element('channel-content-list-container').scrollLeft(scroll.left);\n        };\n\n        $scope.setChannelPos = function (channelIndex) {\n            $scope.setPos({top: channelIndex * pixelsPerChannel, left: undefined});\n        };\n\n        /**\n         * Set the zone size. To calculate he actual pixel width of the channel, you can multiply ts * pixelsPerHour\n         * @param {int} cs                channels per zone, \"a zone is 'cs' channels tall\"\n         * @param {int} ts                time per zone, \"a zone is 'ts' hours wide\"\n         * @param {int} _pixelsPerChannel a channel listing is x pixels tall\n         * @param {int} _pixelsPerHour    an hour is x pixels wide\n         */\n        function setZoneSize(cs, ts, _pixelsPerChannel, _pixelsPerHour, width, height) {\n            channelZoneSize = cs;\n            timeZoneSize = ts;\n            pixelsPerChannel = _pixelsPerChannel;\n            pixelsPerHour = _pixelsPerHour;\n            viewportWidth = width;\n            viewportHeight = height;\n            virtualViewportWidth = viewportWidth * config.guide.viewportWidthMultiplier;\n            virtualViewportHeight = viewportHeight * config.guide.viewportHeightMultiplier;\n            $scope.$emit('guide:zonesize', channelZoneSize, timeZoneSize);\n        }\n\n        /**\n         * Return the pixelsPerHour, this is used by the guide-show-directive to calculate the position of show\n         *\n         * @return {int} pixelsPerHour\n         */\n        function getPixelsPerHour() {\n            return pixelsPerHour;\n        }\n\n        /**\n         * Get the zones that are currently displayed on the screen.\n         *\n         * @param  {int} left the left most pixel positon displayed on the screen.\n         * @param  {int} top  the top most pixel on the screen.\n         * @return {int[int[][]]} array of zone indexes\n         */\n        function getZones(left, top) {\n            var pixelsPerTimeZone = pixelsPerHour * timeZoneSize,\n                pixelsPerChannelZone = pixelsPerChannel * channelZoneSize;\n\n            left = (left < 0) ? 0 : left;\n            top = (top < 0) ? 0 : top;\n\n            let topLeft = [\n                Math.floor(left / pixelsPerTimeZone),\n                Math.floor(top / pixelsPerChannelZone)\n            ];\n            let bottomRight = [\n                Math.floor((left + virtualViewportWidth) / pixelsPerTimeZone),\n                Math.floor((top + virtualViewportHeight) / pixelsPerChannelZone)\n            ];\n\n            let topRight = [bottomRight[0], topLeft[1]]; //brX, tlY\n            let bottomLeft = [topLeft[0], bottomRight[1]];//brY, tlX\n            let zones = [topLeft, bottomRight, topRight, bottomLeft].reduce((memo, checkZone) => {\n                if (!memo.some(addedZone => addedZone[0] === checkZone[0] && addedZone[1] === checkZone[1])) {\n                    memo.push(checkZone);\n                }\n                return memo;\n            }, []);\n\n            return zones;\n        }\n\n        function scrollHandler(_timePos, _topPos, pixPerSecond = 0, force = false) {\n            let currentTime = Date.now();\n            let diffTime = -1;\n            if (lastScrollTime) {\n                diffTime = currentTime - lastScrollTime;\n            }\n            lastScrollTime = currentTime;\n            lastPixPerSecond = pixPerSecond;\n\n            if (_timePos !== null) {\n                timePos = _timePos;\n            }\n            if (_topPos !== null) {\n                topPos = _topPos;\n            }\n\n            let zones = getZones(timePos, topPos);\n            let channelZones = zones.map((zone) => zone[1]);\n            let timeZones = zones.map((zone) => zone[0]);\n\n            //Only trigger if we have scrolled into a new zone\n            if (!angular.equals(zones, vm.zones) || force) {\n                //We are in a new zone\n                vm.channelZones = channelZones;\n                vm.timeZones = timeZones;\n                vm.zones = zones;\n                zoneUpdateData();\n                zoneUpdateDisplay();\n            }\n        }\n\n        function forceFetchCurrent() {\n            let zones = getZones(timePos, topPos);\n            let channelZones = zones.map((zone) => zone[1]);\n            let timeZones = zones.map((zone) => zone[0]);\n            vm.channelZones = channelZones;\n            vm.timeZones = timeZones;\n            vm.zones = zones;\n            lastFetchedZones = null; //Update to force the fetch\n            fetchZoneData();\n            fireZoneUpdateDisplay();\n        }\n\n        function fireZoneUpdateDisplay() {\n            //Update these zones\n            vm.currentChannelZone = vm.channelZones;\n            vm.currentTimeZone = vm.timeZones;\n            $scope.$broadcast('displayZone',  vm.currentChannelZone, vm.currentTimeZone);\n        }\n\n        function fetchZoneData() {\n            if (!angular.equals(lastFetchedZones, vm.zones)) {\n                lastFetchedZones = vm.zones;\n                $scope.$emit('guide:currentZone', vm.zones);\n            }\n        }\n\n        function calculateVelocity(lastTime, lastPos, currentTime, currentPos) {\n            if (lastTime > 0) {\n                let diffTime = lastTime - currentTime;\n                let diffPos = currentPos - lastPos;\n                let pixPerSecond = Math.abs((diffPos / diffTime) * 1000);\n                return pixPerSecond;\n            } else {\n                return 0;\n            }\n        }\n\n        function adjacentZone(zone, visibleZones) {\n            return visibleZones.some(vz => ((vz + adjacentZoneDistance) >= zone &&\n                (vz - adjacentZoneDistance) <= zone));\n        }\n\n        function debounce(func, wait, immediate) {\n            var timeout;\n            return function () {\n                var context = this, args = arguments;\n                var later = function () {\n                    timeout = null;\n                    func.apply(context, args);\n                };\n                var callNow = immediate && !timeout;\n                $timeout.cancel(timeout);\n                timeout = $timeout(later, wait);\n                if (callNow) {\n                    func.apply(context, args);\n                }\n            };\n        }\n    }\n}());\n"],"sourceRoot":"/source/"}