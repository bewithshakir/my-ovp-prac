{"version":3,"sources":["ovpApp/analytics/events/playback.js"],"names":[],"mappings":"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","file":"ovpApp/analytics/events/playback.js","sourcesContent":["(function () {\n    'use strict';\n\n    angular.module('ovpApp.analytics.events.playback', [\n        'ovpApp.analytics.analyticsService',\n        'ovpApp.analytics.analyticsAssetHelper'\n    ])\n    .factory('playback', playbackEvents)\n    .run(function loadHandler(playback) {\n            return playback;\n        });\n\n    /* @ngInject */\n    function playbackEvents($rootScope, analyticsService, $log, config,\n        $transitions, analyticsAssetHelper, $state, playerService) {\n\n        let state = analyticsService.state;\n\n        // Flag for tracking that we were in a 'paused' state when buffering began.\n        // We track this because we'll need to resume buffering after unpausing.\n        let resumeBufferingAfterUnpause = false;\n\n        $rootScope.$on('Analytics:playerInitialized', (e, player) => {\n            attachEventListeners(player);\n            state.setPlayer(player);\n        });\n\n        // Attach to root scope during init time so listeners are ready before\n        // player is initialized.\n        $rootScope.$on('playback-resumed', resumeStream);\n        $rootScope.$on('Analytics:initiateNewStream', initiateNewStream);\n\n        // On logout, stop any ongoing playbacks.\n        $rootScope.$on('Analytics:haltPlaybackFromLogout', haltPlaybackFromLogout);\n\n        /**\n         * Event handler for capturing when the player's end time (media duration)\n         * has changed.\n         * @param e event with new media duration.\n         */\n        function endPositionChanged(e) {\n            // Update the 'selectedContent' object that tracks the media about to\n            // be played.\n            state.setActualRuntimeMs(e.endPosition);\n        }\n\n        /**\n         * Player is resuming a stream that is already loaded. It will not generate\n         * any select or uri-acquired events, so we'll have to replay the last\n         * ones that we captured to put the SDK into the correct state.\n         */\n        function resumeStream(/* e */) {\n            if (analyticsService.isDebug()) {\n                $log.debug('Analytics: Resuming previous stream');\n            }\n\n            // Hold on to the stream start events now, since the 'select' will\n            // delete our existing selectedContent object.\n            let selectEvent = state.getLastSelectEvent();\n            let streamUriEvent = state.getLastStreamUriEvent();\n            let startEvent = {bitrate: state.getBitrate()};\n            let playbackType = state.getLastPlaybackType();\n\n            // Safety check: Cannot resume stream if we don't have the setup events.\n            if (null === selectEvent ||\n                null === streamUriEvent ||\n                null === playbackType) {\n                $log.error('Analytics: Cannot resume stream due to missing events or playbackType',\n                    selectEvent, streamUriEvent, playbackType);\n                return;\n            }\n\n            // Replay the stream setup events.\n            if ('linear' === playbackType) {\n                channelChanged(selectEvent);\n            } else if ('vod' === playbackType) {\n                vodContentSelected(selectEvent);\n            } else if ('dvr' === playbackType) {\n                cdvrContentSelected(selectEvent);\n            } else {\n                $log.error('Analytics: unrecognized playbackType:' + playbackType);\n            }\n            streamUriObtained(streamUriEvent);\n            playbackStarted(startEvent);\n        }\n\n        return {\n            channelChanged,\n            endPositionChanged,\n            resumeStream,\n            initiateNewStream,\n            vodContentSelected,\n            cdvrContentSelected,\n            streamUriObtained,\n            playbackStarted,\n            playerPositionChanged,\n            pauseToggled,\n            bufferingStarted,\n            bufferingStopped,\n            scrubJump,\n            bitrateChanged,\n            playbackStopped,\n            adBreakStopped,\n            adBreakStarted,\n            adStarted,\n            adStopped,\n            adTracking,\n            isPlaying\n        };\n\n        function playerPositionChanged(e) {\n            try {\n                analyticsService.setPlayerPosition(Math.floor(e.PlaybackTimestamp));\n            }\n            catch (ex) {\n                $log.error(ex);\n            }\n        }\n\n        function haltPlaybackFromLogout() {\n            try {\n                if (analyticsService.isDebug()) {\n                    $log.debug('Analytics: haltPlaybackFromLogout');\n                }\n                playbackStopped();\n            }\n            catch (ex) {\n                $log.error(ex);\n            }\n        }\n\n        function pauseToggled(enabled) {\n            try {\n                if (analyticsService.isDebug()) {\n                    $log.debug('Analytics: pauseToggled enabled=' + enabled + ', resumeBufferingAfterUnpause=' +\n                        resumeBufferingAfterUnpause);\n                }\n                let event;\n                if (enabled) {\n                    event = 'playbackPause';\n                } else {\n                    event = 'playbackUnpause';\n                }\n\n                // If we are buffering when pause begins, we need to end the buffering\n                // in order to transition to the 'paused' state.\n                if (event === 'playbackPause' && 'buffering' === analyticsService.getCurrentLibraryState()) {\n                    bufferingStopped();\n                    resumeBufferingAfterUnpause = true;\n                } else if (event === 'playbackUnpause' && 'buffering' === analyticsService.getCurrentLibraryState()) {\n                    // Do what...\n                    if (analyticsService.isDebug()) {\n                        $log.debug('Analytics: Discarding unpause due to ongoing buffering');\n                    }\n                    resumeBufferingAfterUnpause = false;\n                    return;\n                }\n\n                analyticsService.event(event, {triggeredBy: 'user'});\n\n                // Resume buffering if we were buffering before unpausing.\n                if (event === 'playbackUnpause' && resumeBufferingAfterUnpause) {\n                    resumeBufferingAfterUnpause = false;\n                    bufferingStarted();\n                }\n            }\n            catch (ex) {\n                $log.error(ex);\n            }\n        }\n\n        /**\n         * React to a request to play the given stream.\n         * @param e event\n         * @param data Event data, including the stream requested for playback.\n         */\n        function initiateNewStream(e, data) {\n            try {\n                if (analyticsService.isDebug()) {\n                    $log.debug('Analytics: initiateNewStream', data);\n                }\n\n                // Capture the requested stream for use in later event processing.\n                state.setExpectedStream(data.stream);\n            } catch (ex) {\n                $log.error(ex);\n            }\n        }\n\n        function channelChanged(e) {\n            try {\n                if (analyticsService.isDebug()) {\n                    $log.debug('Analytics: channelChanged (select). Playing=' + isPlaying(), e);\n                }\n\n                if (isPlaying()) {\n                    playbackStopped({TriggeredBy: 'channelChange'});\n                }\n\n                // Is this a dupe for a previous select that we aren't yet playing?\n                else if (state.getLastSelectEvent() &&\n                    state.getSelectedContent() &&\n                    (!state.getLastStreamUriEvent() || !state.getLastPlaybackStartedEvent()) &&\n                    'linear' === state.getLastPlaybackType() &&\n                    state.getSelectedContent().tmsProgramId === analyticsAssetHelper.getTmsProgramId(e.channel.asset)) {\n\n                    $log.debug('Analytics: Dropping duplicate linear select event', e);\n                    return;\n                }\n\n                // Send a playbackExitBeforeStart event if we've selected content previously,\n                // but never began playing it. (i.e. no playbackStart event yet)\n                let exitBeforeStart = state.getLastSelectEvent() && !state.getLastPlaybackStartedEvent();\n                if (exitBeforeStart && 'failed' !== analyticsService.getCurrentLibraryState()) {\n                    analyticsService.event('playbackExitBeforeStart', {});\n                }\n\n                // Track the most recently selected content, and retain it in case\n                // we need to replay it later as the result of a playback-resumed event.\n                state.setLastPlaybackType('linear');\n                state.setLastSelectEvent(e);\n                state.setLastStreamUriEvent(null);\n                state.setLastPlaybackStartedEvent(null);\n\n                // Capture details of the currently selected content.\n                state.setSelectedContent({\n                    type: 'linear',\n                    channelId: e.channel.channelId,\n                    tmsGuideId: e.channel.tmsId,\n                    tmsProgramIds: e.channel.asset.tmsProgramIds,\n                    tmsProgramId: analyticsAssetHelper.getTmsProgramId(e.channel.asset)\n                });\n\n                // Suppress this event if we're not on a playback page, but keep the\n                // source event in case we need to resume the stream.\n                if (!playerService.isValidPlayRoute()) {\n                    return;\n                }\n\n                let data = {\n                    contentClass: 'linear',\n                    playbackType: 'linear',\n                    elementStandardizedName: 'liveTvWatch',\n                    pageSectionName: 'conversionArea',\n                    // CAUTION: The incoming event has a 'triggeredBy' field, but it's\n                    // from the player domain, not analytics, and so is not usable here.\n                    triggeredBy: 'user',\n                    drmType: 'adobePrimeTime',\n                    scrubbingCapability: 'none',\n                    closedCaptioningCapable: true,\n                    sapCapable: false,\n                    entitled: true,\n                    operationType: 'playbackPlaySelected'\n                };\n\n                analyticsAssetHelper.populateChannelData(data, e.channel);\n                analyticsAssetHelper.populateAssetData(data, e.channel.asset);\n                analyticsAssetHelper.populateStreamData(data, e.channel.streams[0]);\n                analyticsAssetHelper.populateEventData(data, e);\n\n                analyticsService.event('playbackSelect', data);\n\n                // Any playbackSelect event clears the search state.\n                $rootScope.$broadcast('Analytics:search-reset');\n\n                // Clear out the expected stream\n                state.setExpectedStream(null);\n\n            } catch (ex) {\n                $log.error(ex);\n            }\n        }\n\n        function vodContentSelected(e) {\n\n            if (analyticsService.isDebug()) {\n                $log.debug('Analytics: vodContentSelected (select)', e);\n            }\n\n            try {\n                let asset = e.asset;\n\n                // Track the most recently selected content, and retain it in case\n                // we need to replay it later as the result of a playback-resumed event.\n                state.setLastPlaybackType('vod');\n                state.setLastSelectEvent(e);\n                state.setLastStreamUriEvent(null);\n                state.setLastPlaybackStartedEvent(null);\n\n                // Capture details of the currently selected content.\n                // Suppress this event if we're not on a playback page, but keep the\n                // source event in case we need to resume the stream.\n                if (!playerService.isValidPlayRoute()) {\n                    return;\n                }\n\n                // let data = analyticsAssetHelper.populateVodData({}, e.channel.asset, asset.defaultStream, e);\n                let data = {\n                    playbackType: 'vod',\n                    triggeredBy: 'user',\n                    elementStandardizedName: e.elementStandardizedName,\n                    pageSectionName: 'conversionArea',\n                    drmType: 'adobePrimeTime',\n                    scrubbingCapability: 'all',\n                    sapCapable: false\n                };\n\n                analyticsAssetHelper.populateAssetData(data, asset);\n\n                // Attempt to use the requested stream for playback to populate event.\n                let expectedStream = state.getExpectedStream();\n                if (expectedStream) {\n                    analyticsAssetHelper.populateStreamData(data, expectedStream);\n                } else {\n                    analyticsAssetHelper.populateStreamData(data, asset.defaultStream);\n                }\n                analyticsAssetHelper.populateTvodData(data, asset);\n                analyticsAssetHelper.populateEventData(data, e);\n\n                // Capture all tmsProgramIds, since there could be more than one,\n                // and we don't always know which one will be used by the stream.\n                state.setSelectedContent({\n                    type: 'vod',\n                    tmsProgramId: data.tmsProgramId,\n                    tmsProgramIds: asset.tmsProgramIds\n                });\n\n                // If this is tvod content, add the featureStepName\n                if ('rent' === data.purchaseType) {\n                    data.featureStepName = 'playbackSelect';\n                }\n\n                // Override contentClass for TVOD trailers, if needed.\n                let isTrailer = ($state.params && $state.params.trailer &&\n                    $state.params.trailer === 'true') || false;\n                if (isTrailer) {\n                    if (analyticsService.isDebug()) {\n                        $log.debug('Analytics: Overriding contentClass to trailer', isTrailer);\n                    }\n                    data.contentClass = 'trailer';\n                }\n\n                // Capture TVOD stream details.\n                if (analyticsService.isDebug()) {\n                    $log.debug('Analytics: isTvod? isTvodEntitled=' + asset.isTvodEntitled);\n                }\n\n                if (analyticsAssetHelper.isTvodAsset(asset)) {\n\n                    // If we just purchased this, connect this to the rest of the\n                    // tvod flow.\n                    let purchaseInfo = state.getLatestPurchase();\n                    if (analyticsService.isDebug()) {\n                        $log.debug('Analytics: (tvod) comparing purchaseInfo to asset',\n                            purchaseInfo, e.asset);\n                    }\n\n                    // We only count this as part of the TVOD flow if this is\n                    // happening immediately after purchase.\n                    if (purchaseInfo &&\n                        purchaseInfo.tmsProgramId === data.tmsProgramId) {\n                        if (analyticsService.isDebug()) {\n                            $log.debug('Analytics: (tvod) Applying TVOD properties to playbackSelect event');\n                        }\n\n                        let tvodFlow = state.getTvodFlowState();\n                        if (tvodFlow) {\n                            tvodFlow.featureCurrentStep = tvodFlow.featureNumberOfSteps;\n                            angular.extend(data, tvodFlow);\n                        }\n                        data.purchaseId = purchaseInfo.purchaseId;\n                    }\n\n                    // Always clear the purchase info at this point, since we're\n                    // either done with this part of the TVOD flow, or else not\n                    // in the TVOD flow at all.\n                    if (purchaseInfo) {\n                        state.setLatestPurchase(null);\n                    }\n                }\n\n                analyticsService.event('playbackSelect', data);\n\n                // Any playbackSelect event clears the search state.\n                $rootScope.$broadcast('Analytics:search-reset');\n\n                // Clear out the expected stream\n                state.setExpectedStream(null);\n\n                // Clear any potential tvodFlow state\n                state.setTvodFlowState(null);\n\n            } catch (ex) {\n                $log.error(ex);\n            }\n        }\n\n        function cdvrContentSelected(e) {\n            try {\n                if (analyticsService.isDebug()) {\n                    $log.debug('Analytics: cdvrContentSelected (select)', e);\n                }\n\n                // Track the most recently selected content, and retain it in case\n                // we need to replay it later as the result of a playback-resumed event.\n                state.setLastPlaybackType('dvr');\n                state.setLastSelectEvent(e);\n                state.setLastStreamUriEvent(null);\n                state.setLastPlaybackStartedEvent(null);\n\n                // Capture details of the currently selected content.\n                state.setSelectedContent({\n                    type: 'cdvr',\n                    tmsProgramId: e.asset.cdvrRecording.tmsProgramId,\n                    recordingId: e.asset.cdvrRecording.recordingId\n                });\n\n                // Suppress this event if we're not on a playback page, but keep the\n                // source event in case we need to resume the stream.\n                if (!playerService.isValidPlayRoute()) {\n                    return;\n                }\n\n                let data = {\n                    contentClass: 'cdvr',\n                    playbackType: 'dvr',\n                    triggeredBy: 'user',\n                    elementStandardizedName: 'asset',\n                    pageSectionName: 'conversionArea',\n                    drmType: 'adobePrimeTime',\n                    scrubbingCapability: 'all',\n                    sapCapable: false\n                };\n\n                analyticsAssetHelper.populateAssetData(data, e.asset);\n\n                // Attempt to use the requested stream for playback to populate event.\n                let expectedStream = state.getExpectedStream();\n                if (expectedStream) {\n                    analyticsAssetHelper.populateStreamData(data, expectedStream);\n                } else {\n                    analyticsAssetHelper.populateStreamData(data, e.stream);\n                }\n\n                analyticsAssetHelper.populateEventData(data, e);\n\n                analyticsService.event('playbackSelect', data);\n\n                // Any playbackSelect event clears the search state.\n                $rootScope.$broadcast('Analytics:search-reset');\n\n                // Clear out the expected stream\n                state.setExpectedStream(null);\n            } catch (error) {\n                $log.error(error);\n            }\n        }\n\n        function streamUriObtained(e) {\n            try {\n                if (analyticsService.isDebug()) {\n                    $log.debug('Analytics: streamUriObtained, page=' + state.getCurrentPageName(),\n                        state.getSelectedContent(), e);\n                }\n\n                let selectedContent = state.getSelectedContent();\n\n                // But, is this the most recently selected content? Or something old?\n                // Discard this URI obtained event if it doesn't match the most recent\n                // playback selection.\n                if (selectedContent.type === 'linear' &&\n                    (selectedContent.channelId !== e.contentMetadata.channelId)) {\n                    if (analyticsService.isDebug()) {\n                        $log.debug('Analytics: Discarding linear URI event due to mismatch');\n                    }\n\n                    // Sometmies the streamUriObtained event lists one of the alternate\n                    // tmsProgramIds for the same asset. This logic allows us to catch\n                    // the switch and continue playback instead of just discarding this\n                    // event as a mismatch.\n                    if (selectedContent.tmsProgramIds &&\n                        selectedContent.tmsProgramIds.indexOf(e.contentMetadata.tmsProgramId) >= 0) {\n\n                        selectedContent.tmsProgramId = e.contentMetadata.tmsProgramId;\n                    } else {\n                        return;\n                    }\n                    return;\n                } else if (selectedContent.type === 'vod' &&\n                    (selectedContent.tmsProgramId !== e.contentMetadata.tmsProgramId)) {\n                    if (analyticsService.isDebug()) {\n                        $log.debug('Analytics: Discarding VOD URI event due to tmsProgramId mismatch:' +\n                            selectedContent.tmsProgramId + ' vs ' + e.contentMetadata.tmsProgramId);\n                    }\n\n                    // Sometmies the streamUriObtained event lists one of the alternate\n                    // tmsProgramIds for the same asset. This logic allows us to catch\n                    // the switch and continue playback instead of just discarding this\n                    // event as a mismatch.\n                    if (selectedContent.tmsProgramIds &&\n                        selectedContent.tmsProgramIds.indexOf(e.contentMetadata.tmsProgramId) >= 0) {\n\n                        selectedContent.tmsProgramId = e.contentMetadata.tmsProgramId;\n                    } else {\n                        return;\n                    }\n                } else if (selectedContent.type === 'cdvr' &&\n                    (selectedContent.tmsProgramId !== e.contentMetadata.cdvrRecording.tmsProgramId ||\n                    selectedContent.recordingId !== e.contentMetadata.cdvrRecording.recordingId)) {\n                    if (analyticsService.isDebug()) {\n                        $log.debug('Analytics: Discarding CDVR URI event due to mismatch');\n                    }\n                    return;\n                }\n\n                // Is this a duplicate for a streamUriObtained event we have already received?\n                if (state.getLastStreamUriEvent()) {\n                    $log.debug('Analytics: Dropping duplicate streamUriObtained event', e);\n                    return;\n                }\n\n                // Record the fact that we've received our URI event.\n                selectedContent.receivedUri = true;\n\n                // Record the incoming event, in case we need to replay it later\n                // due to a playback-resumed event.\n                state.setLastStreamUriEvent(e);\n\n                // Suppress this event if we're not on a playback page, but keep the\n                // source event in case we need to resume the stream.\n                if (!playerService.isValidPlayRoute()) {\n                    return;\n                }\n\n                let data = {\n                    contentUri: e.stream.stream_url || undefined,\n                    success: true\n                };\n\n                analyticsService.event('playbackStreamUriAcquired', data);\n            }\n            catch (ex) {\n                $log.error(ex);\n            }\n        }\n\n        function playbackStarted(e) {\n            try {\n                if (analyticsService.isDebug()) {\n                    $log.debug('Analytics: playbackStarted', e);\n                }\n                let deferred;\n\n                let selectedContent = state.getSelectedContent();\n\n                // If we're still waiting for the URI from our most recent\n                // playbackSelect event, then discard this playback event.\n                // This usually happens when the user is rapidly changing\n                // channels in live tv.\n                if (!selectedContent.receivedUri) {\n                    if (analyticsService.isDebug()) {\n                        $log.debug('Analytics: Discarding play event; have not ' +\n                            'yet received URI event', e);\n                    }\n                    return;\n                }\n\n                // If we've already received this event, igore it as a duplicate.\n                if (state.getLastPlaybackStartedEvent()) {\n                    $log.debug('Analytics: Discarding duplicate playbackStarted event');\n                    return;\n                }\n\n                state.setBitrate(e.bitrate);\n                let data = {\n                    triggeredBy: 'application',\n                    playPointTimestamp: Date.now(),\n                    currentBitRateBps: e.bitrate,\n                    numberOfAudioSources: (e.audioTracks) ? e.audioTracks.length : -1,\n                    actualRuntime: state.getActualRuntimeMs()\n                };\n\n                if (state.hasDeferredEvent('adBreakStart')) {\n                    deferred = 'adBreakStart';\n                }\n\n                selectedContent.playbackStartedEvent = e;\n\n                // Record the incoming event, in case we need to replay it later\n                // due to a playback-resumed event.\n                state.setLastPlaybackStartedEvent(e);\n\n                // Suppress this event if we're not on a playback page, but keep the\n                // source event in case we need to resume the stream.\n                if (!playerService.isValidPlayRoute()) {\n                    return;\n                }\n\n                analyticsService.event('playbackStart', data, deferred);\n            }\n            catch (ex) {\n                $log.error(ex);\n            }\n        }\n\n        function bufferingStarted() {\n            try {\n                if (analyticsService.isDebug()) {\n                    $log.debug('Analytics: bufferingStarted, resumeBufferingAfterUnpause=' +\n                        resumeBufferingAfterUnpause);\n                }\n\n                // If we're in a paused state, defer the buffering until\n                // after we're unpaused.\n                if (analyticsService.getCurrentLibraryState() === 'paused') {\n                    resumeBufferingAfterUnpause = true;\n                    return;\n                }\n                analyticsService.event('bufferingStart', {});\n            }\n            catch (ex) {\n                $log.error(ex);\n            }\n        }\n\n        function bufferingStopped() {\n            try {\n                if (analyticsService.isDebug()) {\n                    $log.debug('Analytics: bufferingStopped, resumeBufferingAfterUnpause=' +\n                        resumeBufferingAfterUnpause);\n                }\n\n                // Discard bufferingStop event if we're paused.\n                if (resumeBufferingAfterUnpause) {\n                    if (analyticsService.isDebug()) {\n                        $log.debug('Analytics: Discarding bufferingStopped due to ongoing pause');\n                    }\n                    return;\n                }\n                analyticsService.event('bufferingStop', {});\n            }\n            catch (ex) {\n                $log.error(ex);\n            }\n        }\n\n        function scrubJump(e) {\n            if (analyticsService.isDebug()) {\n                $log.debug('Analytics: scrubJump, contentElapsed=' + state.contentElapsedMs, e);\n            }\n            try {\n\n                let startTimestamp = state.contentElapsedMs;\n\n                let startPositionSec = Math.floor(parseInt(startTimestamp) / 1000);\n                let endPositionSec = Math.floor(parseInt(e.PlaybackTimestamp) / 1000);\n\n                if (startPositionSec === endPositionSec) {\n                    if (analyticsService.isDebug()) {\n                        $log.debug('Analytics: Ignoring scrub event to original position,' +\n                            ' after rounding to nearest second');\n                    }\n                    return;\n                }\n\n                let scrubType = null;\n                if (e.sourceElement === 'skipButton') {\n                    scrubType = endPositionSec > startPositionSec ? 'jumpForward' : 'jumpBack';\n                } else {\n                    scrubType = endPositionSec > startPositionSec ? 'fastForward' : 'rewind';\n                }\n\n                if (analyticsService.isDebug()) {\n                    $log.debug('Analytics: scrubJump, from=' + startPositionSec +\n                        ' to=' + endPositionSec + ' type=' + scrubType, e);\n                }\n\n                // If we're buffering right now, we'll have to halt the\n                // buffering during trickplay, and resume right after.\n                let resumeBufferingAfterTrickPlay = false;\n                if ('buffering' === analyticsService.getCurrentLibraryState()) {\n                    bufferingStopped();\n                    resumeBufferingAfterTrickPlay = true;\n                }\n\n                analyticsService.event('playbackTrickPlayStart', {\n                    scrubSpeed: '1',\n                    scrubType: scrubType,\n                    startPositionSec: Math.floor(parseInt(startTimestamp) / 1000)\n                });\n\n                analyticsService.event('playbackTrickPlayStop', {\n                    endPositionSec: Math.floor(parseInt(e.PlaybackTimestamp) / 1000)\n                });\n\n                // If needed, resume the buffering from before the trickplay.\n                if (resumeBufferingAfterTrickPlay) {\n                    bufferingStarted();\n                }\n            }\n            catch (ex) {\n                $log.error(ex);\n            }\n        }\n\n        function bitrateChanged(e) {\n            if (analyticsService.isDebug()) {\n                $log.debug('Analytics: bitrateChanged', e);\n            }\n            let event, bitrate;\n            try {\n                if (!isPlaying() && 'undefined' === typeof deferredPlaybackStartEvent) {\n                    return;\n                }\n\n                if (e.NewBitRate) {\n                    bitrate = e.NewBitRate;\n                } else if (e.event && e.event.profile) {\n                    bitrate = e.event.profile;\n                }\n\n                if (!bitrate || bitrate === state.getBitrate()) {\n                    return;\n                }\n\n                state.setBitrate(bitrate);\n\n                if (state.getBitrate() > state.previousBitrate) {\n                    event = 'playbackBitRateUpshift';\n                } else {\n                    event = 'playbackBitRateDownshift';\n                }\n\n                let data = {\n                    currentBitRateBps: state.getBitrate()\n                };\n                analyticsService.event(event, data);\n            }\n            catch (ex) {\n                $log.error(ex);\n            }\n        }\n\n        function playbackStopped(e = {}) {\n            if (analyticsService.isDebug()) {\n                $log.debug('Analytics: playbackStopped, isPlaying=' + isPlaying() +\n                    ', state=' + analyticsService.getCurrentLibraryState(), e);\n            }\n            try {\n\n                // Send a playbackExitBeforeStart event if we've selected content previously,\n                // but never began playing it. (i.e. no playbackStart event yet)\n                if ('initiating' === analyticsService.getCurrentLibraryState()) {\n                    state.stopPlayback();\n                    state.setLastPlaybackType(null);\n                    state.setLastSelectEvent(null);\n                    state.setLastStreamUriEvent(null);\n                    state.setLastPlaybackStartedEvent(null);\n                    analyticsService.event('playbackExitBeforeStart', {});\n                    return;\n                }\n\n                if (!isPlaying()) {\n                    return;\n                }\n\n                let data = {};\n                if (e.TriggeredBy === 'exitPlayer') {\n                    data.triggeredBy = 'user';\n                } else {\n                    data.triggeredBy = 'application';\n                }\n\n                state.stopPlayback();\n\n                analyticsService.event('playbackStop', data);\n            }\n            catch (ex) {\n                $log.error(ex);\n            }\n        }\n\n        function playbackFailure(e, data = {}) {\n            try {\n                if (analyticsService.isDebug()) {\n                    $log.debug('Analytics: playbackFailure, state=' +\n                        analyticsService.getCurrentLibraryState(), e, data);\n                }\n\n                // Capture client error code string, if one is defined.\n                if (angular.isDefined(data.cause)) {\n                    if ('string' === typeof data.cause) {\n                        data.clientErrorCode = data.cause;\n                    } else if (angular.isDefined(data.cause.errorID)) {\n                        data.clientErrorCode = data.cause.errorID.toString();\n                    } else if (angular.isDefined(data.cause.mediaPlayerErrorCode)) {\n                        data.clientErrorCode = data.cause.mediaPlayerErrorCode.toString();\n                    }\n                }\n\n                // Assumption: data.errorCode is already normalized.\n                data.errorMessage = data.errorMessage;\n                data.errorType = 'playback';\n\n                // Is this for the asset we currently believe to be playing?\n                if (data.asset &&\n                    state.getSelectedContent().tmsProgramId !== analyticsAssetHelper.getTmsProgramId(data.asset)) {\n\n                    // No. programId exists, but is not a match!\n                    $log.warn('Analytics: 1047: Discarding this failure event, since it is for a different asset');\n                    return;\n                }\n                delete data.asset;\n\n                // If we're paused, we need to end the pause in order for the\n                // SDK to transition to the failure state.\n                if ('paused' === analyticsService.getCurrentLibraryState()) {\n                    if (analyticsService.isDebug()) {\n                        $log.debug('Analytics: Unpausing to allow playbackFailure event');\n                    }\n                    pauseToggled(false);\n                }\n\n                state.stopPlayback();\n\n                analyticsService.event('playbackFailure', data);\n            }\n            catch (ex) {\n                $log.error(ex);\n            }\n        }\n\n        function adBreakStarted(adBreak) {\n            try {\n                let data = {\n                    adBreakNumber: adBreak.index\n                };\n\n                if (!isPlaying()) {\n                    state.setDeferredEvent('adBreakStart', data);\n                    return;\n                }\n\n                analyticsService.event('adBreakStart', data);\n            }\n            catch (ex) {\n                $log.error(ex);\n            }\n        }\n\n        function adBreakStopped(adBreak) {\n            try {\n                if (state.adPlaying) {\n                    state.setDeferredEvent('adBreakStop', adBreak);\n                    return;\n                }\n\n                // If we're buffering at the moment, interrupt it to allow this\n                // event to go through.\n                let resumeBufferingAfterEvent = false;\n                if ('buffering' === analyticsService.getCurrentLibraryState()) {\n                    bufferingStopped();\n                    resumeBufferingAfterEvent = true;\n                }\n\n                if (state.previousEventName === 'adBreakStop') {\n                    return;\n                }\n\n                analyticsService.event('adBreakStop', adBreak);\n\n                // Resume buffering after allowing this event to go through.\n                if (resumeBufferingAfterEvent) {\n                    bufferingStarted();\n                }\n            }\n            catch (ex) {\n                $log.error(ex);\n            }\n        }\n\n        function adStarted(ad) {\n            try {\n                let data = {\n                    adId: ad.adId,\n                    adNumber: ad.index,\n                    adTitle: ad.caid,\n                    deviceAdId: state.getDeviceId()\n                };\n\n                state.startAd(ad);\n\n                analyticsService.event('adStart', data);\n            }\n            catch (ex) {\n                $log.error(ex);\n            }\n        }\n\n        function adStopped(ad) {\n            try {\n                let deferred;\n                let data = {\n                    adDurationSec: parseInt(ad.duration / 1000),\n                    adStoppedReason: 'completion'\n                };\n\n                if (state.hasDeferredEvent('adBreakStop')) {\n                    deferred = 'adBreakStop';\n                }\n\n                state.stopAd();\n\n                analyticsService.event('adStop', data, deferred);\n            }\n            catch (ex) {\n                $log.error(ex);\n            }\n        }\n\n        function adTracking(request) {\n            try {\n                if (request.type === 'adStartTracking') {\n                    adStarted(request.adInstance);\n                } else if (request.type === 'adEndTracking') {\n                    adStopped(request.adInstance);\n                }\n            }\n            catch (ex) {\n                $log.error(ex);\n            }\n        }\n\n        /**\n         * Return true if the SDK is in a state consistent with stream playback.\n         *\n         * @return True if the SDK is in a state consistent with stream playback.\n         */\n        function isPlaying() {\n            let currentState = analyticsService.getCurrentLibraryState();\n            return ['playing', 'buffering', 'scrubbing', 'paused'].indexOf(currentState) > -1;\n        }\n\n        function attachEventListeners(player) {\n            player.on('player-position-changed', playerPositionChanged);\n            player.on('channel-changed', channelChanged);\n            player.on('vod-content-selected', vodContentSelected);\n            player.on('cdvr-content-selected', cdvrContentSelected);\n            player.on('buffering-began', bufferingStarted);\n            player.on('stream-uri-obtained', streamUriObtained);\n            player.on('stream-scrubbed', scrubJump);\n            player.on('ad-break-started', adBreakStarted);\n            player.on('ad-break-stopped', adBreakStopped);\n            player.on('buffering-ended', bufferingStopped);\n            player.on('bitrate-changed', bitrateChanged);\n            player.on('playback-started', playbackStarted);\n            player.on('playback-pause-toggled', pauseToggled);\n            player.on('playback-stopped', playbackStopped);\n            player.on('ad-twc-tracking-request', adTracking);\n            player.on('player-end-position-changed', endPositionChanged);\n\n            // On player errors.\n            $rootScope.$on('Analytics:playbackFailure', playbackFailure);\n\n            $rootScope.$on('Analytics:playback-stopped', (e, data) => {\n                playbackStopped(data);\n            });\n        }\n    }\n}());\n"],"sourceRoot":"/source/"}