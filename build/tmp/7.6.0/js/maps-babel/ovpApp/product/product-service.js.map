{"version":3,"sources":["ovpApp/product/product-service.js"],"names":[],"mappings":"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","file":"ovpApp/product/product-service.js","sourcesContent":["(function () {\n    'use strict';\n\n    angular.module('ovpApp.product.service', [\n        'ovpApp.components.alert',\n        'ovpApp.services.entry',\n        'ovpApp.config',\n        'ovpApp.services.profileService',\n        'ovpApp.dataDelegate',\n        'ovpApp.services.dateFormat',\n        'ovpApp.services.locationService',\n        'ovpApp.services.errorCodes',\n        'ovpApp.messages'\n    ])\n    .factory('productService', productService);\n\n    /* @ngInject */\n    function productService($http, $q, entryService, config, $rootScope,\n            delegateFactory, $timeout, profileService, messages, dateFormat,\n            rx, rxhttp, $log, locationService, errorCodesService) {\n\n        let service = {\n            availabilityMessage,\n            getCdvrDateText,\n            withTmsSeriesId,\n            withTmsId,\n            withProviderAssetId,\n            withUri\n        };\n\n        let transformQueue;\n        let hasAccessibility;\n        let ooh;\n        profileService.isAccessibilityEnabled().then((hasCapability) => {\n            hasAccessibility = hasCapability;\n        });\n        locationService.getLocation().then((location) => {\n            ooh = !location.behindOwnModem;\n        });\n        $rootScope.$on('LocationService:locationChanged', (event, location) => {\n            ooh = !location.behindOwnModem;\n        });\n\n        $rootScope.$on('Session:setCapabilities', () => {\n            //Refresh accessibility capability on refresh\n            profileService.isAccessibilityEnabled().then((hasCapability) => {\n                hasAccessibility = hasCapability;\n            });\n        });\n\n        activate();\n\n        return service;\n\n        //////////////////////////\n\n        function activate() {\n            //Catch malformed JSON, for example, a 404 response returns an error string\n            transformQueue = [\n            function (val) {\n                try {\n                    angular.fromJson(val);\n                } catch (e) {\n                    val = '{}';\n                    $log.error('Unable to parse json from server response');\n                }\n                return val;\n            }];\n            transformQueue = transformQueue.concat(rxhttp.defaults.transformResponse);\n        }\n\n\n        function availabilityMessage(asset, cameFromWatchLater = false) {\n\n            if (!asset) {\n                return;\n            }\n            if (asset.isOutOfWindow && cameFromWatchLater) {\n                return errorCodesService.getMessageForCode('WGU-1004');\n            } else if (!asset.isEntitled) {\n                return errorCodesService.getMessageForCode('WEN-1004', {\n                    IVR_NUMBER: config.ivrNumber\n                });\n            } else if (ooh && !asset.availableOutOfHome) {\n                return errorCodesService.getMessageForCode('WLC-1012');\n            } else if (asset.entitledTvodStream) {\n                let endTime = asset.entitledTvodStream.streamProperties\n                    .tvodEntitlement.rentalEndTimeUtcSeconds;\n                let time = dateFormat.relative.expanded.atTime(new Date(endTime * 1000));\n                return `Watch rental until ${time}`;\n            } else if (asset.tvodStream) {\n                if (asset.isComplexOffering) {\n                    let cheapestStream = asset.streamList\n                        .filter(str => str.isTvodStream)\n                        .sort((a, b) => a.streamProperties.price - b.streamProperties.price)\n                        .shift();\n                    return 'Rent from $' + cheapestStream.streamProperties.price +\n                        '. Available for ' + cheapestStream.streamProperties.rentalWindowInHours +\n                        ' hours.';\n                }\n                return 'Rent for $' + asset.price +\n                    '. Available for ' + asset.tvodStream.streamProperties.rentalWindowInHours +\n                    ' hours.';\n            } else if (asset.isBlockedByParentalControls) {\n                return messages.getMessageForCode('MSG-9045');\n            }\n        }\n\n        function getCdvrDateText(asset, action) {\n            if (action.streamIndex >= 0 && asset && asset.streamList) {\n                let dvrStream = asset.streamList[action.streamIndex];\n                var startTimeMsec;\n\n                // Prefer the CDVR time if available as it is more specific to\n                // the actual recording than perhaps the stream's airtime.\n                if (dvrStream.streamProperties.cdvrRecording) {\n                    startTimeMsec = dvrStream.streamProperties.cdvrRecording.startTimeSec * 1000;\n                } else {\n                    startTimeMsec = parseInt(dvrStream.streamProperties.startTime, 10);\n                }\n\n                let dateString = dateFormat.absolute.expanded.atTime(new Date(startTimeMsec));\n\n                return dateString;\n            }\n        }\n\n        function withTmsSeriesId(tmsSeriesId, params) {\n            return buildFetcher('tmsSeriesId', tmsSeriesId, params);\n        }\n\n        function withTmsId(tmsId, params) {\n            return buildFetcher('tmsProviderProgramId', tmsId, params);\n        }\n\n        function withProviderAssetId(id, params) {\n            return buildFetcher('providerAssetId', id, params);\n        }\n\n        function buildFetcher(type, id, params) {\n            let promises = {};\n            return {\n                fetch: (waitForFresh = false) => {\n                    if (!promises[waitForFresh]) {\n                        promises[waitForFresh] = constructPartialUri(type, id, params)\n                            .then(uri => fetch(uri, waitForFresh))\n                            .then(data => {\n                                promises[waitForFresh] = undefined;\n                                return data;\n                            });\n                    }\n                    return promises[waitForFresh];\n                }\n            };\n        }\n\n        function withUri(uri) {\n            return {\n                fetch: (waitForFresh = false) => fetch(uri, waitForFresh)\n            };\n        }\n\n        /**\n         * Constructs a partial uri, similar (or, ideally, identical) to the ones passed into .withUri()\n         *\n         * @param  {string}            type    id type\n         * @param  {number or string}  id      the tmsProviderProgramId or tmsSeriesId\n         * @param  {object}            params  additional parameters\n         * @return {promise}                   promise which resolves to partial uri which can be passed into fetch()\n         */\n        function constructPartialUri(type, id, params) {\n            return entryService.forDefaultProfile()\n                .then(service => {\n                    let contextParams = {};\n\n                    let serviceTypeMap = {\n                        'tmsSeriesId': service.series.tmsSeriesID,\n                        'tmsProviderProgramId': service.event.tmsProviderProgramID,\n                        'providerAssetId': service.event.providerAssetID\n                    };\n\n                    let requestParams = '';\n                    if (!params) {\n                        params = {\n                            app: 'search'\n                        };\n                    }\n\n                    if (params) {\n                        if (params.app) {\n                            contextParams.app = params.app;\n                        }\n                        if (params.airtime) {\n                            contextParams.airtimeUtcSec = params.airtime;\n                        }\n                        if (params.serviceId) {\n                            contextParams.mystroServiceId = params.serviceId;\n                        }\n                        if (params.tmsGuideServiceId) {\n                            contextParams.tmsGuideServiceId = params.tmsGuideServiceId;\n                        }\n\n                        requestParams = Object.keys(contextParams).reduce((prev, current) => {\n                            return prev + `&${current}=${contextParams[current]}`;\n                        }, '');\n                    }\n\n                    if (serviceTypeMap[type]) {\n                        return serviceTypeMap[type](id) + requestParams;\n                    } else {\n                        return `Invalid result type ${type}`;\n                    }\n                });\n        }\n\n        function fetch(partialUri, waitForFresh) {\n            return rxhttp.get(config.piHost + partialUri, {\n                    withCredentials: true,\n                    transformResponse: transformQueue\n                })\n                .retry(3) // retry for normal failures\n                .do(result => {\n                    if (waitForFresh && isStale(result)) {\n                        throw('stale');\n                    }\n                })\n                .retryWhen(retryStaleResults) // retry for stale data only\n                .map(response => delegateFactory.createInstance(response.data))\n                .toPromise($q);\n        }\n\n        function isStale(result) {\n            return result &&\n                result.data &&\n                result.data.details &&\n                result.data.details.staleDvrCache;\n        }\n\n        function retryStaleResults(errors) {\n            let staleErrors = errors\n                .do(error => {\n                    if (error !== 'stale') {\n                        throw error; //re-emit the error.\n                    }\n                });\n            let maxRetries = 10;\n\n            return rx.Observable.range(1, maxRetries)\n                .zip(staleErrors, i => i * i * 100)  //Exponential back off 100ms, 400, 900, 1600, 2500, etc\n                .flatMap(i => rx.Observable.timer(i));\n        }\n    }\n}());\n"],"sourceRoot":"/source/"}