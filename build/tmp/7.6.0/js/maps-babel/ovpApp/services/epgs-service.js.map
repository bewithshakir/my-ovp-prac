{"version":3,"sources":["ovpApp/services/epgs-service.js"],"names":[],"mappings":"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","file":"ovpApp/services/epgs-service.js","sourcesContent":["(function () {\n    'use strict';\n    angular.module('ovpApp.services.epgsService', [\n        'ovpApp.config',\n        'ovpApp.components.error.ServiceError',\n        'ovpApp.services.stbService'\n    ])\n    .factory('epgsService', epgsService)\n    .factory('realEpgsService', realEpgsService);\n\n    /* @ngInject */\n    function epgsService($http, $q, ServiceError, config, stbService, profileService) {\n        let piHost = config.piHost,\n            smartTv = config.smartTvApi,\n            nmdEpgs = config.nmdEpgsApiV1,\n            channelListQam = config.epgs.channelListQam,\n            channelListIp = config.epgs.channelListIp,\n            channelsPromise = null,\n            lookupTable = {};\n\n        let service = {\n            getChannels,\n            getChannelByMystroSvcId,\n            getChannelByNcsSvcId,\n            clearChannels\n        };\n\n        return service;\n\n        //////////////////////\n\n        /**\n         * Make the channels http request. Determines whether this is an IP or QAM channels request and then builds the\n         * correct URL to make the request to.\n         *\n         * @returns {$q.defer} The promise containing the Http get response.\n         */\n        function getChannels() {\n            if (channelsPromise === null) {\n                channelsPromise = $q.all ([profileService.isIpOnlyEnabled(),\n                    stbService.getHeadend()]).then(params => {\n                    let ipOnlyEnabled = params[0];\n                    let headend = params[1];\n                    let queryParams = {};\n                    let requestUrl = piHost + smartTv;\n                    let enrichedChannels = [];\n\n                    // We need to determine if we are IP based or QAM based.\n                    if (!ipOnlyEnabled) {\n                        // QAM based needs to have the headend set, and uses a different channelList request URL\n                        if (headend) {\n                            queryParams.params = {headend: headend.id};\n                        }\n                        requestUrl += nmdEpgs + channelListQam;\n                    } else {\n                        // IP based channel list request doesn't include nmdEpgs in the URL and uses a different\n                        // channelList property.\n                        requestUrl += channelListIp;\n                    }\n\n                    // Set the credentials query param.\n                    queryParams.withCredentials = true;\n\n                    // Make our channels request.\n                    return $http.get(requestUrl, queryParams).then(function (response) {\n                        enrichedChannels = enrichChannels(response.data.channels);\n\n                        if (!ipOnlyEnabled) {\n                            angular.forEach(response.data.channels, function (channel, index) {\n                                // Create a lookup table for QAM based channel list for RDVR\n                                if (channel && channel.mystroServiceId !== undefined &&\n                                    channel.channelNumber !== undefined) {\n                                    // QAM based channel properties\n                                    channel.channelNumber = parseInt(channel.channelNumber);\n                                    lookupTable[[channel.mystroServiceId, channel.channelNumber].join(':')] = index;\n                                }\n                            });\n                        }\n                        return enrichedChannels;\n                    }, function () {\n                        throw new ServiceError('Error Loading Channels');\n                    });\n                }, clearChannels);\n            }\n            return channelsPromise;\n        }\n\n        function getChannelByMystroSvcId(mystroServiceID, channelID) {\n            return getChannels().then(function (channels) {\n                var index = lookupTable[[mystroServiceID, channelID].join(':')];\n                return (angular.isDefined(index) && channels[index]) || null;\n            });\n        }\n\n        /**\n         * Retrieve the channel object by using the ncsServiceId & networkId in the lookupTable\n         * @param ncsServiceId The ncsServiceId, IP based lineup\n         * @param networkId The networkId, IP based lineup\n         * @returns {*|Promise.<T>}\n         */\n        function getChannelByNcsSvcId(ncsServiceId, networkId) {\n            return getChannels().then(function (channels) {\n                var index = lookupTable[[ncsServiceId, networkId].join(':')];\n                return (angular.isDefined(index) && channels[index]) || null;\n            });\n        }\n\n        /**\n         * Enrich the channels data array to make the channel objects consistent despite the data origin\n         * @param channels The channels array to recurse over and enrich\n         *\n         * @returns {Object} The newly enriched channels array\n         */\n        function enrichChannels(channels) {\n            if (!channels) {\n                return [];\n            }\n\n            let duplicates = [];\n\n            channels.forEach(channel => {\n                //If there is a channels array, then we need to extract the channel number from that data node.\n                if (channel.channels && channel.channels.length) {\n\n                    // Create a channel object for each channel number in the array.\n                    channel.channels.forEach((channelNumber, channelIndex) => {\n\n                        // If there is more than one channel in the array then we need to clone the channel object\n                        // for the additional channels.\n                        if (channelIndex > 0) {\n                            duplicates.push(enrichChannelData(angular.extend({}, channel), channelNumber));\n                        } else {\n                            enrichChannelData(channel, channelNumber);\n                        }\n                    });\n                } else {\n                    enrichChannelData(channel, channel.channelNumber);\n                }\n            });\n            channels.push(...duplicates);\n            channels = channels.sort((a, b) => a.channelNumber - b.channelNumber);\n\n            return channels;\n        }\n\n        /**\n         * Enrich the passed in channel to create consistent channel objects\n         * @param channel The channel object to enrich\n         * @param channelNumber The channel number to use for the channel object\n         *\n         * @returns {Object} The newlyEnriched channel object\n         */\n        function enrichChannelData(channel, channelNumber) {\n            return angular.extend(channel, {\n                channelNumber: angular.isDefined(channelNumber) ? parseInt(channelNumber) : undefined,\n                tmsGuideId: channel.tmsGuideId || channel.tmsId,\n                fullLogoUrl: (channel.logoUrl && channel.logoUrl.startsWith('/') ?\n                    config.piHost + channel.logoUrl : channel.logoUrl) + '?width=50&sourceType=colorhybrid'\n            });\n        }\n\n        function clearChannels() {\n            channelsPromise = null;\n        }\n    }\n\n    // This function is here to allow this service to be mocked in test while\n    // allowing the stb-serviceSpec to reference the real thing here.\n    /* @ngInject */\n    function realEpgsService($http, $q, ServiceError, config, stbService, profileService) {\n        return epgsService($http, $q, ServiceError, config, stbService, profileService);\n    }\n\n}());\n"],"sourceRoot":"/source/"}