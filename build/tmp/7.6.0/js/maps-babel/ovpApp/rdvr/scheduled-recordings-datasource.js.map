{"version":3,"sources":["ovpApp/rdvr/scheduled-recordings-datasource.js"],"names":[],"mappings":"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","file":"ovpApp/rdvr/scheduled-recordings-datasource.js","sourcesContent":["(function () {\n    'use strict';\n\n    angular\n        .module('ovpApp.rdvr.datasource')\n        .factory('ScheduledRecordingsDatasource', factory);\n\n    /* @ngInject */\n    function factory(AbstractDatasource, $q, rx, rxhttp, config, recordingViewModelDefinition,\n        rdvrCacheService, recordingsListType) {\n        return class ScheduledRecordingsDatasource extends AbstractDatasource {\n            constructor(stb) {\n                super(stb, recordingsListType.SCHEDULED, {\n                    data: []\n                });\n\n                if (this.stb && this.stb.dvr) {\n                    this.locallyScheduled = new rx.BehaviorSubject([]);\n                    this.locallyCancelled = new rx.BehaviorSubject([]);\n\n                    this.source = this.reset.map(() => true)\n                        .startWith(false)\n                        .flatMapLatest(force => {\n                            return this.fetchAndCombineWithLocalChanges(force)\n                                .startWith(this.initialValue)\n                                .takeUntil(this.reset);\n                        })\n                        .shareReplay(1);\n                } else {\n                    this.source = rx.Observable.never();\n                }\n            }\n\n            fetchAndCombineWithLocalChanges(force) {\n                this.locallyScheduled.onNext([]);\n                this.locallyCancelled.onNext([]);\n\n                return rx.Observable.combineLatest(\n                    this.fetch(force), this.locallyScheduled, this.locallyCancelled,\n                    (fromStb, locallyScheduled, locallyCancelled) => {\n                        let recordings = fromStb.data.concat(locallyScheduled);\n                        if (locallyScheduled.length > 0) {\n                            recordings.sort((a, b) => a.startTime - b.startTime);\n                        }\n\n                        locallyCancelled.forEach(cancelled => {\n                            const found = recordings.find(r => this.recordingsEqual(r, cancelled));\n                            if (found) {\n                                const index = recordings.indexOf(found);\n                                if (index > -1) {\n                                    recordings.splice(index, 1);\n                                }\n                            }\n                        });\n\n                        if (locallyScheduled.length === 0 && locallyCancelled.length === 0) {\n                            rdvrCacheService.createNewCache(recordingsListType.SCHEDULED, this.stb, {\n                                data: recordings,\n                                nextParams: fromStb.nextParams\n                            });\n                        } else {\n                            rdvrCacheService.updateCache(recordingsListType.SCHEDULED, this.stb, {\n                                data: recordings,\n                                nextParams: fromStb.nextParams\n                            });\n                        }\n\n                        return {\n                            data: recordings.map(r => this.wrapRecording(r)),\n                            isComplete: !fromStb.nextParams,\n                            error: fromStb.error,\n                            lastUpdated: fromStb.lastUpdated,\n                            busyUntil: fromStb.busyUntil\n                        };\n                    });\n            }\n\n            fetch(force) {\n                if (force) {\n                    this.clearCache();\n                }\n\n                return this.batchGetWithCache({\n                        getter: this.getOneScheduledRecordingBatch.bind(this),\n                        initialParams: {startTime: 0, includeCurrent: true}\n                    })\n                    .catch(error => rx.Observable.just({data: [], error}))\n                    .scan(this.mergeBatchesWithDuplicates.bind(this));\n            }\n\n            scheduleRecording(scheduledItem) {\n                if (!this.stb || !this.stb.dvr) {\n                    return $q.resolve();\n                }\n\n                const baseUrl = config.piHost + config.nrsApi + this.getDvrBase();\n                const fullUrl = baseUrl + this.stb.macAddressNormalized +\n                    config.services.dvrSchedule + '/' +\n                    scheduledItem.mystroServiceId + '/' +\n                    scheduledItem.tmsProgramId + '/' +\n                    scheduledItem.startTime + '/' +\n                    (scheduledItem.recordSeries ? 'series' : 'single');\n\n                let source = rxhttp.put(fullUrl, {settings: scheduledItem.settings}, {withCredentials: true});\n\n                // The server may return a 500 error due to a timeout, followed by a 439 indicating it's already\n                // scheduled. We want to treat this as a success.\n                source = this.expectErrors(source, [500, 439])\n                    .do(() => {\n                        let currentValue = this.locallyScheduled.getValue();\n                        // unwraping the data delegate, so it can be saved to the cache correctly\n                        currentValue.push(scheduledItem._context.data);\n                        this.locallyScheduled.onNext(currentValue);\n                    });\n\n                return source.toPromise($q);\n\n\n                // epgsService.getChannels().then(function (channels) {\n                //     var channel = getChannelInfoFromMystroServiceId(channels, scheduledItem.mystroServiceId);\n                //     var tmsGuideId = channel.streamTmsGuideId || null;\n                //     var airingTime = scheduledItem.startTime * 1000;\n                //     var channelNumber = channel.channelNumber;\n                //     var eventData = {\n                //         operation: scheduledItem.isNew ? 'new' : 'edit',\n                //         isSeries:  scheduledItem.recordSeries\n                //     };\n\n                //     if (tmsGuideId && tmsGuideId !== '') {\n                //         eventData.assetMetadata = {\n                //             tmsGuideId:    tmsGuideId.toString(),\n                //             airingTime:    airingTime.toString(),\n                //             channelNumber: channelNumber.toString()\n                //         };\n\n                //         $rootScope.$emit('EG:scheduleNewDvrRecording', eventData);\n                //     }\n                // });\n\n            }\n\n            /**\n             * Adds retry and catch logic so that a predicted sequence of errors can be treated as not an error\n             *\n             * @param  {observable} source     The source observable\n             * @param  {array} expectedErrors  an array of http status codes. If errors occur in the specified order,\n             *                                    then we will keep retrying until either an unexpected error occurs,\n             *                                    or the array is completed. If all the expected errors happen, then\n             *                                    a success is emitted rather than an error.\n             * @param  {Number} retryDelay     amount of time to wait before retrying. Defaults to 500\n             * @param  {object} scheduler      used for unit testing. Leave undefined for normal operation\n             * @return {observable}            The modified version of the source observable\n             */\n            expectErrors(source, expectedErrors, retryDelay = 500, scheduler = undefined) {\n                return source.retryWhen(errors => {\n                    return errors\n                        .take(expectedErrors.length)\n                        .scan((memo, error) => {\n                            memo.push(error);\n                            return memo;\n                        }, [])\n                        .flatMap(accumulatedErrors => {\n                            let okSoFar = accumulatedErrors.every((e, i) => expectedErrors[i] === e.status);\n                            if (okSoFar) {\n                                if (accumulatedErrors.length === expectedErrors.length) {\n                                    // All done. We got the predicted sequence of errors, so treat as success\n                                    let error = accumulatedErrors[accumulatedErrors.length - 1];\n                                    error._treatAsNotAnError = true;\n                                    return rx.Observable.throw(error);\n                                } else {\n                                    // The pattern matches so far, but we need to retry and see if it continues\n                                    return rx.Observable.timer(retryDelay, scheduler);\n                                }\n                            } else {\n                                // Pattern does not match. Throw the error.\n                                return rx.Observable.throw(accumulatedErrors[accumulatedErrors.length - 1]);\n                            }\n                        });\n                })\n                .catch(error => {\n                    if (error.status === expectedErrors[expectedErrors.length - 1] && error._treatAsNotAnError) {\n                        delete error._treatAsNotAnError;\n                        return rx.Observable.just(error);\n                    } else {\n                        return rx.Observable.throw(error);\n                    }\n                });\n            }\n\n            cancelScheduled(scheduledItem, cancelSingle) {\n                if (!this.stb || !this.stb.dvr) {\n                    return rx.Observable.empty();\n                }\n\n                const baseUrl = config.piHost + config.nrsApi + this.getDvrBase();\n                let singleOrSeries = scheduledItem.recordSeries ? 'series' : 'single';\n\n                if (cancelSingle === true) {\n                    singleOrSeries = 'single';\n                }\n\n                const fullUrl = baseUrl + this.stb.macAddressNormalized +\n                        config.services.dvrScheduled + '/' +\n                        scheduledItem.mystroServiceId + '/' +\n                        scheduledItem.tmsProgramId + '/' +\n                        scheduledItem.startTime + '/' +\n                        singleOrSeries;\n\n                let source = rxhttp.delete(fullUrl, {withCredentials: true});\n\n                // The server may return a 500 error due to a timeout, followed by a 404 indicating it's already\n                // deleted. We want to treat this as a success.\n                source = this.expectErrors(source, [500, 404])\n                    .do(() => {\n                        let currentValue = this.locallyCancelled.getValue();\n                        // unwraping the data delegate, so it can be saved to the cache correctly\n                        currentValue.push(scheduledItem._context.data);\n                        this.locallyCancelled.onNext(currentValue);\n                    });\n\n                return source.toPromise($q);\n\n                // .do(() => publishUnscheduledEvent({\n                //     item: scheduledItem,\n                //     isSeries: singleOrSeries === 'single' ? false : true\n                // }))\n            }\n\n            /**\n             * Gets a batch of scheduled recordings\n             */\n            getOneScheduledRecordingBatch({startTime, includeCurrent}) {\n                let params = {};\n                params.startUnixTimestampSeconds = startTime;\n                if (params.includeCurrent === true) {\n                    params.includeCurrent = includeCurrent;\n                }\n\n                const url = config.piHost + config.nrsApi + this.getDvrBase() + this.stb.macAddressNormalized +\n                        config.services.dvrScheduled;\n\n                return rxhttp.get(url, {params, withCredentials: true})\n                    .retry(2)\n                    .map(result => {\n                        // Flatten current and future recordings into a single array\n                        let recordings;\n                        if (result.data.current) {\n                            recordings = result.data.current.concat(result.data.recordings);\n                        } else {\n                            recordings = result.data.recordings;\n                        }\n\n                        // Determine whether another batch is necessary\n                        if (result.status === 206 && recordings.length > 0) {\n                            result.nextParams = {\n                                startTime: result.data.lastStartTime,\n                                includeCurrent: false\n                            };\n                        }\n\n                        // If data is missing, fill it up.\n                        result.data = recordings.map(r => {\n                            if (!r.programMetadata) {\n                                this.createEmptyProgramMetadata(r);\n                            }\n\n                            return r;\n                        });\n\n                        return result;\n                    });\n            }\n        };\n    }\n})();\n"],"sourceRoot":"/source/"}