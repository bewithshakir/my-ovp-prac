{"version":3,"sources":["ovpApp/services/bookmark-service.js"],"names":[],"mappings":"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","file":"ovpApp/services/bookmark-service.js","sourcesContent":["(function () {\n    'use strict';\n\n    /**\n     * RecentlyWatched service\n     * Fetch recently watched assets from the bookmark service and then pull in the\n     * reset of the required data to display the assets.\n     */\n    angular.module('ovpApp.services.bookmark', [\n        'ovpApp.config',\n        'ovpApp.services.nns',\n        'ovpApp.services.parentalControlsService',\n        'ovpApp.services.rxUtils',\n        'ovpApp.services.splunk'\n    ])\n    .factory('BookmarkService', BookmarkService);\n\n    /* @ngInject */\n    function BookmarkService(config, $http, $q, $log, NNSService, parentalControlsService,\n        $rootScope, $timeout, rx, SplunkService) {\n        let bookmarks = [],\n            watches = [],\n            globalBookmarksUrl = config.piHost + config.smartTvApi + config.vod.globalBookmarks,\n            watchlistUrl = config.piHost + config.smartTvApi + config.watchlist,\n            hasBookmarkToSet = false, // flag to indicate whether there is a pending bookmark to be send to server\n            bookMark = null, // actual bookmark to be set\n            bookmarkAssetId = null,\n            postBookmarkUrlBase = globalBookmarksUrl + '/',\n            postCdvrBookmarkUrlBase = config.piHost + config.smartTvApi + config.smartTv.cdvrBookmark + '/',\n            postBookmarkUrl, // initialized with proper AssetID in init\n            postBookmarkInterval = 60000, // TODO hardcoded to 1 min, will be configurable from Activity.Config\n            postImmediateBookmarkInterval = 5000,\n            invalidAsset = false,\n            postBookmark$ = new rx.Subject();\n\n        let service = {\n            activate,\n            getBookmarks,\n            updateBookmark,\n            deleteFromInProgressList,\n            clearInProgressList,\n            getBookmarkByTmsProgramId,\n            getBookmarkByTmsSeriesId,\n            getBookmarkByProviderAssetId,\n\n            getWatchLaters,\n            addToWatchLater,\n            deleteFromWatchLater,\n            clearWatchLater,\n            getWatchLaterByTmsProgramIds,\n            getWatchLaterByTmsSeriesId,\n\n            setAssetToBookmark,\n            setCdvrToBookmark,\n            setBookmark,\n            getBookmark,\n\n            _private: {\n                // exposed for unit testing\n                throttlePostingBookmarks\n            }\n        };\n\n        return service;\n\n        ///////////////////////\n\n        function activate() {\n            getBookmarks();\n            getWatchLaters();\n\n            const streams = throttlePostingBookmarks({\n                stream: postBookmark$,\n                shortThrottle: postImmediateBookmarkInterval,\n                longThrottle: postBookmarkInterval,\n                excessiveThreshold: 5\n            });\n\n            streams.postBookmark$.subscribe(postBookmark);\n            streams.excessive$.subscribe(onExcessiveBookmarks);\n        }\n\n        /**\n         * Applies two levels of throttling to a stream. Truthy emissions are throttled\n         * with the shortThrottle value, falsy emissions are throttled with the long.\n         * @param {Object} options\n         * @param {Observable} options.stream source stream\n         * @param {Number} options.shortThrottle throttle duration to apply to truthy values\n         * @param {Number} options.longThrottle throttle duration to apply to falsy values\n         * @param {Number} options.excessiveThreshold number of throttled immediate events to\n         *    treat as \"excessive\"\n         * @param {*} options.scheduler Allows unit tests to define a scheduler. for normal use,\n         *    this should be undefined.\n         */\n        function throttlePostingBookmarks({stream, shortThrottle, longThrottle, excessiveThreshold, scheduler}) {\n            // Most bookmarks updates can be sent at a leisurly pace\n            const throttled$ = stream.filter(immediate => !immediate).throttle(longThrottle, scheduler);\n            // Some come from important events, such as stopping or jumping and should be sent\n            // more or less immediately. We still have a short throttle to prevent the possibility\n            // of spamming the server if immediate bookmarks are invoked in rapid succession\n            const immediate$ = stream.filter(immediate => !!immediate).share();\n            const throttledImmediate$ = immediate$.throttle(shortThrottle, scheduler).share();\n\n            return {\n                postBookmark$: rx.Observable.merge(throttled$, throttledImmediate$),\n                excessive$: throttledImmediate$\n                    .flatMap(() =>\n                        immediate$\n                            .timestamp(scheduler)\n                            .takeUntil(throttledImmediate$)\n                            .toArray()\n                    )\n                    .filter(throttled => throttled.length >= excessiveThreshold)\n            };\n        }\n\n        function getBookmarkByTmsProgramId(tmsProgramId) {\n            return bookmarks.find(b => b.tmsProgramId == tmsProgramId);\n        }\n\n        function getBookmarkByTmsSeriesId(tmsSeriesId) {\n            return bookmarks.find(b => b.tmsSeriesId == tmsSeriesId);\n        }\n\n        function getBookmarkByProviderAssetId(providerAssetId) {\n            return bookmarks.find(b => b.providerAssetId == providerAssetId);\n        }\n\n        function getWatchLaterByTmsProgramIds(tmsProgramIds) {\n            return watches.find(a => tmsProgramIds.find(b => b == a.tmsProgramId));\n        }\n\n        function getWatchLaterByTmsSeriesId(tmsSeriesId) {\n            return watches.find(b => b.tmsSeriesId == tmsSeriesId);\n        }\n\n        function replaceArrayContents(arrayRef, newContents) {\n            arrayRef.splice(0, arrayRef.length, ...newContents);\n        }\n\n        function getBookmarks() {\n            //TODO: cache the result\n            return get(globalBookmarksUrl)\n                .then(b => {\n                    replaceArrayContents(bookmarks, b);\n                    return bookmarks;\n                });\n        }\n\n        function getWatchLaters() {\n            //TODO: cache the result\n            return get(watchlistUrl, config.watchListParameters)\n                .then(w => {\n                    replaceArrayContents(watches, w);\n                    return watches;\n                });\n        }\n\n        function get(url, params) {\n            return $http.get(url, {\n                withCredentials: true,\n                params: params\n            }).then(response => {\n                return (response && response.data && response.data.result) || [];\n            });\n        }\n\n        /**\n         * Take an asset object and append it to the currect watch list\n         * @param  {asset} a series datadelegate or a movie datadelegate\n         * @return {promise}      promise\n         */\n        function addToWatchLater(asset) {\n            var appendUrl;\n            if (!asset) {\n                throw 'Error appending asset to watchlist, missing data';\n            }\n\n            appendUrl = (asset.tmsSeriesId) ? '/series/' + asset.tmsSeriesId :\n                '/assets/' + asset.watchListProviderAssetId;\n\n            $rootScope.$emit('watchlater:add', asset);\n\n            return $http({\n                url:                watchlistUrl + appendUrl,\n                method:             'POST',\n                withCredentials:    true,\n                data:               {}\n            }).then(function () {\n                $timeout(function () {\n                    getWatchLaters();\n                });\n            });\n        }\n\n        /**\n         * Delete a specific item from the watchlist, this should automatically\n         * determine the correct url, and\n         * @param  {object} asset asset with assetId or tmsSeriesId set\n         * @return {promise}       A promise to resolve when the call is finished\n         */\n        function deleteFromWatchLater(asset) {\n            if (!asset) {\n                return;\n            }\n            let watch, deleteUrl, index = -1;\n\n            if (asset.tmsSeriesId) {\n                watch = getWatchLaterByTmsSeriesId(asset.tmsSeriesId);\n            } else if (asset.tmsProgramIds) {\n                watch = getWatchLaterByTmsProgramIds(asset.tmsProgramIds);\n            }\n\n            $rootScope.$emit('watchlater:delete', asset);\n\n\n            if (watch) {\n                deleteUrl = (watch.tmsSeriesId) ? '/series/' + watch.tmsSeriesId :\n                    '/assets/' + watch.providerAssetId;\n\n                index = watches.indexOf(watch);\n                watches.splice(index, 1);\n\n                return $http({\n                    url:                watchlistUrl + deleteUrl,\n                    method:             'DELETE',\n                    withCredentials:    true,\n                    data:               {}\n                }).catch(function (error) {\n                    $log.warn('Unable to remove from the watchlist ' + error);\n                    watches.splice(index, 0, watch);\n                });\n            }\n        }\n\n        /**\n         * Clear everything in the watchlist\n         * @return {promise} A promise that resolves when the request is complete\n         */\n        function clearWatchLater() {\n            replaceArrayContents(watches, []);\n            $rootScope.$emit('watchlater:clear');\n\n            return $http({\n                url:                watchlistUrl,\n                method:             'DELETE',\n                withCredentials:    true,\n                data:               {}\n            });\n        }\n\n        /**\n         * \"Deletes\" an asset from the In Progress list, this actually just\n         * sets the show to hidden.\n         * @param  {object} asset\n         * @return {promise}\n         */\n        function deleteFromInProgressList(asset) {\n            if (!asset) {\n                return;\n            }\n\n            let bm = [], providerAssetIds = [];\n            let programIds = asset.tmsProgramIds ||\n                (asset.tmsProgramId ? [asset.tmsProgramId] : undefined);\n\n            //If the delegate has an bookmark set use that to make sure we are getting the correct\n            //tmsProgramId (since we might have multiple)\n            if (asset.bookmark) {\n                programIds = [asset.bookmark.tmsProgramId];\n            }\n\n            if (asset.tmsSeriesId) {\n                bm = bookmarks.filter(b => b.tmsSeriesId == asset.tmsSeriesId);\n            } else if (programIds) {\n                bm = bookmarks.filter(b => programIds.includes(b.tmsProgramId));\n            }\n\n            $rootScope.$emit('inprogress:delete', asset);\n            if (bm.length > 0) {\n                bm.forEach(function (b) {\n                    b.hidden = true;\n                    providerAssetIds.push(b.providerAssetId);\n                });\n                return sendHideBookmarksMessage(providerAssetIds);\n            } else {\n                return $q.resolve();\n            }\n        }\n\n        function sendHideBookmarksMessage(providerAssetIds) {\n            return $http({\n                url:                `${globalBookmarksUrl}/hidden`,\n                method:             'POST',\n                withCredentials:    true,\n                data:               { providerAssetIds }\n            }).then(function (results) {\n                if (results.failedAssetIds && results.failedAssetIds.length > 0) {\n                    throw 'Unable to remove some items from the Recently Watched List';\n                }\n                return results;\n            });\n        }\n\n        /**\n         * \"Clears\" everything in the inprogress list. They are actually just\n         * set to be hidden.\n         * @return {promise} A promise that resolves when the request is complete\n         */\n        function clearInProgressList() {\n            let providerAssetIds = [];\n            bookmarks.forEach(function (b) {\n                b.hidden = true;\n                providerAssetIds.push(b.providerAssetId);\n            });\n            $rootScope.$emit('inprogress:clear');\n\n            return sendHideBookmarksMessage(providerAssetIds);\n        }\n\n        /**\n         * Use this when the bookmark has been saved elsewhere, i.e. recentlyPlayedCollection\n         * and must be kept in sync\n         * @param  {object} bookmarkResult  an object from the bookmark service\n         * @return {boolean}                bookmark was updated\n         */\n        function updateBookmark(bookmarkResult) {\n            if (bookmarkResult && bookmarkResult.tmsProgramId) {\n                let currentBookmark = getBookmarkByTmsProgramId(bookmarkResult.tmsProgramId);\n                if (currentBookmark) {\n                    //Overwrite the bookmark with updated data\n                    for (let key in currentBookmark) {\n                        if (currentBookmark.hasOwnProperty(key) &&\n                            bookmarkResult.hasOwnProperty(key)) {\n                            currentBookmark[key] = bookmarkResult[key];\n                        }\n                    }\n                    return true;\n                } else {\n                    bookmarks.unshift(bookmarkResult);\n                    $rootScope.$emit('inprogress:add', bookmarkResult);\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        function setAssetToBookmark(assetId) {\n            hasBookmarkToSet = false;\n            invalidAsset = false;\n            bookMark = null;\n            bookmarkAssetId = assetId;\n            postBookmarkUrl = postBookmarkUrlBase + bookmarkAssetId;\n        }\n\n        function setCdvrToBookmark(assetId) {\n            hasBookmarkToSet = false;\n            invalidAsset = false;\n            bookMark = null;\n            bookmarkAssetId = assetId;\n            postBookmarkUrl = postCdvrBookmarkUrlBase + bookmarkAssetId;\n        }\n\n        /*\n         * Posting a bookmark right away or starting a timer for the same\n         *\n         * @param {string} reason for posting right away. If truthy, it will be posted immediately-ish.\n         *    If falsy, it will be enqueued for eventual posting.\n         * @param {number} playerMarker current playing position of the asset in seconds\n         * @param {number} total playable duration of the asset in seconds\n         */\n        function setBookmark(postRightAway, playerMarker, entertainmentMarker, runTime) {\n            if (!invalidAsset) {\n                //bookmark values to be set, if they are defined.\n                if (typeof playerMarker !== 'undefined' && typeof entertainmentMarker != 'undefined') {\n                    if (typeof runTime === 'undefined' && bookMark) {\n                        runTime = bookMark.runtime;\n                    }\n                    hasBookmarkToSet = true;\n                    bookMark = {\n                        playMarker: playerMarker,\n                        entertainmentPlayMarker: entertainmentMarker,\n                        runtime: runTime\n                    };\n                }\n\n                postBookmark$.onNext(hasBookmarkToSet && postRightAway);\n            }\n        }\n\n        /**\n         * Get the most recent bookmark\n         * @return {object} bookmark object\n         */\n        function getBookmark() {\n            return bookMark;\n        }\n\n        /*\n         * This function will post bookmark data.\n         */\n        function postBookmark() {\n            if (hasBookmarkToSet) {\n                hasBookmarkToSet = false;\n\n                return $http({\n                    method: 'POST',\n                    url: postBookmarkUrl,\n                    data: JSON.stringify(bookMark),\n                    headers: {\n                        'Content-Type': 'application/json; charset=utf-8'\n                    },\n                    dataType: 'json'\n                })\n                .then(function (bookmarkResult) {\n                    var result = {};\n                    if (bookmarkResult && bookmarkResult.data.result && bookmarkResult.data.result.length > 0) {\n                        result = bookmarkResult.data.result[0];\n                        onBookmarkUpdated(bookmarkAssetId, bookMark, result);\n                    }\n                }, function (obj) {\n                    if (obj.status && obj.status == 404) {\n\n                        //asset expired on catalog.\n                        invalidAsset = true;\n                    }\n                });\n            }\n        }\n\n        // To try to find the root cause of STVWEB-553, we are logging to splunk when we encounter\n        //   an excessive number of attempts to post the bookmark immediately.\n        function onExcessiveBookmarks(events) {\n            SplunkService.sendCustomMessage({\n                type: 'excessiveBookmarks',\n                data: events\n            }, 'ERROR');\n        }\n\n        function onBookmarkUpdated(assetId, bookmark, bookmarkResult) {\n            if (bookmarkResult) {\n                if (bookmarkResult.complete) {\n                    updateBookmark(bookmarkResult);\n                    deleteFromInProgressList(bookmarkResult);\n                } else {\n                    updateBookmark(bookmarkResult);\n                }\n            }\n        }\n    } // end watchlist service funciton\n}()); // end iife\n"],"sourceRoot":"/source/"}