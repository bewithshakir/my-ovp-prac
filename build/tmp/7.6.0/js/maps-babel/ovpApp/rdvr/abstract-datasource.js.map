{"version":3,"sources":["ovpApp/rdvr/abstract-datasource.js"],"names":[],"mappings":"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","file":"ovpApp/rdvr/abstract-datasource.js","sourcesContent":["(function () {\n    'use strict';\n\n    /**\n     * Base class for RDVR datasources. Each datasource is responsible for fetching, storing,\n     * and making available a set of data. For example: scheduled recordings, or disk usage.\n     *\n     * The primary means of interacting with the data source is by calling its .fetch() method.\n     * Fetch() returns an observable sequence, which will emit the associated value over time.\n     * The observable will never complete, but instead will continue to emit new data as it is\n     * received. The data takes the form of:\n     *\n     *   {\n     *      data: someBlobOfDataDependingOnWhichDataSourceThisIs\n     *      isComplete: boolean,\n     *      error: object,\n     *      lastUpdated: number,\n     *      busyUntil: number\n     *   }\n     *\n     * If isComplete = false, then the data is only a partial dataset and more data is actively\n     * being downloaded. If isComplete = true, then the data is not expected to change in the\n     * near future. However, new data may still be emitted if circumstances change, (eg, if a\n     * recording is deleted)\n     *\n     * If an error occurs, the error value will be filled out with the error response. This will\n     * still be emitted as an onNext, not an onError, so the subscription will stay active and\n     * will resume emitting data if for some reason we retry. If partial data was received prior\n     * to the error then the data field will continue to be populated with it.\n     *\n     * If data was loaded from the cache, lastUpdated and busyUntil may be filled out. If\n     * busyUntil is filled out, it indicates that the data is dirty, but is not allowed to\n     * update until the specified time. If lastUpdated is filled out, it indicates that the\n     * data was last updated at the specified time.\n     *\n     * You can safely call fetch as many times as you like, without risking sending additional\n     * http requests; the datasource will cache and reuse values automatically. To invalidate\n     * the cache, call .reset()\n     *\n     */\n\n    angular\n        .module('ovpApp.rdvr.datasource', [\n            'rx',\n            'ovpApp.services.rxUtils',\n            'ovpApp.config',\n            'ovpApp.dataDelegate',\n            'ovpApp.rdvr.recordingsCache',\n            'ovpApp.rdvr.cacheService'])\n        .factory('AbstractDatasource', factory);\n\n    /* @ngInject */\n    function factory(rx, config, rdvrCacheService, createObservableFunction, recordingViewModelDefinition) {\n        return class AbstractDatasource {\n            constructor(stb, cacheKey, initialValue) {\n                this.stb = stb;\n                this.cacheKey = cacheKey;\n                this.initialValue = initialValue;\n                this.reset = createObservableFunction();\n\n                // wrap a recording in a datadelegate, and memoize the result so we only do it once per recording\n                this.wrapRecording = (function () {\n                    const memo = {};\n                    function makeKey(r) {\n                        return '' + r.tmsProgramId + r.mystroServiceId + r.startUnixTimestampSeconds + r.recordSeries;\n                    }\n\n                    return function wrapRecording(recording) {\n                        const key = makeKey(recording);\n                        if (!memo[key]) {\n                            memo[key] = recordingViewModelDefinition.createInstance(recording);\n                        }\n                        return memo[key];\n                    };\n                })();\n            }\n\n            //////////////\n\n            clearCache() {\n                rdvrCacheService.clearCache(this.cacheKey, this.stb);\n            }\n\n            saveToCache(result) {\n                if (result === this.initialValue) {\n                    return;\n                }\n\n                rdvrCacheService.createNewCache(this.cacheKey, this.stb, {\n                    data: result.data,\n                    nextParams: result.nextParams\n                });\n            }\n\n            /**\n             * removes extraneous data which is only needed internally\n             * @param  {object} result result object which may have extra data, such as http status codes\n             *                           or parameters for subsequent http requests\n             * @return {object}        limited version of the result object which only has data that the\n             *                           outside world needs to know\n             */\n            convertResultBeforeEmitting(result) {\n                return {\n                    data: result.data,\n                    isComplete: result === this.initialValue ? false : !result.nextParams,\n                    error: result.error,\n                    lastUpdated: result.lastUpdated,\n                    busyUntil: result.busyUntil\n                };\n            }\n\n            /**\n             * Generalized method for sending a sequence of requests until all data is downloaded.\n             *\n             * @param  {function} getter   function which fetches data. The function must accept one argument,\n             *                                 containing the parameters for fetching the data, and must return\n             *                                 an observable which emits the result. If more data needs to be\n             *                                 fetched, the result should include a nextParams field, containing\n             *                                 the parameters to use on the next iteration.\n             * @param  {object} params     initial parameters to pass to the getter\n             * @return {observable}        an observable which emits each batch of results as they arrive\n             */\n            batchGet(getter, params) {\n                return getter(params)\n                    .concatMap(result => {\n                        if (!result.nextParams) {\n                            return rx.Observable.just(result);\n                        } else {\n                            return this.batchGet(getter, result.nextParams)\n                                .startWith(result);\n                        }\n                    });\n            }\n\n            /**\n             * Generalized method for partially or fully restoring from a cache, and then using batchGet\n             * for any data that's still needed.\n             * @param  {[type]} options.getter                 [description]\n             * @param  {[type]} options.initialParams          [description]\n             * @return {[type]}                                [description]\n             */\n            batchGetWithCache({getter, initialParams}) {\n                let cache = rdvrCacheService.getCache(this.cacheKey, this.stb);\n                let cachedResult, source;\n                if (cache) {\n                    cachedResult = cache.getJson();\n                }\n\n                if (cache && !cachedResult.nextParams) {\n                    cachedResult.lastUpdated = cache.getLastRefreshTimeUtcMsec();\n                    if (cache.isDirty()) {\n                        cachedResult.busyUntil = cache.lastDirtiedTimeUtcMsec + cache.getDirtyIntervalMsec();\n                    }\n\n                    source = rx.Observable.just(cachedResult);\n                } else {\n                    const params = (cachedResult && cachedResult.nextParams) || initialParams;\n                    source = this.batchGet(getter, params);\n                    if (cachedResult) {\n                        source = source.startWith(cachedResult);\n                    }\n                }\n\n                return source;\n            }\n\n            mergeBatches(accumulated, newBatch) {\n                if (accumulated) {\n                    newBatch.data = accumulated.data.concat(newBatch.data);\n                }\n                return newBatch;\n            }\n\n            mergeBatchesWithDuplicates(accumulated, newBatch) {\n                if (accumulated) {\n                    const data = accumulated.data;\n                    newBatch.data.forEach(rec => {\n                        if (!data.find(oldRec => this.recordingsEqual(oldRec, rec))) {\n                            data[data.length] = rec;\n                        }\n                    });\n                    newBatch.data = data;\n                }\n                return newBatch;\n            }\n\n            getDvrBase() {\n                return config.services.dvrBase.replace('*', this.stb.rdvrVersion);\n            }\n\n            createEmptyProgramMetadata(recording) {\n                recording.programMetadata = {\n                    imageUrl: '/imageserver/program/' + recording.tmsProgramId,\n                    mystroServiceId: recording.mystroServiceId,\n                    rating: '',\n                    title: '',\n                    episodeTitle: '',\n                    seasonNumber: '',\n                    episodeNumber: '',\n                    genres: []\n                };\n            }\n\n            recordingsEqual(recordingA, recordingB) {\n                return recordingA.tmsProgramId === recordingB.tmsProgramId &&\n                    recordingA.mystroServiceId === recordingB.mystroServiceId &&\n                    recordingA.startUnixTimestampSeconds === recordingB.startUnixTimestampSeconds &&\n                    recordingA.recordSeries === recordingB.recordSeries;\n            }\n        };\n    }\n})();\n"],"sourceRoot":"/source/"}