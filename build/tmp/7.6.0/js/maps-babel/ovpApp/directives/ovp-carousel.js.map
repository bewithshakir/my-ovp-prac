{"version":3,"sources":["ovpApp/directives/ovp-carousel.js"],"names":[],"mappings":"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","file":"ovpApp/directives/ovp-carousel.js","sourcesContent":["/**\n * ovpCarousel\n *\n * Surrounds a group of elements with a container which lays them out horizontally\n * and provides buttons for navigating.\n *\n * example usage:\n *\n * <ovp-carousel items=\"vm.someArray\">\n *   <div ng-repeat=\"thingie in vm.someArray\">{{thingie.name}}</div>\n * </ovp\n *\n * OR, with options, a nested component, and lazy loading:\n *\n * <ovp-carousel items=\"vm.someArray\"\n *    options=\"vm.configObj\"\n *    on-limit-changed=\"vm.onLimitChanged(limit)\">\n *\n *    <ovp-product ng-repeat=\"asset in vm.someArray | limitTo: vm.limit\"\n *       asset=\"asset\"\n *       options=\"vm.optionsForOvpProduct\">\n *    </ovp-product>\n *\n * </ovp-carousel>\n *\n * Bindings:\n *    items: (array) the array of objects being rendered. Note that the same array\n *       must also be passed into the ng-repeat (or similar directive like\n *       dir-paginate).\n *    options: (object) options to modify the carousel behavior (see below)\n *    onLimitChanged: (function) Notifies that the number of items that need to be\n *       on the dom has changed. This is optionally used to improve performance by\n *       limiting the carousel to only the minimum number of items needed. The\n *       component which is using ovp-carousel is responsible for setting the limitTo\n *       parameter on the ng-repeat. The limitTo must start with a nonzero value or\n *       the carousel will be unable to determine element widths.\n *\n * Options:\n *\n *    showReturnArrow: (bool) if true, the right arrow will turn into a return arrow\n *       when reaching the end. If false, the arrow will disappear. Defaults to true\n *    title: (string) a title for the carousel\n *    showTitle: (bool) if true and a title is provided, the carousel will display the\n *       title above the carousel. If false, title will not be displayed, though it\n *       will still be used for aria information. Defaults to true\n *    arrowIconClass: (string) use to overwrite the css class on the arrow icons\n *    useArrows: (bool) if true, arrows are used to navigate between items. Defaults to true\n *    supportVariableWidth: (bool) if true, the carousel will do extra calculations\n *        to support this.elements which do not all have the same width. Does not work\n *        in conjunction with\n *    describedby: (string) if provided, theh carousel will use an aria-describedby\n *\n */\n(function () {\n    'use strict';\n    angular.module('ovpApp.directives.carousel', [])\n    .factory('carouselCoordinator', carouselCoordinator)\n    .component('ovpCarousel', {\n        bindings: {\n            items: '<',\n            options: '<',\n            onLimitChanged: '&?'\n        },\n        transclude: true,\n        templateUrl: '/js/ovpApp/directives/ovp-carousel-template.html',\n        controller: class OvpCarousel {\n            /* @ngInject */\n            constructor($element, $window, $log, carouselCoordinator, $q, $document,\n                $timeout) {\n                angular.extend(this, {$element, $window, $log, carouselCoordinator, $q, $document,\n                    $timeout});\n            }\n\n            $onInit() {\n                this.transformation = {};\n                this.elements = [];\n                this.elementWidths = [];\n                this.scrollIndex = 0;\n\n                this.boundMeasureViewport = this.measureViewport.bind(this);\n                angular.element(this.$window).on('resize', this.boundMeasureViewport);\n            }\n\n            $onChanges(changes) {\n                if (changes.options) {\n                    this.applyDefaultOptions(changes.options.currentValue);\n                }\n                if (changes.items && !changes.items.isFirstChange()) {\n                    if (!this.waitUntilVisibleDefer) {\n                        this.waitUntilVisible()\n                            .then(() => this.measureElements());\n                    } // else, we're already waiting. Don't try to measure multiple times.\n                }\n            }\n\n            $postLink() {\n                this.carouselCoordinator.setTimeoutZero(() => {\n                    this.waitUntilVisible()\n                        .then(() => {\n                            this.measureElements();\n                            this.measureViewport();\n                            this.updateCss();\n                            this.updateLimit();\n                        });\n                    this.$element.find('.carousel-layout').on('scroll', this.onLayoutScrolled);\n                });\n            }\n\n            $doCheck() {\n                if (this.waitUntilVisibleDefer) {\n                    if (this.$element.hasClass('ng-hide') === false) {\n                        this.waitUntilVisibleDefer.resolve();\n                        this.waitUntilVisibleDefer = undefined;\n                    }\n                }\n            }\n\n            $onDestroy() {\n                angular.element(this.$window).off('resize', this.boundMeasureViewport);\n                this.$element.find('.carousel-layout').off('scroll', this.onLayoutScrolled);\n            }\n\n\n            leftClick($event) {\n                $event.stopPropagation();\n\n                this.scrollIndex = this.prevIndex(this.elementWidths, this.viewportWidth, this.scrollIndex);\n\n                this.updateCss();\n                this.updateLimit();\n            }\n\n            rightClick($event) {\n                $event.stopPropagation();\n\n                let oldIndex = this.scrollIndex;\n                this.scrollIndex = this.nextIndex(this.elementWidths, this.viewportWidth, this.scrollIndex);\n                if (oldIndex === this.scrollIndex && this.options.showReturnArrow) {\n                    this.scrollIndex = 0;\n                }\n\n                this.updateCss();\n                this.updateLimit();\n            }\n\n            leftArrowClass() {\n                let isAtEnd = this.scrollIndex ===\n                    this.prevIndex(this.elementWidths, this.viewportWidth, this.scrollIndex);\n                let classList = {\n                    'hidden': this.isSinglePage(),\n                    'arrow-hidden': isAtEnd,\n                    'arrow-left': true\n                };\n                classList[this.options.arrowIconClass] = true;\n                return classList;\n            }\n\n            rightArrowClass() {\n                let classObj = {\n                    'hidden': this.isSinglePage()\n                };\n                classObj[this.options.arrowIconClass] = true;\n\n                let isAtEnd = this.scrollIndex ===\n                    this.nextIndex(this.elementWidths, this.viewportWidth, this.scrollIndex);\n                if (isAtEnd) {\n                    if (this.options.showReturnArrow) {\n                        classObj['return-arrow'] = true;\n                    } else {\n                        classObj['arrow-hidden'] = true;\n                        classObj['arrow-right'] = true;\n                    }\n                } else {\n                    classObj['arrow-right'] = true;\n                }\n                return classObj;\n            }\n\n            onKeydown(event) {\n                const keys = {left: 37, up: 38, right: 39, down: 40, tab: 9};\n                if (!this.options.useArrows) {\n                    if (event.keyCode == keys.tab) {\n                        this.$timeout(() => {\n                            let index = this.findIndex(this.$document[0].activeElement);\n                            if (index >= 0) {\n                                this.focus(index);\n                            }\n                        }, 0);\n                    }\n                    return;\n                }\n\n                if (event.keyCode == keys.left || event.keyCode == keys.up) {\n                    let index = this.findIndex(event.target);\n                    this.focus(index - 1);\n                    event.preventDefault();\n                } else if (event.keyCode == keys.right || event.keyCode == keys.down) {\n                    let index = this.findIndex(event.target);\n                    this.focus(index + 1);\n                    event.preventDefault();\n                } else if (event.keyCode == keys.tab) {\n                    // reset focus to first element so shift-tab can move to prev carousel\n                    this.focus(0);\n                    // Deliberately not calling preventDefault()\n                }\n            }\n\n            ////////////////\n\n            waitUntilVisible() {\n                if (this.$element.hasClass('ng-hide')) {\n                    this.waitUntilVisibleDefer = this.waitUntilVisibleDefer || this.$q.defer();\n                    return this.waitUntilVisibleDefer.promise;\n                } else {\n                    return this.$q.resolve();\n                }\n            }\n\n            applyDefaultOptions(newOptions) {\n                const defaults = {\n                    showReturnArrow: true,\n                    title: '',\n                    showTitle: true,\n                    arrowIconClass: 'default-arrow-icon',\n                    useArrows: true,\n                    supportVariableWidth: false,\n                    describedby: null\n                };\n\n                this.options = angular.extend({}, defaults, newOptions);\n                this.limit = this.options.initialLimit;\n                if (angular.isNumber(this.options.initialFocus)) {\n                    carouselCoordinator.setTimeoutZero(() => this.focus(this.options.initialFocus));\n                }\n                this.setLabelInstructions();\n            }\n\n            setLabelInstructions() {\n                if (!this.options.description) {\n                    this.options.ariaLabel = this.options.title +\n                        (this.options.useArrows ? ', Move through items in the row with the ' +\n                        'right and left arrow keys; select a program using the enter key. Tab will take' +\n                        ' you to the next row' : '');\n                } else {\n                    this.options.ariaLabel = this.options.title + ', ' + this.options.description;\n                }\n            }\n\n            measureElements() {\n                this.elements = this.$element.find('.carousel-items').children();\n                this.elementCountDirty = false;\n\n                if (this.elements.length === 0 && this.items.length > 0) {\n                    this.$log.warn('carousel unexpectedly found no child this.elements.' +\n                        ' If using a limitTo filter, make sure it starts > 0');\n                }\n\n                if (this.options.supportVariableWidth) {\n                    // Need to measure every one of them\n                    this.elementWidths = Array.from(this.elements).map(e => angular.element(e).outerWidth(true));\n                } else {\n                    // Just need to measure one and then copy the value\n                    let firstItemWidth = this.elements.outerWidth(true);\n                    this.elementWidths = this.items.map(() => firstItemWidth);\n                }\n            }\n\n            measureViewport() {\n                this.viewportWidth = this.$element.find('.carousel-layout').innerWidth();\n            }\n\n\n            isSinglePage() {\n                let totalWidth = this.elementWidths.reduce((a, b) => a + b, 0) - 1;\n                return totalWidth <= this.viewportWidth;\n            }\n\n            lastVisibleIndex(elementWidths, viewportWidth, currentIndex) {\n                let accumulatedWidth = 0;\n                for (let i = currentIndex; i < this.elementWidths.length; i++) {\n                    accumulatedWidth += this.elementWidths[i];\n                    if (accumulatedWidth > this.viewportWidth) {\n                        return i - 1;\n                    }\n                }\n\n                return this.elementWidths.length - 1;\n            }\n\n            nextIndex(elementWidths, viewportWidth, currentIndex) {\n                let distanceFromRight = [];\n                elementWidths.reduceRight((a, b, i) => distanceFromRight[i] = a + b, 0);\n\n                let differencePx = 0;\n                for (let i = currentIndex; i < elementWidths.length; i++) {\n                    differencePx += elementWidths[i];\n                    let endOfViewport = distanceFromRight[i] <= viewportWidth;\n                    let fullPage = differencePx > viewportWidth;\n                    if (fullPage) {\n                        // We subtract 1 to leave one item on the left visible, for context\n                        return Math.max(0, i - 1);\n                    } else if (endOfViewport) {\n                        return i;\n                    }\n                }\n\n                return currentIndex;\n            }\n\n            prevIndex(elementWidths, viewportWidth, currentIndex) {\n                let differencePx = 0;\n                for (let i = currentIndex; i >= 0; i--) {\n                    differencePx += elementWidths[i];\n                    let fullPage = differencePx > viewportWidth;\n                    if (fullPage) {\n                        // we add 1 to leave one item on the right visible, for context\n                        return Math.min(elementWidths.length - 1, i + 1);\n                    }\n                }\n\n                // Left edge\n                return 0;\n            }\n\n            updateCss() {\n                let scrollPx = this.elementWidths.reduce((a, b, i) => i >= this.scrollIndex ? a : a + b, 0);\n                let translateXCss = 'translateX(' + (-scrollPx) + 'px)',\n                    translateZCss = ' translateZ(0)';\n\n                this.transformation = {\n                    transform: translateXCss + translateZCss,\n                    '-webkit-transform': translateXCss + translateZCss,\n                    '-moz-transform': translateXCss + translateZCss,\n                    '-ms-transform': translateXCss,\n                    '-o-transform': translateXCss + translateZCss\n                };\n            }\n\n            /**\n             * Helper method for lazy-loading of carousel items. Based on the current index, calculates how many\n             * items the ng-repeat must show in order to be able to scroll a page and not inconvenience the user.\n             *\n             * Note: In variable width mode, it's impossible to predict how many not-yet-rendered items are needed\n             * so variable width + lazy loading isn't supported.\n             *\n             * @param  {number} index index the user is interacting with. Defaults to the scroll index\n             */\n            updateLimit(index = this.scrollIndex) {\n                if (!this.onLimitChanged) {\n                    // No one's listening\n                    return;\n                } else if (this.options.supportVariableWidth) {\n                    this.$log.warn('you registered for limit changes, but that ' +\n                        'isn\\'t supported in variable width mode');\n                    this.onLimitChanged({limit: this.elementWidths.length});\n                    return;\n                }\n\n                let left = this.nextIndex(this.elementWidths, this.viewportWidth, index);\n                let i, accumulatedWidth = 0;\n                for (i = left; i < this.elementWidths.length; i++) {\n                    if (accumulatedWidth > this.viewportWidth) {\n                        // This item is the first one that will be invisible after the next scroll\n                        break;\n                    }\n                    accumulatedWidth += this.elementWidths[i];\n                }\n\n                let limit = Math.min(i, this.elementWidths.length);\n                this.onLimitChanged({limit});\n                this.elementCountDirty = true;\n            }\n\n            findIndex(el) {\n                const maximumDepth = 10;\n                let index;\n                let elArray = Array.from(this.elements);\n                for (let i = 0; i < maximumDepth; i++) {\n                    index = elArray.indexOf(el);\n                    if (index > -1) {\n                        return index;\n                    } else {\n                        el = el.parentElement;\n                        if (!el) {\n                            break;\n                        }\n                    }\n                }\n\n                return -1;\n            }\n\n            focus(index) {\n                if (this.elementCountDirty) {\n                    this.measureElements();\n                }\n\n                let newFocus = this.elements[index];\n                if (newFocus) {\n                    angular.element(newFocus).find('a, .carousel-selectable').focus();\n                }\n\n                if (index > this.lastVisibleIndex(this.elementWidths, this.viewportWidth, this.scrollIndex)) {\n                    this.scrollIndex = this.nextIndex(this.elementWidths, this.viewportWidth, this.scrollIndex);\n                    this.updateCss();\n                } else if (index < this.scrollIndex) {\n                    this.scrollIndex = this.prevIndex(this.elementWidths, this.viewportWidth, this.scrollIndex);\n                    this.updateCss();\n                }\n\n                this.updateLimit(index);\n            }\n\n            onLayoutScrolled(event) {\n                // The layout scrolled, because the focus changed and couldn't fit in the\n                // viewport. This can happen when tabbing rapidly, since the css animation\n                // may not have completed. In any event, we want to keep the control in the\n                // hands of the css, not the scroll postition, so we need to reset it.\n                event.target.scrollLeft = 0;\n            }\n\n            // Used by components inside the carousel to determine their appropriate tab index\n            itemTabIndex(item) {\n                if (this.options.useArrows) {\n                    let index = this.items.indexOf(item);\n                    return index === 0 ? '' : '-1';\n                } else {\n                    return '';\n                }\n            }\n        }\n    });\n\n    /* @ngInject */\n    function carouselCoordinator($timeout) {\n        // Coordinates multiple carousels so they can do their resize logic all at once and not\n        // kick off redundant $digest cycles\n        const service = {\n            setTimeoutZero\n        };\n\n        let promise;\n\n        return service;\n\n        //////////\n\n        function setTimeoutZero(callback) {\n            if (!promise) {\n                promise = $timeout(angular.noop, 0);\n                promise.then(() => promise = undefined);\n            }\n\n            promise.then(callback);\n        }\n    }\n})();\n"],"sourceRoot":"/source/"}