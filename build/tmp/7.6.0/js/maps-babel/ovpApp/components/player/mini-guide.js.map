{"version":3,"sources":["ovpApp/components/player/mini-guide.js"],"names":[],"mappings":"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","file":"ovpApp/components/player/mini-guide.js","sourcesContent":["/*jshint -W072 */\n(function () {\n    'use strict';\n\n    const keys = {up: 38, down: 40, tab: 9, enter: 13, space: 32, right: 39, left: 37};\n\n    /**\n     * miniGuide\n     *\n     * Example Usage:\n     * <mini-guide player=\"someInputValue\"</mini-guide>\n     *\n     * Bindings:\n     *    player: ([type]) flash player object\n     *    liveTmsId: ([type]) channel to tune to (optional)\n     *    eanUrl: ([type]) ean to tune to (optional)\n     */\n    angular.module('ovpApp.playerControls.miniGuide', [\n            'ovpApp.player',\n            'ovpApp.player.whatsOn',\n            'ovpApp.player.streamService',\n            'ovpApp.playerControls.miniGuideData',\n            'ovpApp.config',\n            'ovpApp.services.ovpStorage',\n            'ovpApp.services.parentalControlsService',\n            'ovpApp.services.errorCodes',\n            'ovpApp.services.profileService',\n            'ovpApp.components.alert',\n            'ovpApp.services.locationService',\n            'ovpApp.messages',\n            'ovpApp.video',\n            'ovpApp.version',\n            'ovpApp.directives.lazySrc',\n            'ajoslin.promise-tracker',\n            'ovpApp.services.rxUtils',\n            'vs-repeat',\n            'ovpApp.oauth'\n        ])\n        .component('miniGuide', {\n            bindings: {\n                player: '<',\n                liveTmsId: '<',\n                eanUrl: '<'\n            },\n            templateUrl: '/js/ovpApp/components/player/mini-guide.html',\n            controller: class MiniGuide {\n                /* @ngInject */\n                constructor($scope, $q, playerStreamService, config, miniGuideData, ovpStorage,\n                    $state, parentalControlsService, profileService, CAPABILITIES, alert, locationService,\n                    messages, TWCVideoJS, playerErrors, $timeout, $rootScope, version, $element, promiseTracker,\n                    playerControlTimer, createObservableFunction, storageKeys, playerService, errorCodesService,\n                    OauthDataManager) {\n\n                    angular.extend(this, {$scope, $q, playerStreamService, config, miniGuideData,\n                        ovpStorage, $state, parentalControlsService, profileService, CAPABILITIES, alert,\n                        locationService, messages, TWCVideoJS, playerErrors, $timeout, $rootScope, version, $element,\n                        promiseTracker, playerControlTimer, createObservableFunction, storageKeys, playerService,\n                        errorCodesService, OauthDataManager});\n                }\n\n                $onInit() {\n                    this.focusedChannel = null;\n                    this.miniGuideVisible = true;\n                    this.showChannelNumber = true;\n                    this.filtersVisible = false;\n                    this.filterSelection = null;\n                    this.channels = [];\n                    this.filters = [];\n                    this.currentAppliedFilter = {};\n                    this.selectedFilter = {};\n                    this.sorts = [];\n                    this.currentAppliedSort = {};\n                    this.selectedSort = {};\n                    this.filteredChannels = [];\n                    this.initialChannel = undefined;\n                    this.version = this.version.appVersion;\n                    this.channelSelectedBy = 'application';\n                    this.parentalControlsEnabled = false;\n                    this.loadingTracker = this.promiseTracker();\n                    this.eventSubscriptions = [];\n                    this.sortVisible = true;\n                    this.allChannelsMsg = '';\n\n                    this.profileService.isAccessibilityEnabled().then((isEnabled) => {\n                        //No need to track changes to accessibility capability change\n                        //as app will get reloaded when accessibility mode changes\n                        this.isAccessibilityEnabled = isEnabled;\n                    });\n\n                    // Spec U hides channel numbers\n                    this.isSpecU = this.profileService.isSpecU();\n\n                    if (this.isSpecU) {\n                        this.sortVisible = false;\n                        this.showChannelNumbers = false;\n                    }\n\n                    if (!this.waitForPlayer) {\n                        this.waitForPlayer = this.$q.defer();\n                    }\n\n                    // Throttle to improve the performace while scrolling as\n                    // we get lot of scrolling events at once.\n                    this.throttledScrollingFn = this.createObservableFunction();\n\n                    this.lastScrollPosition = 0;\n                    let scrollThreshold = 500;\n\n                    let promise = this.$q.all([\n                        this.loadChannelData(),\n                        this.registerCallbacks()\n                    ]).then(([initialChannel]) => {\n                        this.selectChannel(initialChannel);\n                        this.scrollToChannel(this.selectedChannel);\n                        this.showMiniGuide();\n                        this.isParentalControlsEnabled();\n                    });\n\n                    this.loadingTracker.addPromise(promise);\n\n                    this.eventSubscriptions[this.eventSubscriptions.length] = this.$rootScope.$on('scrollable:scrolled',\n                        (evt, element) => {\n                            let filteredLastChannelNumber, limitLastChannelNumber;\n                            let scrollTop = element.scrollTop();\n                            let limitLastChildElement = angular.element(element[0].lastElementChild)\n                                .find('.channel-number');\n\n                            if (this.filteredChannels.length > 0 &&\n                                limitLastChildElement &&\n                                limitLastChildElement.length > 0) {\n                                filteredLastChannelNumber = this.filteredChannels[this.filteredChannels.length - 1]\n                                    .localChannelNumber;\n                                limitLastChannelNumber = parseInt(limitLastChildElement[0].innerHTML);\n                            }\n                            // We need to scroll down.\n                            if (scrollTop > this.lastScrollPosition) {\n                                // When we have reached the bottom of the mini guide then load more elements.\n                                if ((scrollTop + element.innerHeight()) >= (element[0].scrollHeight)) {\n                                    if (limitLastChannelNumber != filteredLastChannelNumber) {\n                                        this.throttledScrollingFn('scrollDown');\n                                    }\n                                }\n                            } else { // We need to scroll up.\n                                if (scrollTop <= 0) {\n                                    if (this.begin > 0) {\n                                        this.throttledScrollingFn();\n                                        // So that user can scroll again if the channels are\n                                        // still pending at the top.\n                                        element.scrollTop(scrollThreshold);\n                                    }\n                                }\n                            }\n                            this.lastScrollPosition = scrollTop;\n                        });\n\n                    this.eventSubscriptions[this.eventSubscriptions.length] =\n                        this.$rootScope.$on('connectivityService:statusChanged', (e, isOnline) => {\n                            if (isOnline) {\n                                this.loadChannelData();\n                            }\n                        });\n\n\n                    this.$scope.$on('player-control:click', () => {\n                        this.onPlayerMouseDown();\n                    });\n\n                    this.$scope.$on('player-control:hide', () => {\n                        this.miniGuideVisible = false;\n                    });\n\n                    this.$scope.$on('player:fullscreen-toggled', (event, data) => {\n                        if (data.isEnabled) {\n                            this.miniGuideVisible = false;\n                        }\n                    });\n\n                    this.$scope.$watch(() => this.miniGuideVisible, newValue => {\n                        this.$rootScope.$broadcast('player-control:guide-toggled', {isVisible: newValue});\n                        this.ariaAnnouncement = '';\n                        if (newValue === true) {\n                            this.setAriaAnnouncement('Mini Guide Opened');\n                        }\n                        this.$scope.$evalAsync();\n                    });\n                }\n\n                $onChanges(changes) {\n                    if (changes.player) {\n                        if (angular.isDefined(this.player)) {\n                            if (!this.waitForPlayer) {\n                                this.waitForPlayer = this.$q.defer();\n                            }\n                            this.waitForPlayer.resolve();\n                        }\n                    }\n                }\n\n                $onDestroy() {\n                    this.miniGuideData.onPlayerDestroyed();\n                    this.eventSubscriptions.forEach(sub => sub());\n\n                    if (this.playerSubscriptions) {\n                        Object.keys(this.playerSubscriptions)\n                            .forEach(key => this.player.off(key, this.playerSubscriptions[key]));\n                    }\n\n                    if (this.retryPromise) {\n                        this.$timeout.cancel(this.retryPromise);\n                    }\n                }\n\n                isParentalControlsEnabled() {\n                    this.parentalControlsService.isParentalControlsDisabledForClient()\n                        .then(isDisabled => this.parentalControlsEnabled = !isDisabled);\n\n                    this.eventSubscriptions[this.eventSubscriptions.length] = this.$rootScope.$on(\n                        'player:parentalControlsUnblocked',\n                        () => this.parentalControlsEnabled = false);\n                }\n\n                isPrevious (event) {\n                    return [keys.up, keys.left].indexOf(event.keyCode) > -1;\n                }\n\n                isNext (event) {\n                    return [keys.down, keys.right].indexOf(event.keyCode) > -1;\n                }\n\n                channelBrowserKeyDown(event) {\n                    if ([keys.up, keys.down, keys.enter,\n                        keys.space, keys.left, keys.right].indexOf(event.keyCode) > -1) {\n                        // This is to stop the default scrolling of the mini guide.\n                        event.preventDefault();\n                        var childElement = this.$element.find('.selected'),\n                            selectedElement = {},\n                            selectedElementBounds,\n                            elementBounds;\n\n                        // When user selects the channel from the mini guide.\n                        if (event.keyCode === keys.enter) {\n                            if (this.focusedChannel === this.selectedChannel &&\n                                this.selectedChannel.isParentallyBlocked) {\n                                this.$rootScope.$emit('player:focusUnblock');\n                            } else if (this.focusedChannel === this.selectedChannel &&\n                                this.focusedChannel.hasLinkedVODAsset) {\n                                this.setAriaAnnouncement('Restarting Show');\n                                //give time for announcement\n                                this.$timeout(() => {\n                                    this.startOver(this.selectedChannel);\n                                }, 500);\n                            } else {\n                                this.selectChannel(this.focusedChannel);\n                            }\n                        } else if (this.isNext(event))  {\n                            selectedElement = childElement.next('[selectable]');\n                            if (selectedElement.length > 0) {\n                                selectedElementBounds = selectedElement[0].getBoundingClientRect();\n                                elementBounds = this.$element[0].getBoundingClientRect();\n                                if (selectedElementBounds.top + selectedElementBounds.height >\n                                    (elementBounds.height + elementBounds.top)) {\n                                    this.$element.scrollTop(this.$element.scrollTop() + selectedElementBounds.height);\n                                }\n                            } else {\n                                // When user reachea at the bottom of the screen using keyboard then\n                                // load more elements.\n                                this.throttledScrollingFn('scrollDown');\n                            }\n                        } else if (this.isPrevious(event)) {\n                            selectedElement = childElement.prev('[selectable]');\n                            if (selectedElement.length > 0) {\n                                selectedElementBounds = selectedElement[0].getBoundingClientRect();\n                                elementBounds = this.$element[0].getBoundingClientRect();\n                                if (selectedElementBounds.bottom <= elementBounds.top) {\n                                    this.$element.scrollTop(this.$element.scrollTop() - selectedElementBounds.height);\n                                }\n                            } else {\n                                // When user reachea at the top of the screen using keyboard then\n                                // load more elements.\n                                this.throttledScrollingFn();\n                            }\n                        }\n                        if (selectedElement.length > 0) {\n                            childElement.blur();\n                            selectedElement.focus();\n                        }\n                    }\n                }\n\n                //could be a directive\n                sortOnKeyDown(event, sort) {\n                    if (event.keyCode === keys.enter || event.keyCode === keys.space) {\n                        this.selectedSort = sort;\n                        if (!this.isAccessibilityEnabled) {\n                            this.setFocusOnChannelFromFilterSelection();\n                            this.onSortChanged();\n                            const name = this.selectedSort.name.replace('-', ' through ');\n                            this.setAriaAnnouncement('Sort Changed to: ' + name);\n                        }\n                    } else if (this.isNext(event)) {\n                        event.preventDefault();\n                        this.$element.find('#sort-' + (this.sorts.indexOf(this.focusedSort) + 1)).focus();\n                    } else if (this.isPrevious(event)) {\n                        event.preventDefault();\n                        this.$element.find('#sort-' + (this.sorts.indexOf(this.focusedSort) - 1)).focus();\n                    }\n                }\n\n                onSortFocus(sort) {\n                    this.focusedSort = sort;\n                    this.sortAria = sort.name.replace('-', ' through ');\n                }\n\n                filterLabelKeyDown(event) {\n                    if (event.keyCode === keys.tab && !event.shiftKey) {\n                        if (!this.filtersVisible) {\n                            event.preventDefault();\n                            this.setFocusOnChannelFromFilterSelection();\n                        }\n                    } else if ([keys.space, keys.enter].indexOf(event.keyCode) > -1) {\n                        event.preventDefault();\n                        this.filtersVisible = !this.filtersVisible;\n                    }\n                }\n\n                filterOnKeyDown(event, filter) {\n                    if (event.keyCode === keys.enter || event.keyCode === keys.space) {\n                        this.selectedFilter = filter;\n                        if (!this.isAccessibilityEnabled) {\n                            this.setFocusOnChannelFromFilterSelection();\n                            this.onFilterChanged();\n                            this.setAriaAnnouncement('Filter Changed to: ' + this.selectedFilter.name);\n                        }\n                    } else if (this.isNext(event)) {\n                        event.preventDefault();\n                        this.$element.find('#filter-' + (this.filters.indexOf(this.focusedFilter) + 1)).focus();\n                    }  else if (this.isPrevious(event)) {\n                        event.preventDefault();\n                        this.$element.find('#filter-' + (this.filters.indexOf(this.focusedFilter) - 1)).focus();\n                    }\n                }\n\n                filterCancelKeyDown(event) {\n                    if (event.keyCode === keys.tab && !event.shiftKey) {\n                        this.filtersVisible = !this.filtersVisible;\n                    }\n                }\n\n                onFilterFocus(filter) {\n                    this.focusedFilter = filter;\n                }\n\n                registerCallbacks() {\n                    return this.waitForPlayer.promise\n                        .then(() => {\n                            this.playerSubscriptions = {\n                                'player-mouse-down': () => this.onPlayerMouseDown(),\n                                'error': (error) => this.onVideoPlayerError(error)\n                            };\n\n                            Object.keys(this.playerSubscriptions)\n                                .forEach(key => this.player.on(key, this.playerSubscriptions[key]));\n\n                            let playSelectedChannelHandler = this.playSelectedChannel.bind(this);\n                            let onEanHandler = this.onEan.bind(this);\n                            this.$scope.$on('player:blockChanged', playSelectedChannelHandler);\n                            this.$rootScope.$on('EAN:start', onEanHandler);\n                        });\n                }\n\n                setFocusOnChannelFromFilterSelection(options) {\n                    options = options || {};\n                    const channel = this.filteredChannels.indexOf(this.selectedChannel) < 0 ?\n                        this.filteredChannels[0] : this.selectedChannel;\n                    this.scrollToChannel(channel)\n                        .then(() => {\n                            if (!options.noFocus) {\n                                this.focusChannel(channel);\n                            }\n                        });\n                }\n\n                showMiniGuide($event) {\n                    if (!this.miniGuideVisible) {\n                        this.miniGuideVisible = true;\n                        if ($event) {\n                            $event.preventDefault();\n                        }\n                    }\n                    this.playerControlTimer.scheduleHide();\n                }\n\n                onPlayerMouseDown() {\n                    //set focus on dummy element so next tab is filters\n                    this.playerMouseDown = true;\n                    angular.element('#player-mouse-down-focus')[0].focus();\n                    this.playerMouseDown = false;\n                    this.miniGuideVisible = !this.miniGuideVisible;\n                }\n\n                onChannelFocussed(channel) {\n                    this.focusedChannel = channel;\n                }\n\n                setAriaAnnouncement(data) {\n                    this.ariaAnnouncement = data;\n                    //clearing the aria announcement after giving time for announcements\n                    //This is required for NGC-6039 where subsequent announcements are messed up\n                    //if this is not cleared up.\n                    this.$timeout(() => {\n                        this.ariaAnnouncement = '';\n                    }, 500);\n                }\n\n                selectChannel(channel, evt) {\n                    if (this.selectedChannel !== channel) {\n\n                        // If no initial channel, assume the application is automatically\n                        // selecting the channel. In all other cases, assume the user chose.\n                        this.channelSelectedBy = ('undefined' === typeof this.selectedChannel ? 'application' : 'user');\n                        this.focusedChannel = channel;\n                        this.selectedChannel = channel;\n\n                        // Analytics (Should only emit when user clicks, not when app auto-selects)\n                        if (evt && this.channelSelectedBy === 'user') {\n\n                            this.$rootScope.$emit('Analytics:select-channel', {\n                                channel: channel,\n                                triggeredBy: this.channelSelectedBy\n                            });\n                        }\n\n                        this.playSelectedChannel();\n                    }\n                }\n\n                onFilterOrSortChanged() {\n                    //don't set focus on current channel when filter/sorts are changed and set focus on\n                    //filter label.\n                    this.setFocusOnChannelFromFilterSelection({noFocus: this.isAccessibilityEnabled});\n                    this.filtersVisible = !this.filtersVisible;\n                    this.lastScrollPosition = 0;\n                }\n\n                onFilterChanged() {\n                    if (!this.isAccessibilityEnabled) {\n                        // Added this check to prevent this event from sending twice to\n                        // EG in case of Flash UI as we have already send it from\n                        // `VideoJSOutboundEvent.as`.\n                        this.currentAppliedFilter = this.selectedFilter;\n                        this.player.trigger('channel-filter-changed', this.selectedFilter);\n                        this.miniGuideData.setSelectedFilter(this.selectedFilter);\n                        this.onFilterOrSortChanged();\n\n                        // Analytics:\n                        this.$rootScope.$broadcast('Analytics:guide:updateFilter', {\n                            filter: this.currentAppliedFilter\n                        });\n                    }\n                }\n\n                onCancel() {\n                    //onCancel is only invoked when accessibility is enabled\n                    //so added this as a guard\n                    if (this.isAccessibilityEnabled) {\n                        this.filtersVisible = !this.filtersVisible;\n                        //Reset sort & filter\n                        this.selectedSort = this.currentAppliedSort;\n                        this.selectedFilter = this.currentAppliedFilter;\n                        //Set focus back on filter label\n                        angular.element('.filter-selection').focus();\n                    }\n                }\n\n                onApply() {\n                    //onApply is only invoked when accessibility is enabled\n                    //so added this as a guard\n                    if (this.isAccessibilityEnabled) {\n                        if (this.selectedSort !== this.currentAppliedSort) {\n                            //Sort has changed\n                            this.miniGuideData.setSelectedSort(this.selectedSort);\n                            this.player.trigger('channel-filter-changed', this.selectedFilter);\n\n                            // Analytics:\n                            this.$rootScope.$broadcast('Analytics:guide:updateSort', {\n                                sort: this.selectedSort\n                            });\n                        }\n\n                        if (this.selectedFilter !== this.currentAppliedFilter) {\n                            //Filter has changed\n                            this.player.trigger('channel-sortby-changed', this.selectedSort.egName);\n                            this.miniGuideData.setSelectedFilter(this.selectedFilter);\n\n                            // Analytics:\n                            this.$rootScope.$broadcast('Analytics:guide:updateFilter', {\n                                filter: this.selectedFilter\n                            });\n                        }\n                        this.currentAppliedSort = this.selectedSort;\n                        this.currentAppliedFilter = this.selectedFilter;\n                        this.onFilterOrSortChanged();\n                        //Set focus back on filter label\n                        angular.element('.filter-selection').focus();\n                    }\n                }\n\n                getFilterName(filter) {\n                    let name = filter.name;\n                    if (filter.channelCount !== undefined) {\n                        name += ` (${filter.channelCount})`;\n                    }\n                    return name;\n                }\n                getFilterNameForAria(filter) {\n                    let name = filter.name;\n                    if (filter.channelCount !== undefined) {\n                        name += `, ${filter.channelCount}`;\n                    }\n                    return name;\n                }\n\n                onSortChanged() {\n                    if (!this.isAccessibilityEnabled) {\n                        // Added this check to prevent this event from sending twice to\n                        // EG in case of Flash UI as we have already send it from\n                        // `VideoJSOutboundEvent.as`.\n                        this.currentAppliedFilter = this.selectedFilter;\n                        this.player.trigger('channel-sortby-changed', this.selectedSort.egName);\n                        this.miniGuideData.setSelectedSort(this.selectedSort);\n                        this.onFilterOrSortChanged();\n\n                        // Analytics:\n                        this.$rootScope.$broadcast('Analytics:guide:updateSort', {\n                            sort: this.selectedSort\n                        });\n                    }\n                }\n\n                startOver(channel) {\n                    let program = channel.asset;\n                    let channelNumber = channel.localChannelNumber;\n                    if (channelNumber !== undefined) {\n                        this.ovpStorage.setItem('twctv:startOverChannelInfo', JSON.stringify({\n                            channelNumber: channelNumber,\n                            channelID: channel.channelId\n                        }));\n                    }\n\n                    if (program) {\n                        let seriesId = program.vodTmsSeriesId;\n                        let vodProviderAssetId = program.vodProviderAssetId;\n                        let state, params;\n                        if (seriesId) {\n                            state = 'ovp.ondemand.playEpisodeWithDetails';\n                            params = {\n                                seriesID: seriesId,\n                                episodeID: vodProviderAssetId\n                            };\n                        } else {\n                            state = 'ovp.ondemand.playProduct';\n                            params = {\n                                productID: vodProviderAssetId\n                            };\n                        }\n                        params.startOver = true;\n                        this.$state.go(state, params);\n                    } else {\n                        this.alert.open({\n                            message: this.errorCodesService.getMessageForCode('WGE-1001'),\n                            buttonText: 'OK'\n                        });\n                    }\n                }\n\n                isEANChannel(channel) {\n                    return channel && channel.localChannelNumber === this.config.eanChannelNumber;\n                }\n\n                /**\n                 * Loads channel data. Doesn't attempt to insert it into the player, so this function\n                 * can safely be run while the player is still initializing\n                 * @return {[type]} [description]\n                 */\n                loadChannelData() {\n                    return this.miniGuideData.getData(this.liveTmsId, this.eanUrl)\n                        .then(data => {\n                            this.channels = data.channels;\n                            this.filters = data.filters;\n                            this.sorts = data.sorts;\n                            this.filteredChannels = data.filteredChannels;\n                            this.selectedSort = data.selectedSort; //Keeps track of selected sort by radio\n                            this.currentAppliedSort = data.selectedSort; //Keeps track of current applied sort\n                            this.selectedFilter = data.selectedFilter; //Keeps track of selected filter by radio\n                            this.currentAppliedFilter = data.selectedFilter; //Keeps track of current applied filter\n                            //TODO: whether or not filters are allowed (Based on location and config)\n                            return data.selectedChannel;\n                        });\n                }\n\n                onEan(event, {eanUrl}) {\n                    this.eanUrl = eanUrl;\n                    this.selectChannel(this.miniGuideData.addDummyEANChannel(eanUrl));\n                }\n\n                playSelectedChannel() {\n                    if (this.isEANChannel(this.selectedChannel)) {\n                        return this.playEan();\n                    } else {\n                        if (this.onEanCompletion) {\n                            this.onEanCompletion();\n                        }\n                        // start the channelUpdateTimer even if we have not been able to play the asset,\n                        // so that if user decides to still be on the channel,\n                        // we can try to play the new asset when current asset ends.\n                        this.miniGuideData.startChannelUpdateTimer(this.selectedChannel);\n                        return this.playerStreamService.playChannel({\n                                player: this.player,\n                                channel: this.selectedChannel,\n                                triggeredBy: this.channelSelectedBy})\n                            .then(() => {\n                                this.miniGuideData.setSelectedChannel(this.selectedChannel);\n                            }).catch(err => this.onPlayChannelError(err));\n                    }\n                }\n\n                playEan() {\n                    let promise = this.playerStreamService.playEAN({player: this.player, eanUrl: this.eanUrl})\n                        .then(() => {\n                            let wasMuted = this.ovpStorage.getItem(this.storageKeys.muted);\n                            this.player.setMuted(false);\n                            this.onEanCompletion = function (event) {\n                                this.player.setMuted(wasMuted);\n                                if (event) {\n                                    this.selectChannel(this.miniGuideData.getDefaultChannel(this.liveTmsId));\n                                }\n\n                                this.player.off('playback-stopped', this.onEanCompletion);\n                                this.onEanCompletion = undefined;\n\n                                this.miniGuideData.removeDummyEANChannel();\n                            };\n                            this.player.on('playback-stopped', this.onEanCompletion);\n                        })\n                        .catch(err => this.onPlayChannelError(err));\n\n                    this.eanUrl = undefined;\n\n                    return promise;\n                }\n\n                onPlayChannelError(error) {\n                    if (error == this.playerErrors.tunedAway || error == this.playerErrors.oohFraudDetection) {\n                        return;\n                    } else if (error == this.playerErrors.outOfHome) {\n                        this.locationService.resetCache();\n                        this.onUnavailableChannelSelected();\n                    } else if (error == this.playerErrors.unentitled) {\n                        this.alert.open(this.errorCodesService.getAlertForCode('WEN-1004', {\n                            IVR_NUMBER: this.config.ivrNumber\n                        }));\n                    } else if (error == this.playerErrors.notFound) {\n                        this.alert.open({\n                            message: this.errorCodesService.getMessageForCode('WCH-1000', {\n                                CHANNEL: this.selectedChannel.localChannelNumber\n                            }),\n                            buttonText: 'OK'\n                        });\n                    } else {\n                        this.alert.open({\n                            message: this.errorCodesService.getMessageForCode('WGE-1001'),\n                            buttonText: 'OK'\n                        });\n                    }\n                }\n\n                onUnavailableChannelSelected() {\n                    this.alert.open(this.errorCodesService.getAlertForCode('WLC-1000'));\n                }\n\n                onVideoPlayerError(error) {\n                    let codes = this.TWCVideoJS.FlashVideoPlayer.playerErrorCodes;\n                    if (error.errorID === codes.STREAMING_FAILED_ERROR) {\n                        this.$rootScope.$emit('Analytics:playbackFailure', {\n                            asset: this.selectedChannel.asset,\n                            cause: error,\n                            errorCode: 'WVP-3305',\n                            errorMessage: this.errorCodesService.getMessageForCode('WVP-3305')\n                        });\n                        // Reset locationService cache in the hopes that the failure was due to a network change\n                        this.locationService.resetCache();\n\n                        // Retry in 20 seconds\n                        this.retryPromise = this.$timeout(() => {\n                            this.playSelectedChannel();\n                            this.retryPromise = undefined;\n                        }, 20000);\n                    } else if (error.title && error.message) {\n                        this.playerService.showErrorAlert(error, this.selectedChannel.asset);\n                    }\n                }\n\n                scrollToChannel(channel) {\n                    // Timeout needed to ensure channel dom nodes have been rendered\n                    return this.$timeout(() => {\n                        const index = this.filteredChannels.indexOf(channel);\n                        if (index < 0) {\n                            return;\n                        }\n\n                        const container = this.$element.find('#channel-browser');\n                        const channelHeight = this.$element.find('.channel-list-item').outerHeight();\n                        const channelsPerViewport = container.height() / channelHeight;\n                        const scrollOffset = channelHeight * (index - Math.floor(channelsPerViewport / 2));\n\n                        container.scrollTop(scrollOffset);\n                    }, 0);\n                }\n\n\n                focusChannel(channel, doNotScroll = false) {\n                    // Timeout needed to ensure channel dom nodes have been rendered\n                    this.$timeout(() => {\n                        const index = this.filteredChannels.indexOf(channel);\n                        if (index < 0) {\n                            return;\n                        }\n\n                        const id = `#channel-list-item-${channel.localChannelNumber}-${channel.channelId}`;\n                        const el = this.$element.find(id);\n                        if (el.length > 0) {\n                            el.focus();\n                            this.firstFocusedChannel = channel;\n                        } else if (!doNotScroll) {\n                            // Since we use a virtual repeat, the element only exists if it's in the viewport\n                            this.scrollToChannel(channel)\n                                .then(() => this.focusChannel(channel, true));\n                        }\n                    }, 0);\n                }\n            }\n        });\n})();\n"],"sourceRoot":"/source/"}