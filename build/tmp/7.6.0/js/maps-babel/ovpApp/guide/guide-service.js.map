{"version":3,"sources":["ovpApp/guide/guide-service.js"],"names":[],"mappings":"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","file":"ovpApp/guide/guide-service.js","sourcesContent":["(function () {\n    'use strict';\n\n    angular.module('ovpApp.guide')\n        .constant('guideIpOnlyEpg', {\n            WINDOW_HOURS: 4 // EPG V2 service is fixed window sizes\n        })\n        .service('GuideService', GuideService);\n\n    /* @ngInject */\n    function GuideService($http, config, $rootScope, $log, stbService, $q, epgsService,\n        profileService, guideIpOnlyEpg, $timeout, alert, errorCodesService) {\n        var service = this,\n            loadPromise,\n            earliest,\n            latest,\n            displayEarliest,\n            zeroHour,\n            filters;\n\n        service.fetchChannelList = fetchChannelList;\n        service.fetchChannels = fetchChannels;\n        service.getZeroHour = getZeroHour;\n        service.filterChannel = filterChannel;\n        service.clearProgramData = clearProgramData;\n        service.setZeroTime = setZeroTime;\n\n        activate();\n\n        return service;\n\n        function activate() {\n            setZeroTime();\n            $rootScope.$on('guide:updateFilter', function (event, updatedFilters) {\n                filters = updatedFilters;\n            });\n        }\n\n        function setZeroTime() {\n            zeroHour = new Date();\n            let currentTimeMillis = zeroHour.getTime();\n            zeroHour.setMinutes(0);\n            zeroHour.setSeconds(0);\n            zeroHour.setMilliseconds(0);\n            service.zeroTime = Math.floor(zeroHour.getTime() / 1000);\n            let resetTimeout = (zeroHour.getTime() + 3600000) - currentTimeMillis;\n            service.endTime = service.zeroTime + (14 * 24 * 3600);\n            displayEarliest = service.zeroTime;\n            getTimeBounds();\n\n            $timeout(setZeroTime, resetTimeout);\n        }\n\n        /**\n         * Fetch the channel list, this is required before we can fetch any other info.\n         * @return {Promise}\n         */\n        function fetchChannelList() {\n            loadPromise = epgsService.getChannels()\n                .then(channels => {\n                    if (profileService.isSpecU()) {\n                        channels.sort((a, b) => a.networkName > b.networkName ? 1 : -1);\n                    }\n                    // STVWEB-1868: Display Subscribed Only (Video/Internet Only) - Guide\n                    if (profileService.isIpOnlyEnabled()) {\n                        channels = channels.filter(chnl => chnl.subscribed !== false);\n                    }\n                    service.channels = channels ? channels.map((channel, idx) => {\n                        channel.index = idx;\n                        channel.content = [];\n                        return channel;\n                    }) : [];\n                    return service.channels;\n                });\n            return loadPromise;\n        }\n\n        function fetchChannels(channels, timeStart, timeEnd) {\n            if (!loadPromise) {\n                loadPromise = fetchChannelList();\n            }\n\n            return loadPromise.then(function () {\n                let channelDataPromise = fetchChannelData(channels, timeStart, timeEnd);\n                return channelDataPromise;\n            });\n        }\n\n        function fetchChannelData(channelSlice, begin = 0, end = 2) {\n            //Filter out any channels that we already have this data for\n            channelSlice = channelSlice.filter(channel => !channelHasTime(channel, begin, end));\n\n            return profileService.isIpOnlyEnabled().then((ipOnly) => {\n                if (ipOnly) {\n                    return fetchIpChannelData(channelSlice, begin, end);\n                } else {\n                    end += 1;\n                    return fetchQamChannelData(channelSlice, begin, end);\n                }\n            });\n        }\n\n        function fetchQamChannelData(channelSlice, begin, end) {\n            var requestData;\n            var headend;\n\n            return stbService.getHeadend().then(he => {\n                headend = he.id;\n\n                requestData = {\n                    headend: headend,\n                    hourBegin: begin,\n                    hourEnd: end,\n                    //This seems like bad behavior - this should use something other than the channel index\n                    tmsGuideIds: channelSlice.map(channel => channel.tmsGuideId).join('.')\n                };\n\n                requestData = updateRequestTimeBounds(requestData);\n                channelSlice.forEach(channel => {\n                    channel.loading = true;\n                });\n\n                if (channelSlice.length > 0) {\n                    return $http({\n                        url: config.piHost +\n                        config.smartTvApi +\n                        config.nmdEpgsApiV1 +\n                        config.epgs.guide +\n                        '/' + headend +\n                        config.epgs.grid,\n                        method: 'GET',\n                        params: requestData,\n                        withCredentials: true\n                    }).then(res => {\n                        Object.keys(res.data).forEach((tmsGuideId) => {\n                            let shows = res.data[tmsGuideId];\n                            service.channels.filter(c => {\n                                return c.tmsGuideId == tmsGuideId;\n                            }).forEach(channel => {\n                                let newShows = shows.map(show => enrichShowData(show, channel));\n                                if (channel.staged && channel.staged.length > 0) {\n                                    channel.staged = channel.staged.concat(newShows);\n                                } else {\n                                    channel.staged = newShows;\n                                }\n                                channel.loaded = true;\n                                channel.loading = false;\n                                channelSaveLoadedTime(channel, begin, end);\n                            });\n                            return service.channels;\n                        });\n                    }, function errorCallback() {\n                        alert.open({\n                            message: errorCodesService.getMessageForCode('WGU-1000'),\n                            title: errorCodesService.getHeaderForCode('WGU-1000'),\n                            buttonText: 'OK'\n                        });\n                    });\n                } else {\n                    //Determined that we didn't need to send a request\n                    return $q.resolve();\n                }\n            });\n        }\n\n        function fetchIpChannelData(channelSlice, begin, end) {\n            // Adjust begin to be an hour and day offset\n            let now = new Date();\n            let nowHour = now.getUTCHours();\n            let hourOffset = (nowHour + begin) % 24;\n            let dayOffset = Math.floor((nowHour + begin) / 24);\n            let entitlementIds = channelSlice.map(channel => channel.entitlementId).join(',');\n\n            if (channelSlice.length === 0) {\n                //Determined that we didn't need to send a request\n                return $q.resolve();\n            }\n\n            channelSlice.forEach(channel => {\n                channel.loading = true;\n            });\n\n            // Loop, getting data in guideIpOnlyEpg.WINDOW_HOURS hour chunks which is what the API returns\n            let numChunks = Math.ceil((end - begin) / guideIpOnlyEpg.WINDOW_HOURS);\n            let promises = [];\n            var i;\n            for (i = 0; i < numChunks; i++) {\n                // Create a closure so the async code below understands what chunk itis in.\n                let absStartOffset = begin + (i * guideIpOnlyEpg.WINDOW_HOURS);\n                let absEndOffset = absStartOffset + guideIpOnlyEpg.WINDOW_HOURS;\n\n                promises.push(fetchIpOnlyChunk(entitlementIds, hourOffset, dayOffset, absStartOffset, absEndOffset));\n\n                // Increment to the next guideIpOnlyEpg.WINDOW_HOURS hour chunk\n                dayOffset = dayOffset + Math.floor((hourOffset + guideIpOnlyEpg.WINDOW_HOURS) / 24);\n                hourOffset = (hourOffset + guideIpOnlyEpg.WINDOW_HOURS) % 24;\n            }\n\n            $q.all(promises).then(() => {\n                channelSlice.forEach(channel => {\n                    channel.loaded = true;\n                    channel.loading = false;\n                });\n\n                return service.channels;\n            });\n        }\n\n        function fetchIpOnlyChunk(entitlementIds, hourOffset, dayOffset, absStartOffset, absEndOffset) {\n            let requestData = {\n                hourOffset: hourOffset,\n                dayOffset: dayOffset,\n                entitlementIds: entitlementIds\n            };\n\n            return $http({\n                url:\n                config.piHost +\n                config.smartTvApi +\n                config.epgs.ipOnlyGuide,\n                method: 'GET',\n                params: requestData,\n                withCredentials: true\n            }).then(res => {\n                Object.keys(res.data).forEach((tmsGuideId) => {\n                    let shows = res.data[tmsGuideId];\n                    service.channels.filter(c => {\n                        return c.tmsGuideId == tmsGuideId;\n                    }).forEach(channel => {\n                        let newShows = shows.map(show => enrichShowData(show, channel));\n                        if (channel.staged && channel.staged.length > 0) {\n                            channel.staged = channel.staged.concat(newShows);\n                        } else {\n                            channel.staged = newShows;\n                        }\n                        channelSaveLoadedTime(channel, absStartOffset, absEndOffset);\n                    });\n                });\n                return service.channels;\n            }, function errorCallback() {\n                alert.open({\n                    message: errorCodesService.getMessageForCode('WGU-1000'),\n                    title: errorCodesService.getHeaderForCode('WGU-1000'),\n                    buttonText: 'OK'\n                });\n            });\n        }\n\n        function enrichShowData(show) {\n            var endTime = show.startTimeSec + (show.durationMinutes * 60),\n                classData = {};\n            show.endTimeUtcSeconds = endTime;\n            let nowSec = Math.round(Date.now() / 1000);\n            if ((show.startTimeSec < nowSec) && (nowSec < endTime)) {\n                classData.onnow = true;\n            }\n            classData['duration_' + show.durationMinutes] = true;\n            classData['new'] = (show.icons.indexOf('New') >= 0);\n            classData.series = (show.metadata && show.metadata.tmsSeriesId) ? true : false;\n            classData.rating_block = show.ratingsBlocked;\n            show.classData = classData;\n            show.startTimeOffset = show.startTimeSec - displayEarliest;\n\n            return show;\n\n        }\n\n        //Create a list of unix timestamps for every 30 minutes starting with the current hour\n        function getTimeBounds() {\n            let start = earliest, end = service.endTime;\n\n            let endTime = displayEarliest;\n            let timesSeconds = [displayEarliest]; //Store as seconds,\n            while (endTime < end) {\n                endTime += (30 * 60); //30 min blocks as seconds\n                timesSeconds.push(endTime);\n            }\n            //The actual time bounds (since we are fixing the earliest to 2 hours before, then there isn't much we can\n            //do with this info.\n            latest = service.latest = end;\n            earliest = service.earliest = start;\n            service.times = timesSeconds.map(time => time *= 1000); //End\n            return service.times;\n        }\n\n        function getZeroHour() {\n            return zeroHour;\n        }\n\n        //Since the request is relative to the current time, we may have loaded data that is a few minutes out dated,\n        //and the current start=0 may have advanced by an hour on the server.\n        function updateRequestTimeBounds(requestData) {\n            var current = new Date();\n            let min = current.getMinutes();\n            current.setMinutes(0);\n            current.setMilliseconds(0);\n            if (min > 55) {\n                current.setTime(current.getTime() + (3600 * 1000));\n            }\n            let timeDiff = current.getTime() - zeroHour.getTime();\n            if (timeDiff > (55 * 60 * 1000)) {\n                //If the current time has elapsed to more than 55min past\n                //the beginning of the hour then we want to decriment the begin and end by\n\n                let decAmount = Math.floor(timeDiff / 3600000);\n                requestData.hourBegin -= decAmount;\n                requestData.hourEnd -= decAmount;\n            }\n            return requestData;\n        }\n\n        function filterChannel(channel) {\n\n            if (filters) {\n                let display = true;\n                if (filters.preset && filters.preset.filter) {\n                    if (!filters.preset.filter(channel)) {\n                        display = false;\n                    }\n                }\n\n                if (display && filters.text) {\n                    display = (channel.callSign.indexOf(filters.text.toUpperCase()) >= 0);\n                }\n                channel.display = display;\n            } else {\n                channel.display = false;\n            }\n            return channel.display;\n        }\n\n        /**\n         * Store the times that have already been loaded for the channel - combine times that are contiguious\n         * @param  {channel} channel the channel to look at\n         * @param  {int} start   the start time to add\n         * @param  {int} end     the end time to add\n         */\n        function channelSaveLoadedTime(channel, start, end) {\n            if (!channel.loadedTimes) {\n                channel.loadedTimes = [];\n            }\n            channel.loadedTimes.push([start, end]);\n            channel.loadedTimes = channel.loadedTimes.sort((a, b) => a[0] - b[0])\n                .reduce((memo, timePair) => {\n                    if (memo.length > 0 &&\n                        memo[memo.length - 1][0] <= timePair[0] &&\n                        memo[memo.length - 1][1] >= timePair[0]) {\n                        //The times are overlapping or contiguious, the list is sorted by start, so they must\n                        if (memo[memo.length - 1][1] < timePair[1]) {\n                            memo[memo.length - 1][1] = timePair[1];\n                        }//same or timePair is less time than what is already on the list;\n                    } else {\n                        //Non contiguious, just append it to the end\n                        memo.push(timePair);\n                    }\n                    return memo;\n                }, []);\n        }\n\n        function channelHasTime(channel, start, end) {\n            if (!channel.loadedTimes) {\n                return false;\n            } else {\n                return channel.loadedTimes.some(time => (time[0] < start - 1 && time[1] > end + 1));\n            }\n        }\n\n        function clearProgramData() {\n            service.channels.forEach(channel => {\n                channel.loadedTimes = [];\n            });\n        }\n    }\n})();\n"],"sourceRoot":"/source/"}