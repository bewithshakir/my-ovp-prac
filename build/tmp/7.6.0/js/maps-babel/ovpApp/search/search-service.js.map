{"version":3,"sources":["ovpApp/search/search-service.js"],"names":[],"mappings":"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","file":"ovpApp/search/search-service.js","sourcesContent":["(function () {\n    'use strict';\n    angular.module('ovpApp.search.searchService', [\n        'ovpApp.services.entry',\n        'ovpApp.services.ovpStorage',\n        'ovpApp.config',\n        'ovpApp.services.rxUtils',\n        'rx'\n    ])\n    .factory('searchService', searchService);\n\n    /* @ngInject */\n    function searchService($http, $q, $timeout, $rootScope, config, entryService,\n        ovpStorage, storageKeys, rx, rxhttp) {\n\n        let service = {\n            stripInvalidCharacters,\n            getComponentResults,\n            getSubResultsByUri,\n            getSubResultsByQueryAndCategory,\n            getActorResults,\n            getDirectorResults,\n            getRelatedByTmsProgramId,\n            getRelatedByTmsSeriesId,\n            getRecentSearches,\n            saveRecentSearch,\n            clearRecentSearches,\n            doNotRedirect: false\n        };\n\n        return service;\n\n        ///////////////\n\n        function stripInvalidCharacters(searchString = '') {\n            return searchString\n                .replace(/[^ 0-9a-zA-Z\\-&ÆÐƎƏƐƔĲŊŒẞÞǷȜæðǝəɛɣĳŋœĸſßþƿȝĄƁÇĐƊĘĦĮƘŁØƠŞȘŢȚŦŲƯY̨Ƴąɓçđɗęħįƙłøơşșţțŧųưy̨ƴÁÀÂÄǍĂĀÃÅǺĄÆǼǢƁĆĊĈČÇĎḌĐƊÐÉÈĖÊËĚĔĒĘẸƎƏƐĠĜǦĞĢƔáàâäǎăāãåǻąæǽǣɓćċĉčçďḍđɗðéèėêëěĕēęẹǝəɛġĝǧğģɣĤḤĦIÍÌİÎÏǏĬĪĨĮỊĲĴĶƘĹĻŁĽĿʼNŃN̈ŇÑŅŊÓÒÔÖǑŎŌÕŐỌØǾƠŒĥḥħıíìiîïǐĭīĩįịĳĵķƙĸĺļłľŀŉńn̈ňñņŋóòôöǒŏōõőọøǿơœŔŘŖŚŜŠŞȘṢẞŤŢṬŦÞÚÙÛÜǓŬŪŨŰŮŲỤƯẂẀŴẄǷÝỲŶŸȲỸƳŹŻŽẒŕřŗſśŝšşșṣßťţṭŧþúùûüǔŭūũűůųụưẃẁŵẅƿýỳŷÿȳỹƴźżžẓ]/gi, '') // jshint ignore:line\n                .toLowerCase();\n        }\n\n        function findCategory(data, categoryName) {\n            categoryName = categoryName.toLowerCase();\n            return data.results.find(category => category.title.toLowerCase() == categoryName);\n        }\n\n        function findItem(data, searchString, categoryName) {\n            let categories, match;\n            if (data) {\n                searchString = stripInvalidCharacters(searchString);\n                if (categoryName) {\n                    let cat = findCategory(data, categoryName);\n                    if (cat) {\n                        categories = [cat];\n                    }\n                }\n                if (!categories) {\n                    categories = data.results;\n                }\n\n                categories.forEach(category =>\n                    match = category.results.find(val =>\n                        searchString == stripInvalidCharacters(val.searchStringMatch)));\n            }\n            return match;\n        }\n\n        /**\n         * Executes a search, and returns results separated into different components. For example,\n         * There may be some \"title\" results, some \"person\" results, some \"sports\" results, etc.\n         * @param  {string} searchString\n         * @return {Observable} An observable which will emit the result of the search\n         */\n        function getComponentResults(searchString) {\n            searchString = encodeURIComponent(stripInvalidCharacters(searchString));\n            return rx.Observable.fromPromise(entryService.forDefaultProfile())\n                .flatMap(function (services) {\n                    let url = config.piHost + services.componentSearch.searchString(searchString);\n                    return rxhttp.get(url, {withCredentials: true})\n                        .map(response => {\n\n                            // Analytics: Propagate queryId and resultIndex to each result.\n                            if (angular.isDefined(response.data.results)) {\n                                let resultArrays = response.data.results;\n                                for (var i = 0; i < resultArrays.length; ++i) {\n                                    populateSearchAnalytics(resultArrays[i]);\n                                }\n                            }\n\n                            return response.data;\n                        });\n                });\n        }\n\n\n        /**\n         * Find results underneath a top level search, using the uri found by a previous\n         * top level search. If you have not done a top level search and thus don't\n         * know the uri, use getSubResultsByQueryAndCategory instead.\n         * @param  {string} uri uri to use\n         * @return {observable}\n         */\n        function getSubResultsByUri(uri) {\n            $rootScope.$emit('Analytics:issue-search');\n            return rxhttp.get(config.piHost + uri, {withCredentials: true})\n                .map(response => {\n                    populateSearchAnalytics(response.data);\n                    return response.data;\n                });\n        }\n\n        function getActorResults(personid, tmsid) {\n            return rx.Observable.fromPromise(entryService.forDefaultProfile())\n                .flatMap(function (services) {\n                    let url = config.piHost + services.actor.tmsProviderProgramID_tmsPersonID(tmsid, personid);\n                    return rxhttp.get(url, {withCredentials: true})\n                        .map(response => {\n                            populateSearchAnalytics(response.data);\n                            return response.data;\n                        });\n                });\n        }\n\n        function getDirectorResults(personid, tmsid) {\n            return rx.Observable.fromPromise(entryService.forDefaultProfile())\n                .flatMap(function (services) {\n                    let url = config.piHost + services.director.tmsProviderProgramID_tmsPersonID(tmsid, personid);\n                    return rxhttp.get(url, {withCredentials: true})\n                        .map(response => {\n                            populateSearchAnalytics(response.data);\n                            return response.data;\n                        });\n                });\n        }\n\n        /**\n         * Find results underneath a top level search, but having never actually done the\n         * top level search. If you've done a top level search and thus know the uri for the\n         * subsearch, use getSubResultsByUri() instead.\n         * @param {string} query string to search for\n         * @param {string} (optional) a category in which to look. only results in the specified\n         *         category will be checked. You can omit this if you want, but it is\n         *         possible for there to be matches in multiple categories, and no\n         *         guarantee is provided on which one will be selected.\n         * @return {observable}\n         */\n        function getSubResultsByQueryAndCategory(searchString, category) {\n            return getComponentResults(searchString)\n                .map(data => findItem(data, searchString, category))\n                .flatMap(item => item ? getSubResultsByUri(item.uri) : rx.Observable.just([]));\n        }\n\n        function saveRecentSearch(searchString) {\n            let recentSearches = getRecentSearches();\n            let i = recentSearches.indexOf(searchString),\n                limit = 10; //TODO: limit should come from activityconfig\n            if (i >= 0) {\n                recentSearches.splice(i, 1);\n            }\n            recentSearches.unshift(searchString);\n            if (recentSearches.length > limit) {\n                recentSearches.pop();\n            }\n            ovpStorage.setItem(storageKeys.recentSearches, recentSearches);\n        }\n\n        function getRecentSearches() {\n            return ovpStorage.getItem(storageKeys.recentSearches) || [];\n        }\n\n        function clearRecentSearches() {\n            ovpStorage.setItem(storageKeys.recentSearches, []);\n        }\n\n        function getRelatedByTmsProgramId(tmsProgramId) {\n            if (!tmsProgramId) {\n                return rx.Observable.throw('tmsProgramId is null');\n            } else {\n                return rx.Observable.fromPromise(entryService.forDefaultProfile())\n                    .flatMap(function (services) {\n                        let url = config.piHost + services.similarTo.tmsProviderProgramID(tmsProgramId);\n                        return rxhttp.get(url, {withCredentials: true})\n                            .map(response => response.data);\n                    });\n            }\n        }\n\n        function getRelatedByTmsSeriesId(tmsSeriesId) {\n            if (!tmsSeriesId) {\n                return rx.Observable.throw('tmsSeriesId is null');\n            } else {\n                return rx.Observable.fromPromise(entryService.forDefaultProfile())\n                    .flatMap(function (services) {\n                        let url = config.piHost + services.similarTo.tmsSeriesID(tmsSeriesId);\n                        return rxhttp.get(url, {withCredentials: true})\n                            .map(response => response.data);\n                    });\n            }\n        }\n\n        /**\n         * Given a search response containing an array of results, propagate the\n         * queryId, resultIndex, and searchFacet (\"type of search\") to each result.\n         *\n         * @param result An updateable search result object containing an array\n         *               of results, as well as additional data relevant to this\n         *               search.\n         */\n        function populateSearchAnalytics(result) {\n            // Do nothing if we're missing required fields.\n            if (!angular.isDefined(result.results) || !Array.isArray(result.results)) {\n                return;\n            }\n\n            let searchFacet = (result.title ? result.title.toLowerCase() : '');\n\n            for (var i = 0; i < result.results.length; ++i) {\n                result.results[i].dsQueryId = result.dsQueryId;\n                result.results[i].searchResultIndex = i;\n                result.results[i].searchFacet = searchFacet;\n            }\n        }\n\n    } // end search service function\n}()); // end IIFE\n"],"sourceRoot":"/source/"}