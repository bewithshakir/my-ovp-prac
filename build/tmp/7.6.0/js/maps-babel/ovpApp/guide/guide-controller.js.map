{"version":3,"sources":["ovpApp/guide/guide-controller.js"],"names":[],"mappings":"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","file":"ovpApp/guide/guide-controller.js","sourcesContent":["(function () {\n    'use strict';\n\n    angular.module('ovpApp.guide')\n        .controller('GuideController', GuideController);\n\n    /* @ngInject */\n    function GuideController($scope, $state, $http, config, $rootScope, $log, GuideService, favoritesService,\n        $q, rdvrService, ChannelService, channelList, favorites, alert, messages, $filter, profileService,\n        loadingDefer, stbService, $timeout) {\n        var vm = this,\n            zoneLoadQueue = [[0,0],[0,1],[1,0],[1,1]],\n            dateFilter = $filter('date');\n\n        vm.displayHours = 14 * 24; //Total number of hours to display - this should come from the STB though.\n        vm.times = [];\n        vm.channels = channelList;\n        vm.favorites = favorites || [];\n        vm.recentChannels = [];\n        vm.recordings = [];\n        vm.getShowData = getShowData;\n        vm.toggleFavorite = toggleFavorite;\n        vm.fetchPromise = null;\n        vm.focusChannel = null;\n        vm.focusShow = null;\n        vm.focusTime = null;\n        vm.move = move;\n        vm.keypress = keypress;\n        vm.gridFocused = gridFocused;\n        vm.setFocus = setFocus;\n        vm.$state = $state;\n\n        /*\n            A zone is a single window. This is used to help load the page by thinking of it as a large grid of zones.\n            We ensure that we only load each zone once and on time.\n         */\n        vm.zoneData = [];\n        vm.channelsPerZone = -1;\n        vm.hoursPerZone = -1;\n\n        activate();\n\n        function activate() {\n            //guide:currentZone gets sent by : GSCD->fetchZoneData (called by scroll handler)\n            //displayZone is sent by GSCD to go 'down' to the rows (not listened to here, essentially the same event)\n            $scope.$on('guide:currentZone', fetchZone);\n            $scope.$on('update-dvr', function () {\n                //Only use the update-dvr if we are using CDVR\n                profileService.isCdvrEnabled().then(isEnabled => {\n                    if (isEnabled) {\n                        GuideService.clearProgramData();\n                        // updateGrid();\n                        $scope.$broadcast('guide:invalidateData');\n                    }\n                });\n            });\n\n            $scope.$on('guide:reactivate', () => {\n                // timeout is needed to correctly set blue colored focus on the Dom element.\n                $timeout(() => {\n                    setFocus(vm.focusZone, vm.focusChannel, vm.focusShow);\n                }, 0);\n            });\n\n            $scope.$on('set-top-box-selected', updateRecordings);\n            $scope.$on('guide:updateFilter', updateGrid);\n\n            $scope.$on('guide:channelSearch', function (e, channelNumber) {\n                if (profileService.isSpecU() || vm.channels.every(c => c.channelNumber === undefined)) {\n                    // No searching by channel when there are no channel numbers (ie, SpecU)\n                    return;\n                }\n                let closest = vm.channels.reduce((candidate, channel) => {\n                    if (channel.globalIndex !== null &&\n                        (!candidate.channel || Math.abs(channel.channelNumber - channelNumber) < candidate.dist)) {\n                        candidate.channel = channel;\n                        candidate.dist = Math.abs(channel.channelNumber - channelNumber);\n                    }\n                    return candidate;\n                }, {\n                    dist: null,\n                    channel: null\n                }).channel;\n                $scope.setChannelPos(closest.globalIndex);\n                setFocus(closest.zone, closest);\n            });\n            //Wait for zonesize before we trigger the first fetch\n            $scope.$on('guide:zonesize', function (event, channelsPerZone, hoursPerZone) {\n                vm.channelsPerZone = channelsPerZone;\n                vm.hoursPerZone = hoursPerZone;\n                updateGrid(vm.channels);\n            });\n\n            $scope.$on('guide:timejump', clearSelection);\n            enrichChannelData();\n            updateRecordings();\n\n            $scope.$watch(() => GuideService.times, (nv) => {\n                vm.times = nv.map((epoch,idx) => {\n                    return {\n                        time: dateFilter(epoch, 'shortTime'),\n                        index: idx,\n                        epoch: epoch\n                    };\n                });\n            });\n\n            // Analytics\n            $rootScope.$emit('Analytics:channel-info', {\n                channels: vm.channels\n            });\n        }\n\n        function clearSelection() {\n            vm.focusZone = null;\n            vm.focusChannel = null;\n            vm.focusShow = null;\n            vm.focusTime = null;\n        }\n\n        /**\n         * When the screen size changes, update the grid to ensure the zone is appropriatly sized.\n         */\n        function updateGrid() {\n            initZones();\n            //Updates the display variable on each channel\n            let saveTime = vm.focusTime;\n            clearSelection();\n            vm.focusTime = saveTime;\n            //Updates GuideScrollContainer -> create zone html elements, forceFetchCurrent zone\n            $scope.$broadcast('guide:updateZones');\n        }\n\n        /**\n         * Update the recordings asyncrounously so we can append that data to the current display when available.\n         * @return {[type]} [description]\n         */\n        function updateRecordings() {\n            profileService.isRdvrEnabled()\n                .then(rdvrEnabled => {\n                    vm.recordings = [];\n\n                    if (rdvrEnabled) {\n                        stbService.getCurrentStb()\n                            .then(stb => {\n                                const stbChanged = stbService.currentStbSource.skip(1);\n                                rdvrService.getScheduledRecordings(stb)\n                                    .takeUntil(stbChanged)\n                                    .subscribe(\n                                        result => {\n                                            updateLoadingIndicator(result);\n                                            applyRecordings(result);\n                                        }\n                                    );\n                            });\n                    }\n                });\n        }\n\n        function updateLoadingIndicator({data, isComplete, error}) {\n            if (error) {\n                if (vm.rdvrDefer) {\n                    vm.rdvrDefer.resolve();\n                    vm.rdvrDefer = undefined;\n                }\n            } else if (data.length === 0 && !isComplete) {\n                //Start of fetch\n                if (vm.rdvrDefer) {\n                    vm.rdvrDefer.reject();\n                }\n\n                vm.rdvrDefer = $q.defer();\n                vm.rdvrPromise = vm.rdvrDefer.promise;\n            } else if (isComplete) {\n                // Data is fully loaded\n                if (vm.rdvrDefer) {\n                    vm.rdvrDefer.resolve();\n                    vm.rdvrDefer = undefined;\n                }\n            }\n        }\n\n        /**\n         * Append the subscribed and favorite data to the channel list once for filtering the the channels.\n         * @return {[type]} [description]\n         */\n        function enrichChannelData() {\n            vm.channels.forEach(channel => {\n                // If there is a channel that is marked as a QAM favorite and has the same channel number\n                // in the IP lineup, but does not represent the same channel (ncsServiceId or mystroServiceId)\n                // We could potentially mark this as a favorite and entitled when it is not.\n                // Or if the channel is IP only and doesn't have a channel number there might not be a channel\n                // object to operate on.\n                ChannelService.getChannelByChannelNumber(channel.channelNumber).then(bc => {\n                    if (bc && !bc.entitled) {\n                        channel.subscribed = false;\n                    } else {\n                        channel.subscribed = true;\n                    }\n                });\n                if (favoritesService.isFavorite(channel)) {\n                    channel.favorite = true;\n                } else {\n                    channel.favorite = false;\n                }\n            });\n        }\n\n        /**\n         * Calculate all the zones on the page based on the current size of the guide\n         * viewport.\n         * @return {Array} zoneData, the array containing all the channels subdivided into 'zones'\n         */\n        function initZones() {\n            // update the favorites on init\n            enrichChannelData();\n            let channels = vm.channels;\n\n            let channelZones = Math.ceil(channels.length / vm.channelsPerZone);\n            let timeZones = Math.ceil(vm.displayHours / vm.hoursPerZone) + 1;\n            vm.zoneData = [];\n            let lastChannelIndex = 0;\n            let globalIndex = 0;\n            for (let i = 0; i < channelZones; i++) {\n                let channelZone = {\n                    zoneIndex: i,\n                    timeZones: []\n                };\n                let zoneChannels = [];\n                let channelIndex = lastChannelIndex;\n                while ((channelIndex < vm.channels.length) && (zoneChannels.length < vm.channelsPerZone)) {\n                    let currentChannel = vm.channels[channelIndex];\n                    if (GuideService.filterChannel(currentChannel)) {\n                        zoneChannels.push(currentChannel);\n                        currentChannel.globalIndex = globalIndex;\n                        currentChannel.zoneIndex = i;\n                        globalIndex++;\n                    } else {\n                        currentChannel.globalIndex = null;\n                        currentChannel.zoneIndex = null;\n                    }\n                    channelIndex++;\n                }\n                lastChannelIndex = channelIndex;\n                channelZone.zoneChannels = zoneChannels;\n\n                for (let j = 0; j <  timeZones; j++) {\n                    let start = j * vm.hoursPerZone;\n                    channelZone.timeZones.push({\n                        startTime: start,\n                        startSecondsOffset: start * 3600,\n                        endTime: start + vm.hoursPerZone,\n                        endSecondsOffset: (start + vm.hoursPerZone) * 3600,\n                        timeZoneIndex: j\n                    });\n                }\n\n                vm.zoneData.push(channelZone);\n\n            }\n            return vm.zoneData;\n        }\n\n        /**\n         * Fetch all the data for the given zone and apply to the vm.zoneData variable.\n         * @param  {Event} event Angular Event\n         * @param  {Array} zones Array of zones\n         * @return {Promise|undefined}\n         */\n        function fetchZone(event, zones) {\n            if (zones) {\n                vm.lastFetchedZones = zones;\n            }\n            if (vm.zoneData.length > 0) {\n                let combinedZones = combineZones(zones);\n                if (combinedZones.channels.length > 0) {\n                    let fetchPromise = GuideService.fetchChannels(\n                            combinedZones.channels,\n                            combinedZones.startTime,\n                            combinedZones.endTime);\n\n                    fetchPromise.then((results) => {\n                        if (loadingDefer && loadingDefer.promise.$$state.pending) {\n                            $rootScope.$broadcast('pageChangeComplete', $state.current);\n                            loadingDefer.resolve();\n                        }\n                        checkForRecordings();\n                        return results;\n                    }, (err) => {\n                        if (loadingDefer && loadingDefer.promise.$$state.pending) {\n                            loadingDefer.resolve();\n                        }\n                        $log.warn('Error fetching channel data', err);\n                    });\n\n                    vm.fetchPromise = fetchPromise;\n                    return vm.fetchPromise;\n                }\n            } else {\n                zoneLoadQueue = zoneLoadQueue.concat(zones);\n            }\n        }\n\n        function getShowData(show, channel) {\n            vm.recentChannels.push(channel);\n        }\n\n        function toggleFavorite(channel) {\n            channel.favorite = !channel.favorite;\n            favoritesService.toggleFavorite(channel);\n        }\n\n        /**\n         * When the recordings have been returned from the dvr service, append them to each channel based on the\n         * mystroServiceId so we can later apply them to the recordings\n         */\n        function applyRecordings({data, isComplete}) {\n            vm.recordings = data;\n\n            if (data.length === 0 && !isComplete) {\n                //Starting to fetch\n                vm.channels.forEach(ch => ch.recordings = {});\n                $scope.$broadcast('guide:clearRecordings');\n            } else {\n                vm.recordings.forEach((recording) => {\n                    vm.channels\n                        .filter(ch => ch.mystroServiceId === recording.mystroServiceId)\n                        .forEach(channel => {\n                            if (!channel.recordings) {\n                                channel.recordings = {};\n                            }\n                            channel.recordings[recording.tmsProgramId] = recording;\n                        });\n                });\n                $scope.$broadcast('guide:updateRecordings');\n            }\n        }\n\n        /**\n         * All recordings are stored at the channel level before they are applied to each show. We should have\n         * the channel when the recordings return\n         */\n        function checkForRecordings() {\n            vm.channels.forEach((channel) => {\n                if (channel.content) {\n                    channel.content.forEach(show => {\n                        if (channel.recordings && channel.recordings[show.tmsProgramId]) {\n                            show.recording = channel.recordings[show.tmsProgramId];\n                        }\n                    });\n                }\n            });\n\n\n        }\n\n        /**\n         * This takes all the zones and combines the data into a format that we can use to call the service with so that\n         * we are not making more service calls than neccessary.\n         * @param  {Array} zones The zones list that we need to fetch.\n         * @return {Object}      An object containing the channels and the time zones we want from the server\n         */\n        function combineZones(zones) {\n            let combinedZones = zones.reduce((memo, zone) => {\n                let timeZoneIndex = zone[0];\n                let channelZone = zone[1];\n                if (vm.zoneData[channelZone]) {\n                    let tz = vm.zoneData[channelZone].timeZones[timeZoneIndex];\n                    memo.channels = memo.channels.concat(vm.zoneData[channelZone].zoneChannels);\n                    if (memo.startTime === null || tz.startTime < memo.startTime) {\n                        memo.startTime = tz.startTime;\n                    }\n                    if (memo.endTime === null || tz.endTime > memo.endTime) {\n                        memo.endTime = tz.endTime;\n                    }\n                }\n                return memo;\n            }, {\n                channels: [],\n                startTime: null,\n                endTime: null\n            });\n            combinedZones.channels = combinedZones.channels.reduce((channels, channel) => {\n                if (channels.indexOf(channel) < 0) {\n                    channels.push(channel);\n                }\n                return channels;\n            }, []);\n            return combinedZones;\n        }\n\n        function keypress($event) {\n\n            switch ($event.keyCode) {\n                case 38: move($event, 'up'); break;\n                case 39: move($event, 'right'); break;\n                case 40: move($event, 'down'); break;\n                case 37: move($event, 'left'); break;\n                case 9: //Tab key\n                    if ($event.shiftKey) {\n                        angular.element('.channel-header-row[channel-index=\"' +\n                            vm.focusChannel.globalIndex +\n                            '\"]').focus();\n                        $event.preventDefault();\n                    }\n                    break;\n            }\n        }\n\n\n        function setFocus(zone, channel, show = null, time = null, updateTime = true) {\n            var focusPromise = null;\n            vm.focusZone = zone;\n            vm.focusChannel = channel;\n            if (channel && !zone) {\n                vm.focusZone = vm.zoneData[channel.zoneIndex];\n            }\n\n            if (vm.focusChannel && vm.focusChannel.focusIn) {\n                if (!show || show === null) {\n                    let findAtTime = time || vm.focusTime;\n                    focusPromise = vm.focusChannel.focusIn(findAtTime, null);\n                } else {\n                    vm.focusShow = show;\n                    focusPromise = vm.focusChannel.focusIn(null, show);\n                }\n            } else {\n                $log.error('Channel does not have the focusIn function set', vm.focusChannel);\n            }\n\n            if (focusPromise) {\n                focusPromise.then(focusedShow => {\n                    if (focusedShow) {\n                        vm.focusShow = focusedShow;\n                        if (updateTime) {\n                            if (focusedShow.startTimeOffset >= 0) {\n                                vm.focusTime = focusedShow.startTimeOffset;\n                            } else {\n                                vm.focusTime = 0;\n                            }\n                        }\n                    }\n                }, (err) => {\n                    $log.error('Unable to set focus, dom element is missing', err);\n                    let idx = vm.focusZone.channels.indexOf(vm.focusChannel);\n                    if (idx >= 0 && vm.focusZone.channels[idx + 1]) {\n                        return setFocus(vm.focusZone, vm.focusZone.channels[idx + 1], null, time, updateTime);\n                    } else {\n                        vm.focusZone = null;\n                        vm.focusChannel = null;\n                        gridFocused();\n                    }\n                });\n            }\n\n        }\n\n        function move(e, direction) {\n            if (!vm.focusChannel || !vm.focusZone || !vm.focusShow) {\n                return gridFocused(e);\n            } else {\n                let focusChannelIdx;\n                let focusZoneIdx;\n                let focusTime = vm.focusTime || 0;\n\n                if (direction == 'up' || direction == 'down') {\n                    focusChannelIdx = vm.focusZone.zoneChannels.indexOf(vm.focusChannel);\n                    focusZoneIdx = vm.focusZone.zoneIndex;\n                    if (direction == 'down') {\n                        if (vm.focusZone.zoneChannels[focusChannelIdx + 1]) {\n                            focusChannelIdx++;\n                        } else if (vm.zoneData[focusZoneIdx + 1] &&\n                            vm.zoneData[focusZoneIdx + 1].zoneChannels.length > 0) {\n                            focusChannelIdx = 0;\n                            focusZoneIdx++;\n                        } //else - at the bottom, do nothing\n                    } else {\n                        if (vm.focusZone.zoneChannels[focusChannelIdx - 1]) {\n                            focusChannelIdx--;\n                        } else if (vm.zoneData[focusZoneIdx - 1] &&\n                            vm.zoneData[focusZoneIdx - 1].zoneChannels.length > 0) {\n                            focusZoneIdx--;\n                            focusChannelIdx = vm.zoneData[focusZoneIdx].zoneChannels.length - 1;\n                        } //else - at the top, do nothing\n                    }\n                } else {\n                    //right or left\n                    focusChannelIdx = vm.focusZone.zoneChannels.indexOf(vm.focusChannel);\n                    focusZoneIdx = vm.focusZone.zoneIndex;\n                    if (direction === 'right') {\n                        focusTime = vm.focusShow.startTimeOffset + vm.focusShow.durationMinutes * 60 + 300;\n                    } else {\n                        focusTime = vm.focusShow.startTimeOffset - 300; //5min\n                    }\n                }\n                if (vm.zoneData[focusZoneIdx] && vm.zoneData[focusZoneIdx].zoneChannels[focusChannelIdx]) {\n                    let zone = vm.zoneData[focusZoneIdx];\n                    let channel = zone.zoneChannels[focusChannelIdx];\n                    setFocus(zone, channel, null, focusTime, (direction === 'right' || direction === 'left'));\n                    e.preventDefault();\n                } else {\n                    $log.warn('Zone or Channel index out of range',\n                        vm.zoneData[focusZoneIdx],\n                        vm.zoneData[focusZoneIdx].zoneChannels[focusChannelIdx]);\n                }\n            }\n        }\n\n        /**\n         * When focusing the grid, this will determine the upper left most cell and set the focus at that time if\n         * the event type is actually a focus event\n         * @return {undefined}\n         */\n        function gridFocused(event) {\n            //Figure out the event type and if\n            if (event.type === 'focus' && (!vm.focusZone || !vm.focusChannel)) {\n                let {channelIndex, hour, scroll} = $scope.getPos();\n                let channel = vm.channels.find(channel => channel.globalIndex === channelIndex);\n                let time = hour * 3600;\n                setFocus(vm.zoneData[channel.zoneIndex], channel, null, time);\n                $scope.setPos(scroll);\n            } else {\n                setFocus(vm.focusZone, vm.focusChannel, vm.focusShow);\n            }\n        }\n\n    }\n\n})();\n"],"sourceRoot":"/source/"}