{"version":3,"sources":["ovpApp/oauth/oauth-service.js"],"names":[],"mappings":"AAAA;;AAAA,CAAC,YAAY;IACT;;;;;;;IAMA,QAAQ,OAAO,gBACV,SAAS,gBAAgB;;;;;;IAM9B,SAAS,gBAAgB;QACrB,IAAI,WAAW;;QAEf,OAAO;YACH,oBAAM,SAAA,KAAU,WAAW;gBACvB,IAAI,CAAC,UAAU;oBACX,WAAW,UAAU,YAAY;;gBAErC,OAAO;;;YAGX,YAAY,SAAA,aAAY;gBACpB,OAAO;;;;;;;IAOnB,SAAS,aAAa,IAAI,OAAO,MAAM,UAAU,UAAU,kBAAkB,aAAa,UAAU,QAChG,aAAa,UAAU,YAAY,aAAa,WAAW,mBAAmB,gBAC9E,YAAY,aAAa,SAAS,WAAW,mBAAmB;QAChE,IAAM,UAAU;;QAEhB,IAAI,mBAAmB;YACnB,iBAAiB;YACjB,cAAc;YACd,kBAAkB;YAClB,qBAAqB;YACrB,iBAAiB;YACjB,kBAAkB;YAClB,kBAAkB;YAClB,gBAAgB;YAChB,cAAc;YACd,aAAa;YACb,2BAA2B;;QAC3B,qBAAqB,YAAY;YACjC,uCAAwC,OAAO,wCAAwC;;;QAG3F,sBAAsB,KAAK,MAAM,KAAK,WAAW,MAAM;;QAEvD,QAAQ,cAAc;QACtB,QAAQ,YAAY;QACpB,QAAQ,iBAAiB;QACzB,QAAQ,kBAAkB;QAC1B,QAAQ,gBAAgB;QACxB,QAAQ,SAAS;QACjB,QAAQ,QAAQ;QAChB,QAAQ,eAAe;QACvB,QAAQ,0BAA0B;QAClC,QAAQ,qBAAqB;QAC7B,QAAQ,yBAAyB;;;QAGjC,WAAW,WAAW,YAAY;;QAElC;;;;;;;;;;;;QAYA,SAAS,kBAA+B;YACpC,IADqB,QAAK,UAAA,UAAA,KAAA,UAAA,OAAA,YAAG,QAAK,UAAA;;YAClC,OAAO,YAAY,OAAO,KAAK,YAAM;gBACjC,WAAW,WAAW,YAAY;gBAClC,cAAc;gBACd,OAAO,GAAG,QAAQ;eACnB,YAAc;gBAGb,IAHA,MAAG,UAAA,UAAA,KAAA,UAAA,OAAA,YAAG,KAAE,UAAA;;gBACR,iBAAiB;gBACjB,cAAc;gBACd,OAAO,GAAG,QAAQ;;;;;;;;QAQ1B,SAAS,mBAAmB;YACxB,OAAO,OAAO,cAAe,UAAU,SAAS,oBAAoB;;;;;;;QAOxE,SAAS,0BAA0B;YAC/B,OAAO,OAAO,qBAAqB,QAAQ,UAAU;;;;;;;;QAQzD,SAAS,qBAAqB;YAC1B,OAAO,UAAU,SAAS;;;;;;QAM9B,SAAS,sCAAsC,iBAAiB,MAAM;YAClE,IAAI,2BAA2B;gBAC3B,iBAAiB;gBACjB,IAAI,YAAY,iBAAiB;oBAC7B,WAAW;oBACP,kBAAkB,UAAU;oBAC5B,oBAAoB,UAAU;oBAC9B,yBAAyB;oBACzB,aAAa,KAAK;;;gBAG1B,OAAO,MAAM;oBACT,eAAe;oBACf,kBAAkB;oBAClB,MAAM;oBACN,SAAS,EAAC,gBAAgB;oBAC1B,kBAAkB,SAAA,iBAAU,KAAK;wBAC7B,OAAO,OAAO,KAAK,KACd,IAAI,UAAA,KAAG;4BAIR,OAJY,mBAAmB,OAAO,MAAM,mBAAmB,IAAI;2BAClE,KAAK;;oBAEd,QAAQ;oBACR,KAAK,YAAY;mBAEpB,KAAK,UAAU,UAAU;oBACtB,IAAI,eAAe,yBAAyB;oBAC5C,OAAO,SAAS,aAAa,UAAU;;mBAExC;gBACH,OAAO,GAAG,OAAO;;;;QAIzB,SAAS,gBAAgB;YACrB,OAAO;;;;QAIX,SAAS,wBAAwB;YAC7B,IAAI,sBAAsB,WAAW,QAAQ,YAAY;YACzD,OAAO,uBACD,KAAK,QAAQ,sBAAuB;;;;;;QAM9C,SAAS,yBAAyB;YAC9B,OAAO,kBACF,KAAK,UAAA,eAAiB;gBACnB,IAAI,CAAC,eAAe;oBAChB,IAAI,CAAC,YAAY;wBACb,aAAa,GAAG;;oBAEpB,OAAO,WAAW;;;;;;;;;;QAUlC,SAAS,cAA2B;YAEhC,IAFiB,QAAK,UAAA,UAAA,KAAA,UAAA,OAAA,YAAG,QAAK,UAAA;;YAC9B,IAAI,YAAY,iBAAiB;;;YAGjC,IAAI,CAAC,oBAAoB,CAAC,mBAAmB,CAAC,UAAU,UAAU,YAAY,6BAC1E,CAAC,iBAAiB;;;gBAGlB,WAAW,MAAM,wBAAwB;oBACrC,UAAU;;gBAEd,WAAW,MAAM,uBAAuB;oBACpC,OAAO,iBAAiB;oBACxB,SAAS;;;gBAGb,kBAAkB;;;;;YAKtB,IAAI,CAAC,sBAAsB,CAAC,UAAU,UAAU,YAAY,6BAA6B,CAAC,OAAO;gBAC7F,OAAO,eAAe,uBAAuB,GAAG,YAAY,eAAe;mBACxE,IAAI,CAAC,kBAAkB,OAAO;gBACjC,OAAO;mBACJ;;gBAEH,OAAO,GAAG,OAAO,eAAe;;;;;;;;;;;QAWxC,SAAS,UAAU,UAAU,UAAU;;;YAGnC,WAAW,MAAM,wBAAwB;gBACrC,UAAU;gBACV,UAAU;;;YAGd,OAAO,oBAAoB,KAAK,UAAC,MAAS;gBACtC,OAAO,cAAc,UAAU,UAAU,MAAM,KAAK,UAAC,UAAa;oBAC9D,mBAAmB;oBACnB,OAAO,SAAS,UAAU;mBAC3B,UAAU,KAAK;;;oBAGd,WAAW,MAAM,uBAAuB;wBACpC,UAAU,8BAA8B;wBACxC,SAAS;;oBAEb,OAAO,GAAG,OAAO,8BAA8B;;eAEpD,KAAK,UAAU,OAAO;;gBAErB,mBAAmB;gBACnB,IAAI,YAAY;oBACZ,WAAW;oBACX,aAAa;;gBAEjB,WAAW,WAAW;gBACtB,OAAO;;;;;;;;;QASf,SAAS,eAAe;YACpB,IAAI,CAAC,oBAAoB;gBACrB,qBAAqB,WAAU,SAAO,UAAC,UAAa;oBAChD,OAAO,oBAAoB,KAAK,UAAC,WAAc;wBAC3C,OAAO,+BAA+B,WAAU,SAAO,UAAC,WAAc;4BAClE,OAAO,qBAAqB,WAAU,SAAO,UAAC,KAAQ;;;gCAGlD,IAAI,2BAA2B;oCAC3B,OAAO,sCAAsC,sBAAsB,WAClE,KAAK,UAAC,WAAc;wCACjB,UAAU,OAAO;wCACjB,OAAO;uCACR,UAAC,KAAQ;wCACR,UAAU,OAAO;wCACjB,OAAO,GAAG,OAAO;;uCAElB,IAAI,eAAe,qBAAqB;oCAC3C,OAAO,6BAA6B;uCACjC;oCACH,KAAK,MAAK,+CAA8C,WAAQ,iDAC1D,aAAc,UAAU,YAAa,UAAU,YAAY;oCACjE,OAAO,GAAG,OAAO;;;;;mBAKlC,KAAK,YAAM;;oBAEV,mBAAmB;oBACnB,qBAAqB;oBACrB,iBAAiB;;oBAEjB,OAAO,eAAe,uBAAuB,GAAG,YAAY,eAAe;mBAC5E,YAAc;oBACb,IADA,MAAG,UAAA,UAAA,KAAA,UAAA,OAAA,YAAG,KAAE,UAAA;;;;oBAGR,qBAAqB;oBACrB,mBAAmB;;;;oBAInB,IAAI,kBAAkB,UAAU,IAAI;oBACpC,IAAI,mBAAmB,gBAAgB,YAAY;;;wBAG/C,iBAAiB;wBACjB,iBAAiB;wBACjB,OAAO,GAAG,OAAO;2BACd;;;wBAGH,OAAO,GAAG;;;;YAItB,OAAO;;;QAGX,SAAS,+BAA+B,WAAW;YAC/C,IAAI,iBAAiB,iBAAiB,MAAM;YAC5C,IAAI,gBAAgB;;;gBAGhB,WAAW,MAAM,wBAAwB;oBACrC,UAAU;;;gBAGd,OAAO,gBAAgB,gBAAgB,WAAW,KAAK,UAAC,UAAa;oBACjE,OAAO,SAAS,UAAU;mBAC3B,KAAK,YAAY;;;;oBAIhB,WAAW,MAAM,uBAAuB;wBACpC,OAAO,iBAAiB;wBACxB,SAAS;;mBAEd,UAAU,KAAK;;;;oBAId,WAAW,MAAM,uBAAuB;wBACpC,UAAU;wBACV,SAAS;;oBAEb,OAAO,GAAG,OAAO;;mBAElB;gBACH,OAAO,GAAG;;;;QAIlB,SAAS,qBAAqB,MAAM;YAChC,IAAI,gBAAgB;YACpB,IAAI,iBAAiB,yBAAyB;gBAC1C,OAAO,GAAG,OAAO;mBACd,IAAI,eAAe;gBACtB,IAAM,WAAW,QAAQ,UAAU,UAAU,MAAM;gBACnD,IAAI,CAAC,UAAU;oBACX,OAAO,cAAc,MAAM,KAAK,UAAC,UAAa;wBAC1C,OAAO,SAAS,UAAU;;uBAE3B;oBACH,OAAO,GAAG,OAAO;;mBAElB;gBACH,OAAO,GAAG,OAAO;;;;QAIzB,SAAS,6BAA6B,WAAW;;YAE7C,IAAI,CAAC,iBAAiB;gBAClB,WAAW,MAAM,wBAAwB;oBACrC,UAAU;;gBAEd,kBAAkB;;;YAGtB,OAAO,cAAc,WAAW,KAAK,UAAC,UAAa;gBAC/C,OAAO,SAAS,UAAU;eAC3B,KAAK,YAAY;;;;;;gBAMhB,IAAI,eAAe,oBAAoB;oBACnC,OAAO,0BACH,GAAG,OAAO;wBACN,SAAS,eAAe;wBACxB,WAAW,eAAe;wBAC1B,mBAAmB;yBAClB,GAAG;uBACT;;;oBAGH,OAAO,eAAe,SAAS,MAAM,KAAK,YAAM;;wBAE5C,OAAO,eAAe,gBAAgB,KAAK,UAAC,UAAa;4BACrD,OAAO,eAAe,cAAc,KAAK,YAAM;;gCAC3C,IAAI,CAAC,UAAU;oCACX,OAAO,GAAG,OAAO;;+BAEvB,SAAO,UAAA,KAAO;;gCACZ,IAAI,QAAQ,eAAe;oCACvB,MAAM;uCACH;oCACH,OAAO;;;2BAGhB,KAAK,YAAM;4BACV,IAAI,yBAAyB;;gCAEzB,iBAAiB;;gCAEjB,WAAW,MAAM,yBAAyB;oCACtC,eAAe;;gCAEnB,OAAO,GAAG,OAAO;oCACb,cAAc;oCACd,mBAAmB;;;;;;eAMxC,UAAU,KAAK;;;gBAGd,WAAW,MAAM,uBAAuB;oBACpC,UAAU;oBACV,SAAS;;;;gBAIb,KAAK,MAAM;gBACX,OAAO,GAAG,OAAO;;;;;;;;;;;QAWzB,SAAS,SAAS,UAAU,MAAM;YAC9B,IAAI,YAAY,iBAAiB;gBAC7B,aAAa,UAAU;gBACvB,cAAc,KAAK;gBACnB,cAAc;gBACd,cAAc;gBACV,eAAe;gBACf,aAAa;gBACb,QAAQ;gBACR,KAAK,YAAY;;;;YAIzB,IAAI,CAAC,gBAAgB;gBACjB,IAAI,UAAU;oBACV,YAAY,eAAe;uBACxB,IAAI,cAAc,YAAY;oBACjC,YAAY,mBAAmB,UAAU;uBACtC;oBACH,OAAO,GAAG,OAAO;;;gBAGrB,IAAI,MAAM;oBACN,YAAY,YAAY;;;gBAG5B,iBAAiB,MAAM,aAAa,KAAK,UAAU,UAAU;oBACzD,IAAI,YAAY,yBAAyB;oBACzC,iBAAiB;oBACjB,iBAAiB;;;oBAGjB,IAAI,UAAU,UAAU,aAAa;wBACjC,OAAO,GAAG,OAAO;;;oBAGrB,iBAAiB,IAAI;oBACrB,WAAW,UAAU;;oBAErB,WAAW,MAAM,gCAAgC;wBAC7C,SAAS;wBACT,OAAO;;oBAEX,OAAO;mBACR,UAAC,KAAQ;oBACR,iBAAiB;;;oBAGjB,IAAI,gBAAgB,8BAA8B;oBAClD,WAAW,MAAM,gCAAgC;wBAC7C,SAAS;wBACT,UAAU;wBACV,WAAW,cAAc;wBACzB,iBAAiB,IAAI,QAAQ;wBAC7B,cAAc,cAAc;;oBAEhC,OAAO,GAAG,OAAO;;;;YAIzB,OAAO;;;;;;;;QAQX,SAAS,yBAAyB,eAAe;YAC7C,IAAI,CAAC,iBAAiB,CAAC,cAAc,MAAM;gBACvC,MAAM,IAAI,MAAM;;YAEpB,IAAI,cAAc,cAAc;;YAEhC,IAAI,YAAY,SAAS,wBAAwB;;YAEjD,OAAO,OAAO,KAAK,WAAW,OAAO,UAAC,MAAM,KAAQ;gBAChD,IAAI,YAAY,QAAQ,UAAU,MAAM;oBACpC,KAAK,YAAY,QAAQ,UAAU;;gBAEvC,OAAO;eACR;;;QAGP,SAAS,8BAA8B,eAAe;YAClD,IAAI,CAAC,iBAAiB,CAAC,cAAc,MAAM;gBACvC,MAAM,IAAI,MAAM;;YAEpB,OAAO;gBACH,oBAAoB,cAAc,KAAK;gBACvC,gBAAgB,cAAc,KAAK;gBACnC,UAAU,cAAc,KAAK;gBAC7B,aAAa,cAAc,KAAK;gBAChC,gBAAgB,cAAc,KAAK;;;;;;;;;;;QAW3C,SAAS,8BAA8B,wBAAwB;YAC3D,IAAI,YAAY;gBAAG,YAAY;gBAAW;gBAAS;gBAAc;;YAEjE,yBAAyB,uBAAuB;;;YAGhD,IAAI,wBAAwB;gBACxB,UAAU,uBAAuB,MAAM;gBACvC,YAAY,WAAW,QAAQ,SAAS,KAAK,QAAQ;;gBAErD,YAAY,aAAa,UAAU,QAAQ,SAAS;;;gBAGpD,QAAQ;oBACJ,KAAK;oBACL,KAAK;oBACL,KAAK;oBACL,KAAK;oBACL,KAAK;oBACL,KAAK;wBAAQ;4BACT,YAAY,YAAY,SAAS,YAAY;4BAC7C;;;oBAGJ;wBAAS;4BACL,YAAY;4BACZ;;;;gBAIR,YAAY,uBAAuB,MAAM;gBACzC,YAAY,aAAa,UAAU,SAAS,KAAK,UAAU;;gBAE3D,qBAAqB,aAAc,OAAO,yBACtC,KAAK,UAAU,0BACf;gBACJ,eAAe,kBAAkB,kBAAkB;;YAEvD,OAAO;gBACH,gBAAiB,cAAc;gBAC/B,WAAW;gBACX,cAAc;gBACd,WAAW;gBACX,oBAAA;;;;;;;;;QASR,SAAS,oBAAoB;;YAEzB,iBAAiB,IAAI;gBACjB,OAAO;gBACP,aAAa;;YAEjB,OAAO,MAAM;gBACL,eAAe;gBACf,kBAAkB;gBAClB,QAAQ;gBACR,KAAK,YAAY;eAClB,KAAK,0BACR,UAAA,KAAO;gBACH,WAAW,MAAM,uBAAuB;oBACpC,UAAU,8BAA8B;oBACxC,SAAS;;gBAEb,OAAO,GAAG,OAAO,8BAA8B;;;;;QAK3D,SAAS,oBAAoB,MAAM,UAAU,QAAQ,QAAQ,iBAAiB;YAC1E,IAAI,YAAY,iBAAiB;gBAC7B,WAAW;gBACP,kBAAkB,UAAU;gBAC5B,oBAAoB,UAAU;gBAC9B,aAAa,KAAK;;;YAG1B,IAAI,UAAU;gBACV,SAAS,yBAAyB;;;YAGtC,IAAI,UAAU,QAAQ,OAAO;gBACzB,eAAe;gBACf,WAAW;gBACX,kBAAkB;gBAClB,MAAM;gBACN,QAAQ;gBACR,KAAK;eACN;YACH,OAAO,MAAM,SAAS,KAAK,UAAC,UAAa;;gBAErC,WAAW,MAAM,kCAAkC;oBAC/C,eAAe,SAAS,QAAQ;;gBAEpC,IAAI,QAAQ,WAAW,kBAAkB;oBACrC,IAAI,kBAAkB,gBAAgB;oBACtC,IAAI,iBAAiB;;;wBAGjB,iBAAiB,IAAI;wBACrB,OAAO,gBAAgB;2BACpB;wBACH,OAAO,GAAG,OAAO;;;gBAGzB,OAAO;eACR,UAAC,KAAQ;;;gBAGR,WAAW,MAAM,kCAAkC;oBAC/C,eAAe,IAAI,QAAQ;;;gBAG/B,OAAO,GAAG,OAAO,8BAA8B;;;;;;;;;;QAUvD,SAAS,gBAAgB,UAAU,MAAM;YACrC,OAAO,oBAAoB,MAAM,UAAU,YAAY,wBAAwB;gBAC3E,SAAS;oBACL,gBAAgB;;gBAEpB,kBAAkB,SAAA,iBAAU,KAAK;oBAC7B,OAAO,OAAO,KAAK,KACd,IAAI,UAAA,KAAG;wBAMR,OANY,mBAAmB,OAAO,MAAM,mBAAmB,IAAI;uBAClE,KAAK;;eAEf;;;QAGP,SAAS,cAAc,MAAM;YACzB,OAAO,oBAAoB,MAAM,MAAM,YAAY,sBAAsB;gBACrE,SAAS;oBACL,gBAAgB;;gBAEpB,cAAc,CAAC;eAChB;;;QAGP,SAAS,cAAc,MAAM;YACzB,OAAO,oBAAoB,MAAM,MAAM,YAAY,kBAAkB;gBACjE,aAAa;gBACb,iBAAiB;gBACjB,SAAS;oBACL,gBAAgB;;gBAEpB,kBAAkB,SAAA,iBAAU,KAAK;oBAC7B,OAAO,OAAO,KAAK,KACd,IAAI,UAAA,KAAG;wBAMR,OANY,mBAAmB,OAAO,MAAM,mBAAmB,IAAI;uBAClE,KAAK;;eAEf;;;;;;;;;;;QAWP,SAAS,cAAc,UAAU,UAAU,MAAM;;YAE7C,IAAI,YAAY,iBAAiB;gBAC7B,WAAW;gBACP,kBAAkB,UAAU;gBAC5B,oBAAoB,UAAU;gBAC9B,aAAa,KAAK;gBAClB,UAAU;gBACV,UAAU;;;YAGlB,OAAO,MAAM;gBACL,eAAe;gBACf,WAAW;gBACX,kBAAkB;gBAClB,MAAM;gBACN,SAAS,EAAC,gBAAgB;gBAC1B,kBAAkB,SAAA,iBAAU,KAAK;oBAC7B,OAAO,OAAO,KAAK,KACd,IAAI,UAAA,KAAG;wBAMZ,OANgB,mBAAmB,OAAO,MAAM,mBAAmB,IAAI;uBAClE,KAAK;;gBAEd,QAAQ;gBACR,KAAK,YAAY;eAEpB,KAAK,UAAU,UAAU;gBACtB,IAAI,kBAAkB,yBAAyB;gBAC/C,IAAI,iBAAiB;;oBAEjB,iBAAiB,IAAI;oBACrB,OAAO,gBAAgB;uBACpB;oBACH,OAAO,GAAG,OAAO,CAAC;wBACd,gBAAgB;wBAChB,KAAK,YAAY;;;;;;QAOrC,SAAS,WAAW,YAAY;;YAE5B,IAAI,SAAS,aAAa,KAAK,QAAQ;YACvC,IAAI,SAAS,GAAG;gBACZ;;YAEJ,gBAAgB,SAAS,YAAY;gBACjC,gBAAgB;gBAChB;eACD;;YAEH,OAAO;;;;;;;;;;;QAWX,SAAS,UAAU,SAAS;YACxB,IAAI,YAAY,iBAAiB;;;YAG7B,SAAS,OAAO,OAChB;gBACI,sBAAsB,YAAY;gBAClC,eAAe;gBACf,0BAA0B,YAAY;gBACtC,eAAe;gBACf,mBAAmB,KAAK;gBACxB,iBAAiB,YAAY;eAC9B,QAAQ;gBAEX,SAAS,QAAQ,YAAY,OAAO;gBAEpC;gBACA;;YAEJ,IAAI,CAAC,QAAQ,kBAAkB;gBAC3B,OAAO,cAAc,CAAC,SAAS,QAAQ,UAAU,QAAQ,QAAQ,gBAAgB;;;YAGrF,IAAI,UAAU,aAAa;gBACvB,OAAO,qBAAqB,UAAU;;;YAG1C,IAAI,QAAQ;gBACR,UAAU,QAAQ,QAAQ,UAAU;gBACpC,UAAU,cAAc,QAAQ,UAAU;;YAE9C,YAAY,YAAY,KAAK,SAAS,WAAW;;YAEjD,eAAe,OAAO,KAAK,QAAQ,IAAI,UAAA,KAAG;gBAEtC,OAF0C,MAAM,OAAO,OAAO,OAAO;eAAK,OAAO,KAAK;;YAE1F,gBAAgB,wBAAwB,YAAY;;YAEpD,OAAO;gBACH,iBAAiB,WAAW;;;;QAIpC,SAAS,UAAU,WAAuB;YAItC,IAJ0B,SAAM,UAAA,UAAA,KAAA,UAAA,OAAA,YAAG,IAAC,UAAA;;YACpC,IAAI,MAAM,KAAK;YACf,OAAO,OAAO,eAAe,KAAM,MAAO,SAAU,OAAO;;;QAG/D,SAAS,OAAO;YACZ,SAAS,KAAK;gBACV,OAAO,KAAK,MACR,KAAK,WAAW;kBAClB,SAAS;;;YAGf,OACI,OAAO,OACP,OACA,OACA,OACA,OAAO,OAAO;;;QAItB,SAAS,QAAQ;YACb,iBAAiB;;QAErB,SAAS,SAAS;YACd,SAAS;;;;;;QAMb,SAAS,iBAAiB;YACtB,IAAI,eAAe;gBACf,SAAS,OAAO;;;;KAI3B","file":"ovpApp/oauth/oauth-service.js","sourcesContent":["(function () {\n    'use strict';\n\n    /**\n     * OAuth service\n     * Manage and control user authentication.\n     */\n    angular.module('ovpApp.oauth')\n        .provider('OauthService', OauthProvider);\n\n    /**\n     * Must use a provider here to make sure this is available in the configuration when creating the\n     * interceptors\n     */\n    function OauthProvider() {\n        var oService = null;\n\n        return {\n            $get: function ($injector) {\n                if (!oService) {\n                    oService = $injector.instantiate(OauthService);\n                }\n                return oService;\n            },\n\n            getService: function () {\n                return oService;\n            }\n        };\n    }\n\n    /* @ngInject */\n\n    function OauthService($q, $http, $log, $cookies, $timeout, OauthDataManager, oAuthConfig, httpUtil, config,\n        OauthKeyMap, messages, $rootScope, OauthSigner, $injector, streamPlusService, profileService,\n        ovpStorage, storageKeys, $window, $location, errorCodesService) {\n        const service = this;\n\n        let _isAuthenticated = false,\n            _loginRequired = false,\n            verifierKey = 'oauth_verifier',\n            refreshTokenKey = 'xoauth_refresh_token',\n            _refreshTokenMutex = null,\n            _getTokenMutex = null,\n            _sentResumeAuth = false,\n            _sentAutoAccess = false,\n            _timerPromise = null,\n            _oauthError = null,\n            loginDefer = null,\n            _refreshExpireBufferTime = 30000, //Add this when determining if the token is expired\n            _refreshBufferTime = oAuthConfig.refreshBufferTime,\n            _autoOauthDisabledTimeInMilliseconds = (config.autoAccessDisabledTimePeriodInMinutes * 60000);\n\n        //The refresh timer should vary by tab so it doesn't fire at the same time in more than one instance\n        _refreshBufferTime += Math.floor(Math.random() * 10) * 1000;\n\n        service.updateToken = updateToken;\n        service.userLogin = userLogin;\n        service.getOAuthHeader = getHeader;\n        service.isAuthenticated = isAuthenticated;\n        service.getOAuthError = getOAuthError;\n        service.logout = logout;\n        service.reset = reset;\n        service.clearTimeout = removeTimeouts;\n        service.shouldAttemptMasquerade = shouldAttemptMasquerade;\n        service.getMasqueradeToken = getMasqueradeToken;\n        service.waitUntilAuthenticated = waitUntilAuthenticated;\n\n        // Clear specU state from storage\n        ovpStorage.removeItem(storageKeys.showSpecULink);\n\n        return;\n        //////\n\n        /**\n         * This is the definitive \"isAuthenticated\" this knows the actual state of the user, an can verify the\n         * user's state.\n         *\n         * NOTE: this has a slight change from the previous version in that tries hard not to reject the promise\n         * under normal operation.\n         *\n         * @return {Promise(Boolean)} returns a promise that will resolve with the answer\n         */\n        function isAuthenticated(force = false) {\n            return updateToken(force).then(() => {\n                ovpStorage.removeItem(storageKeys.autoAuthSignOutTime);\n                _oauthError = null;\n                return $q.resolve(true);\n            }, (err = {}) => {\n                _loginRequired = true;\n                _oauthError = err;\n                return $q.resolve(false);\n            });\n        }\n\n        /**\n         * Attempt to sso if url parameter exists and feature is enabled\n         * @returns {boolean}\n         */\n        function shouldAttemptSso() {\n            return config.ssoEnabled && ($location.search().sessionOverride === 'true');\n        }\n\n        /**\n         * Attempt to masquerade if url parameter exists and feature is enabled\n         * @returns {boolean}\n         */\n        function shouldAttemptMasquerade() {\n            return config.masqueradeEnabled && angular.isDefined(getMasqueradeToken());\n        }\n\n        /**\n         * ACE application will supply a request parameter with a valid token that is used to\n         * authenticate\n         * @returns {*}\n         */\n        function getMasqueradeToken() {\n            return $location.search().mqtn;\n        }\n\n        /**\n         * masquerade token to be used to create special OAuth session\n         */\n        function createOAuthSessionFromMasqueradeToken(masqueradeToken, temp) {\n            if (shouldAttemptMasquerade()) {\n                OauthDataManager.reset();\n                var oAuthData = OauthDataManager.get(),\n                    authData = {\n                        xoauth_device_id: oAuthData.deviceId,\n                        xoauth_device_type: oAuthData.deviceType,\n                        xoauth_masquerade_token: masqueradeToken,\n                        oauth_token: temp.token\n                    };\n\n                return $http({\n                    bypassRefresh: true,\n                    oAuthIgnoreToken: true,\n                    data: authData,\n                    headers: {'Content-Type': 'application/x-www-form-urlencoded'},\n                    transformRequest: function (obj) {\n                        return Object.keys(obj)\n                            .map(key => encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]))\n                            .join('&');\n                    },\n                    method: 'POST',\n                    url: oAuthConfig.masqueradeUrl\n                })\n                .then(function (response) {\n                    let masqResponse = getOAuthDataFromResponse(response);\n                    return getToken(masqResponse.verifier, temp);\n                });\n            } else {\n                return $q.reject('No masquerade token');\n            }\n        }\n\n        function getOAuthError() {\n            return _oauthError;\n        }\n\n        // Private method\n        function shouldRejectAutoOauth() {\n            let autoAuthSignOutTime = ovpStorage.getItem(storageKeys.autoAuthSignOutTime);\n            return autoAuthSignOutTime &&\n                ((Date.now() - autoAuthSignOutTime) < _autoOauthDisabledTimeInMilliseconds);\n        }\n\n        /**\n         * Returns a promise which will resolve once the user is authenticated\n         */\n        function waitUntilAuthenticated() {\n            return isAuthenticated()\n                .then(authenticated => {\n                    if (!authenticated) {\n                        if (!loginDefer) {\n                            loginDefer = $q.defer();\n                        }\n                        return loginDefer.promise;\n                    }\n                });\n        }\n\n        /**\n         * Verify that we have a valid token or attempt to update the token, this function manages the token state\n         * so that it knows if the token actually needs updating or if we know its ok.\n         * @return {Promise}\n         */\n        function updateToken(force = false) {\n            var oAuthData = OauthDataManager.get();\n\n            // Record resumeAuth, if appropriate and we haven't already done so for this session.\n            if (!_isAuthenticated && !_sentResumeAuth && !isExpired(oAuthData.expiration, _refreshExpireBufferTime) &&\n                !_sentAutoAccess) {\n\n                // Analytics\n                $rootScope.$emit('Analytics:loginStart', {\n                    authType: 'resumeAuth'\n                });\n                $rootScope.$emit('Analytics:loginStop', {\n                    oauth: OauthDataManager.get(),\n                    success: true\n                });\n\n                _sentResumeAuth = true;\n            }\n\n            // No longer force a refreshToken on page refresh, only if forced or expired\n            // _refreshTokenMutex check to make sure that refresh token request is not in-progress\n            if (!_refreshTokenMutex && !isExpired(oAuthData.expiration, _refreshExpireBufferTime) && !force) {\n                return profileService.isProfileRefreshed() ? $q.resolve() : profileService.postAuth();\n            } else if (!_loginRequired || force) {\n                return refreshToken();\n            } else {\n                //User must login before contiune\n                return $q.reject(_oauthError || 'User must login');\n            }\n        }\n\n        /**\n         * Use a username and password to fetch an oauth token set and use that for future data requests.\n         *\n         * @param  {String} username\n         * @param  {String} password\n         * @return {Promise}\n         */\n        function userLogin(username, password) {\n\n            // Analytics\n            $rootScope.$emit('Analytics:loginStart', {\n                authType: 'manualAuth',\n                username: username\n            });\n\n            return getTemporaryToken().then((temp) => {\n                return authorizeUser(username, password, temp).then((verifier) => {\n                    _isAuthenticated = true;\n                    return getToken(verifier, temp);\n                }, function (err) {\n\n                    // Emit loginStop failure event.\n                    $rootScope.$emit('Analytics:loginStop', {\n                        response: getOAuthErrorCodeFromResponse(err),\n                        success: false\n                    });\n                    return $q.reject(getOAuthErrorCodeFromResponse(err));\n                });\n            }).then(function (token) {\n                // Manual authorization succeeded\n                _isAuthenticated = true;\n                if (loginDefer) {\n                    loginDefer.resolve();\n                    loginDefer = undefined;\n                }\n                $rootScope.$broadcast('OauthService:loginActionComplete');\n                return token;\n            });\n        }\n\n        /**\n         * Attempt to refresh the token by all means. If this eventually fails after attempting all tokens and login\n         * methods, log the user out\n         * @return {Promise}\n         */\n        function refreshToken() {\n            if (!_refreshTokenMutex) {\n                _refreshTokenMutex = getToken().catch((tokenErr) => {\n                    return getTemporaryToken().then((tempToken) => {\n                        return refreshTokenWithDeviceVerifier(tempToken).catch((deviceErr) => {\n                            return attemptTokenExchange(tempToken).catch((err) => {\n                                //If all normal attempts to long fail, we should try to use the masq\n                                //token, if that fails - we should see a normal login\n                                if (shouldAttemptMasquerade()) {\n                                    return createOAuthSessionFromMasqueradeToken(getMasqueradeToken(), tempToken)\n                                    .then((oauthData) => {\n                                        $location.search({}); // clear query param\n                                        return oauthData;\n                                    }, (err) => {\n                                        $location.search({}); // clear query params on error too\n                                        return $q.reject(err);\n                                    });\n                                } else if (profileService.isAutoAuthEnabled()) {\n                                    return refreshTokenWithAutoVerifier(tempToken);\n                                } else {\n                                    $log.debug(`Failed to fetch token with deviceVerifier ${tokenErr},\n                                        ${(deviceErr && deviceErr.errorName) ? deviceErr.errorName : deviceErr}`);\n                                    return $q.reject(err);\n                                }\n                            });\n                        });\n                    });\n                }).then(() => {\n                    //If we managed to get a token we can say for sure that we where able to verify a login.\n                    _isAuthenticated = true;\n                    _refreshTokenMutex = null;\n                    _loginRequired = false;\n\n                    return profileService.isProfileRefreshed() ? $q.resolve() : profileService.postAuth();\n                }, (err = {}) => {\n                    //Need to make sure and clear the mutex so we can try again at some point - regardless of\n                    //what happened\n                    _refreshTokenMutex = null;\n                    _isAuthenticated = false;\n                    // Get a reference to the connectivity service. This is\n                    // done here to avoid a circular dependency at module load\n                    // time.\n                    let connectivitySvc = $injector.get('connectivityService');\n                    if (connectivitySvc && connectivitySvc.isOnline()) {\n                        // We are online or not able to determine if online\n                        // Force login.\n                        _loginRequired = true;\n                        OauthDataManager.reset();\n                        return $q.reject(err);\n                    } else {\n                        // Offline so try again  when another request is made.\n                        // Silently fail.\n                        return $q.resolve();\n                    }\n                });\n            }\n            return _refreshTokenMutex;\n        }\n\n        function refreshTokenWithDeviceVerifier(tempToken) {\n            let deviceVerifier = OauthDataManager.get().deviceVerifier;\n            if (deviceVerifier) {\n\n                // Analytics\n                $rootScope.$emit('Analytics:loginStart', {\n                    authType: 'verifierAuth'\n                });\n\n                return authorizeDevice(deviceVerifier, tempToken).then((verifier) => {\n                    return getToken(verifier, tempToken);\n                }).then(function () {\n                    // verifierAuthSuccess\n\n                    // Analytics\n                    $rootScope.$emit('Analytics:loginStop', {\n                        oauth: OauthDataManager.get(),\n                        success: true\n                    });\n                }, function (err) {\n                    // verifier auth failed\n\n                    // Analytics\n                    $rootScope.$emit('Analytics:loginStop', {\n                        response: err,\n                        success: false\n                    });\n                    return $q.reject(err);\n                });\n            } else {\n                return $q.reject();\n            }\n        }\n\n        function attemptTokenExchange(temp) {\n            let shouldAttempt = shouldAttemptSso();\n            if (shouldAttempt && shouldRejectAutoOauth()) {\n                return $q.reject('SSO enabled, but user manually logged out recently');\n            } else if (shouldAttempt) {\n                const isMobile = $window.navigator.userAgent.match(/(ipad)|(iphone)|(ipod)|(android)/i);\n                if (!isMobile) {\n                    return tokenExchange(temp).then((verifier) => {\n                        return getToken(verifier, temp);\n                    });\n                } else {\n                    return $q.reject('SSO enabled, but user is on a mobile device');\n                }\n            } else {\n                return $q.reject('SSO is not enabled');\n            }\n        }\n\n        function refreshTokenWithAutoVerifier(tempToken) {\n            // Analytics: loginstart - autoAccess\n            if (!_sentAutoAccess) {\n                $rootScope.$emit('Analytics:loginStart', {\n                    authType: 'autoAccess'\n                });\n                _sentAutoAccess = true;\n            }\n\n            return autoAuthorize(tempToken).then((verifier) => {\n                return getToken(verifier, tempToken);\n            }).then(function () {\n                // Autoauth success\n                // SpecU and Bulk MDU users don't need a package. Other account types much check capabilities\n                // We need to disable auto auth for 24 hours before application auto logs in for a user,\n                // and also show a link on the login screen that enables SpecU login, in this situation.\n                // Refer - https://jira.charter.com/browse/STVWEB-1265\n                if (profileService.isSpecUOrBulkMDU()) {\n                    return shouldRejectAutoOauth() ?\n                        $q.reject({\n                            isSpecU: profileService.isSpecU(),\n                            isBulkMDU: profileService.isBulkMDU(),\n                            isManualOperation: true\n                        }) : $q.resolve();\n                } else {\n                    // Autoauth only for eligible customer\n                    // Refresh capabilities to cache values\n                    return profileService.postAuth(true).then(() => {\n                        // Show login screen for video customer not subscribed to IPTV package\n                        return profileService.isIptvPackage().then((isIpOnly) => {\n                            return profileService.canUseTwctv().then(() => { // has video capabilitiy\n                                if (!isIpOnly) {\n                                    return $q.reject('ipOnlyError');\n                                }\n                            }).catch(err => { // no video capabilitiy\n                                if (err === 'ipOnlyError') {\n                                    throw err;\n                                } else {\n                                    return true;\n                                }\n                            });\n                        }).then(() => {\n                            if (shouldRejectAutoOauth()) {\n                                // Clear token\n                                OauthDataManager.reset();\n                                // Analytics\n                                $rootScope.$emit('Analytics:forcedLogin', {\n                                    operationType: 'manual'\n                                });\n                                return $q.reject({\n                                    isStreamPlus: true,\n                                    isManualOperation: true\n                                });\n                            }\n                        });\n                    });\n                }\n            }, function (err) {\n\n                // Analytics: loginstop - autoAccess - failed\n                $rootScope.$emit('Analytics:loginStop', {\n                    response: err,\n                    success: false\n                });\n\n                // Autoauth failed\n                $log.debug('Failed to auto authorize');\n                return $q.reject(err);\n            });\n        }\n\n        /**\n         * Get a new OauthToken and store the response. This code makes sure that we do not generate more than\n         * one request at a time.\n         * @param  {String} verifier device verifier token\n         * @param  {String} temp     Temporary oauth token\n         * @return {Promise}         This may be a new promise or a stored promise (_getTokenMutex)\n         */\n        function getToken(verifier, temp) {\n            var oAuthData = OauthDataManager.get(),\n                expiration = oAuthData.expiration,\n                unixTimeNow = Date.now(),\n                oAuthFields = {},\n                ajaxOptions = {\n                    bypassRefresh: true,\n                    oAuthFields: oAuthFields,\n                    method: 'POST',\n                    url: oAuthConfig.tokenUrl\n                };\n\n            //_getTokenMutex keeps us from trying to fetch the token more than once.\n            if (!_getTokenMutex) {\n                if (verifier) {\n                    oAuthFields[verifierKey] = verifier;\n                } else if (unixTimeNow < expiration) {\n                    oAuthFields[refreshTokenKey] = oAuthData.refreshToken;\n                } else {\n                    return $q.reject('Expired Token');\n                }\n\n                if (temp) {\n                    ajaxOptions.oAuthTemp = temp;\n                }\n\n                _getTokenMutex = $http(ajaxOptions).then(function (response) {\n                    var oAuthData = getOAuthDataFromResponse(response);\n                    _getTokenMutex = null;\n                    _loginRequired = false;\n\n                    // STVWEB-600: Reject token if it's already expired, e.g. client clock is set to a future time\n                    if (isExpired(oAuthData.expiration)) {\n                        return $q.reject('Expired Token');\n                    }\n\n                    OauthDataManager.set(oAuthData);\n                    startTimer(oAuthData.expiration);\n\n                    $rootScope.$emit('Analytics:receivedOauthToken', {\n                        success: true,\n                        oauth: oAuthData\n                    });\n                    return oAuthData;\n                }, (err) => {\n                    _getTokenMutex = null;\n\n                    // Analytics\n                    let errorResponse = getOAuthErrorCodeFromResponse(err);\n                    $rootScope.$emit('Analytics:receivedOauthToken', {\n                        success: false,\n                        response: errorResponse,\n                        errorCode: errorResponse.errorCode,\n                        clientErrorCode: err.headers('x-pi-auth-failure'),\n                        errorMessage: errorResponse.errorMessage\n                    });\n                    return $q.reject(errorResponse);\n                });\n            }\n\n            return _getTokenMutex;\n        }\n\n        /**\n         * Parse the response text and extract the key pairs.\n         * @param  {HttpResponseObject} oAuthResponse A response from an oauth service\n         * @return {Object}             Object with oauth data\n         */\n        function getOAuthDataFromResponse(oAuthResponse) {\n            if (!oAuthResponse || !oAuthResponse.data) {\n                throw new Error('unable to get data from response');\n            }\n            let oAuthString = oAuthResponse.data;\n            // get keys and map them to preferred param name\n            let dataPairs = httpUtil.getPairsFromQueryString(oAuthString);\n            // Look for each known parameter key and get the value, assign it to dataMap\n            return Object.keys(dataPairs).reduce((memo, key) => {\n                if (OauthKeyMap[key] && dataPairs[key]) {\n                    memo[OauthKeyMap[key]] = dataPairs[key];\n                }\n                return memo;\n            }, {});\n        }\n\n        function getAutoAccessDataFromResponse(oAuthResponse) {\n            if (!oAuthResponse || !oAuthResponse.data) {\n                throw new Error('unable to get data from response');\n            }\n            return {\n                deviceRegistration: oAuthResponse.data.xoauth_device_registration,\n                deviceVerifier: oAuthResponse.data.xoauth_device_verifier,\n                verifier: oAuthResponse.data.oauth_verifier,\n                accountType: oAuthResponse.data.xoauth_account_type,\n                classification: oAuthResponse.data.xoauth_classification\n            };\n        }\n\n        /*\n         * Parse OAuth response for error\n         *\n         * @param {string} oAuthErrorCodeResponse Raw OAuth response\n         *\n         * @return {string} Error code, usually a number\n         */\n        function getOAuthErrorCodeFromResponse(oAuthErrorCodeResponse) {\n            var errorCode = 0, errorName = 'UNKNOWN', matches, errorMessage, clientErrorMessage;\n\n            oAuthErrorCodeResponse = oAuthErrorCodeResponse.data;\n            // format of response is typically ERROR_CODE (1010) some error code explained\n            // get just the (1010) portion\n            if (oAuthErrorCodeResponse) {\n                matches = oAuthErrorCodeResponse.match(/\\([0-9]+\\)/g);\n                errorCode = matches && matches.length > 0 && matches[0];\n                // remove parens\n                errorCode = errorCode && errorCode.replace(/[()]/g, '');\n\n                // Normalize error code\n                switch (errorCode) {\n                    case '1010':\n                    case '1012':\n                    case '1024':\n                    case '1025':\n                    case '1027':\n                    case '1032': {\n                        errorCode = errorCode ? 'WLI-' + errorCode : errorCode;\n                        break;\n                    }\n\n                    default: {\n                        errorCode = 'WLI-9000';\n                        break;\n                    }\n                }\n\n                errorName = oAuthErrorCodeResponse.match(/RC_[A-Z_]*/g);\n                errorName = errorName && errorName.length > 0 && errorName[0];\n\n                clientErrorMessage = ('object' === typeof oAuthErrorCodeResponse) ?\n                    JSON.stringify(oAuthErrorCodeResponse) :\n                    oAuthErrorCodeResponse;\n                errorMessage = errorCodesService.getMessageForCode(errorCode);\n            }\n            return {\n                isInvalidCreds: (errorCode === 'WLI-1010'),\n                errorName: errorName,\n                errorMessage: errorMessage,\n                errorCode: errorCode,\n                clientErrorMessage\n            };\n        }\n\n        /**\n         * Get a temporary token\n         *\n         * @return {Promise} [description]\n         */\n        function getTemporaryToken() {\n            //Make sure that we wipe the old token so that it isn't used when getting the new token\n            OauthDataManager.set({\n                token: null,\n                tokenSecret: null\n            });\n            return $http({\n                    bypassRefresh: true,\n                    oAuthIgnoreToken: true,\n                    method: 'POST',\n                    url: oAuthConfig.temporaryRequestUrl\n                }).then(getOAuthDataFromResponse,\n                err => {\n                    $rootScope.$emit('Analytics:loginStop', {\n                        response: getOAuthErrorCodeFromResponse(err),\n                        success: false\n                    });\n                    return $q.reject(getOAuthErrorCodeFromResponse(err));\n                });\n        }\n\n        /* Private method */\n        function _deviceOauthRequest(temp, verifier, reqUrl, reqOpt, responseHandler) {\n            var oAuthData = OauthDataManager.get(),\n                authData = {\n                    xoauth_device_id: oAuthData.deviceId,\n                    xoauth_device_type: oAuthData.deviceType,\n                    oauth_token: temp.token\n                };\n\n            if (verifier) {\n                authData.xoauth_device_verifier = verifier;\n            }\n\n            let options = angular.extend({\n                bypassRefresh: true,\n                oAuthTemp: temp,\n                oAuthIgnoreToken: true,\n                data: authData,\n                method: 'POST',\n                url: reqUrl\n            }, reqOpt);\n            return $http(options).then((response) => {\n                // Analytics: Capture authorization attempt Id\n                $rootScope.$emit('Analytics:captureAuthAttemptId', {\n                    authAttemptId: response.headers('x-trace-id')\n                });\n                if (angular.isFunction(responseHandler)) {\n                    var oAuthDeviceData = responseHandler(response);\n                    if (oAuthDeviceData) {\n                        //Store device auth data here so we know refreshToken can be run\n\n                        OauthDataManager.set(oAuthDeviceData);\n                        return oAuthDeviceData.verifier;\n                    } else {\n                        return $q.reject('Unable to retrieve device data');\n                    }\n                }\n                return response;\n            }, (err) => {\n\n                // Analytics: Capture authorization attempt Id\n                $rootScope.$emit('Analytics:captureAuthAttemptId', {\n                    authAttemptId: err.headers('x-trace-id')\n                });\n\n                return $q.reject(getOAuthErrorCodeFromResponse(err));\n            });\n        }\n\n        /**\n         * Use stored device token to fetch a new _verifier_ ??\n         *\n         * I suspect that this may not be necessary, since we are using a temp token and a stored device_verifer\n         * to get a new device verifier.\n         */\n        function authorizeDevice(verifier, temp) {\n            return _deviceOauthRequest(temp, verifier, oAuthConfig.deviceAuthorizationUrl, {\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                },\n                transformRequest: function (obj) {\n                    return Object.keys(obj)\n                        .map(key => encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]))\n                        .join('&');\n                }\n            }, getOAuthDataFromResponse);\n        }\n\n        function autoAuthorize(temp) {\n            return _deviceOauthRequest(temp, null, oAuthConfig.autoAuthorizationUrl, {\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                ignoreStatus: [401]\n            }, getAutoAccessDataFromResponse);\n        }\n\n        function tokenExchange(temp) {\n            return _deviceOauthRequest(temp, null, oAuthConfig.tokenExchangeUrl, {\n                crossDomain: true,\n                withCredentials: true,\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                },\n                transformRequest: function (obj) {\n                    return Object.keys(obj)\n                        .map(key => encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]))\n                        .join('&');\n                }\n            }, getOAuthDataFromResponse);\n        }\n\n        /**\n         * Use a username and password combination get a device verifier token to use in the _getToken_ call.\n         *\n         * @param  {String} username\n         * @param  {String} password\n         * @param  {String} temp     Temporary token\n         * @return {Promise}\n         */\n        function authorizeUser(username, password, temp) {\n\n            var oAuthData = OauthDataManager.get(),\n                authData = {\n                    xoauth_device_id: oAuthData.deviceId,\n                    xoauth_device_type: oAuthData.deviceType,\n                    oauth_token: temp.token,\n                    username: username,\n                    password: password\n                };\n\n            return $http({\n                    bypassRefresh: true,\n                    oAuthTemp: temp,\n                    oAuthIgnoreToken: true,\n                    data: authData,\n                    headers: {'Content-Type': 'application/x-www-form-urlencoded'},\n                    transformRequest: function (obj) {\n                        return Object.keys(obj)\n                            .map(key => encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]))\n                            .join('&');\n                    },\n                    method: 'POST',\n                    url: oAuthConfig.deviceAuthorizationUrl\n                })\n                .then(function (response) {\n                    var oAuthDeviceData = getOAuthDataFromResponse(response);\n                    if (oAuthDeviceData) {\n                        //Store device auth data here so we know refreshToken can be run\n                        OauthDataManager.set(oAuthDeviceData);\n                        return oAuthDeviceData.verifier;\n                    } else {\n                        return $q.reject([{\n                            isInvalidCreds: false,\n                            url: oAuthConfig.deviceAuthorizationUrl\n                        }]);\n                    }\n                });\n\n        }\n\n        function startTimer(expiration) {\n\n            var millis = expiration - Date.now() - _refreshBufferTime; //oAuthConfig.refreshBufferTime;\n            if (millis > 0) {\n                removeTimeouts();\n            }\n            _timerPromise = $timeout(function () {\n                _timerPromise = null;\n                refreshToken();\n            }, millis);\n\n            return _timerPromise;\n        }\n\n        /*\n         * Returns modified headers for OAuth requests\n         *\n         * @param {Object} options URL, POST/GET, oAuthParamKeys to send, ignoreTokenSecret\n         * for pre-token oauth calls\n         *\n         * @return {Object} Modified headers including OAuth headers to be send with request\n         */\n        function getHeader(request) {\n            var oAuthData = OauthDataManager.get(),\n\n                // oauth keys to always send\n                params = Object.assign(\n                {\n                    'oauth_consumer_key': oAuthConfig.consumerKey,\n                    'oauth_nonce': guid(),\n                    'oauth_signature_method': oAuthConfig.signatureMethod,\n                    'oauth_token': '',\n                    'oauth_timestamp': Date.now(),\n                    'oauth_version': oAuthConfig.version\n                }, request.oAuthFields),\n\n                isTemp = request.oAuthTemp ? true : false,\n\n                paramsHeader,\n                signature;\n\n            if (!request.oAuthIgnoreToken) {\n                params.oauth_token = (isTemp ? request.oAuthTemp.token : request.oauth_token) || '';\n            }\n\n            if (oAuthData.accountType) {\n                params.oauth_account_type = oAuthData.accountType;\n            }\n\n            if (isTemp) {\n                oAuthData.token = request.oAuthTemp.token;\n                oAuthData.tokenSecret = request.oAuthTemp.tokenSecret;\n            }\n            signature = OauthSigner.sign(request, oAuthData, params);\n\n            paramsHeader = Object.keys(params).map(key => key + '=\"' + params[key] + '\"').sort().join(', ');\n            // append signature to header\n            paramsHeader += ', oauth_signature=\"' + signature + '\"';\n\n            return {\n                'Authorization': 'OAuth ' + paramsHeader\n            };\n        }\n\n        function isExpired(timestamp, buffer = 0) {\n            var now = Date.now();\n            return Number(timestamp) === 0 || ((now + buffer) > Number(timestamp));\n        }\n\n        function guid() {\n            function S4() {\n                return Math.floor(\n                    Math.random() * 0x10000 /* 65536 */\n                ).toString(16);\n            }\n\n            return (\n                S4() + S4() +\n                S4() +\n                S4() +\n                S4() +\n                S4() + S4() + S4()\n            );\n        }\n\n        function reset() {\n            OauthDataManager.reset();\n        }\n        function logout() {\n            httpUtil.logout();\n        }\n\n        /**\n         * Clear any existing timeout that might be waiting to refresh the token.\n         */\n        function removeTimeouts() {\n            if (_timerPromise) {\n                $timeout.cancel(_timerPromise);\n            }\n        }\n    }//End OauthService\n}());\n"],"sourceRoot":"/source/"}