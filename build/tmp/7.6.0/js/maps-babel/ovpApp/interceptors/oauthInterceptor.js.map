{"version":3,"sources":["ovpApp/interceptors/oauthInterceptor.js"],"names":[],"mappings":"AAAA;;AAAA,CAAC,YAAY;;sDACT;IACA,QAAQ,OAAO,6BAA6B,CAAC,kBACxC,OAAO;;;;;;;;;;;IAWZ,SAAS,iBAAiB,eAAe;QACrC,cAAc,aAAa,KAAK,CAAC,MAAM,aAAa,UAAU,IAAI,WAAW;YACzE,IAAI,kBAAkB;YACtB,OAAO;gBACH,SAAS,SAAA,QAAU,QAAQ;oBACvB,IAAI,eAAe,UAAU,IAAI;wBAC7B,YAAY,UAAU,IAAI;;oBAE9B,IAAI,OAAO,IAAI,QAAQ,UAAU,MAAM,mBAAmB,CAAC,MACtD,OAAO,IAAI,QAAQ,UAAU,YAAY,KAC1C,OAAO,IAAI,QAAQ,UAAU,6BAA6B,IAAI;wBAC9D,IAAI,CAAC,OAAO,eAAe;;;4BAGvB,OAAO,aAAa,cAAc,KAAK,YAAM;gCACzC,OAAO,cAAc,QAAQ;+BAC9B,UAAC,KAAQ;gCACR,OAAO,GAAG,OAAO,8CACb,OAAO,MAAM,MAAM,MAAM;;+BAE9B;4BACH,OAAO,cAAc,QAAQ;;2BAG9B;;wBAEH,OAAO,GAAG,QAAQ;;;gBAI1B,eAAe;;;;YAInB,SAAS,cAAc,QAAQ,cAAc;gBACzC,IAAI,SAAS,aAAa,eAAe;gBACzC,IAAI,CAAC,OAAO,SAAS;oBACjB,OAAO,UAAU;uBACd;oBACH,OAAO,OAAO,OAAO,SAAS;;gBAElC,OAAO;;;;;;;;;;;YAWX,SAAS,qBAAqB,UAAU;gBACpC,IAAI,SAAS,UACT,SAAS,WAAW,OACpB,CAAC,SAAS,OAAO;gBAChB,SAAS,OAAO,eAAe,aAAa,SAAS,OAAO,aAAa,kBAAkB;;oBAE5F,IAAI,eAAe,UAAU,IAAI;oBACjC,OAAO,aAAa,YAAY,MAAM,KAAK,YAAM;wBAC7C,IAAI,QAAQ,UAAU,IAAI;wBAC1B,IAAI,CAAC,SAAS,OAAO,YAAY;4BAC7B,SAAS,OAAO,aAAa;;wBAEjC,SAAS,OAAO;wBAChB,OAAO,MAAM,SAAS;;uBAEvB;oBACH,OAAO,GAAG,OAAO;;;;;KAKhC","file":"ovpApp/interceptors/oauthInterceptor.js","sourcesContent":["(function () {\n    'use strict';\n    angular.module('ovpApp.interceptors.oauth', ['ovpApp.config'])\n        .config(oauthInterceptor);\n\n    /**\n     * Since http interceptors in angular are done before services initialize,\n     * the config must be injected at runtime.\n     *\n     * This is also implemented in the nns-service for jquery http calls.\n     * @param $httpProvider\n     */\n\n    /* @ngInject */\n    function oauthInterceptor($httpProvider) {\n        $httpProvider.interceptors.push(['$q', '$injector', function ($q, $injector) {\n            var MAX_RETRY_COUNT = 3;\n            return {\n                request: function (config) {\n                    var OauthService = $injector.get('OauthService'),\n                        appConfig = $injector.get('config');\n\n                    if (config.url.indexOf(appConfig.oAuth.tokenExchange) === -1 &&\n                        (config.url.indexOf(appConfig.piHost) === 0 ||\n                        config.url.indexOf(appConfig.authNeededTrackingDomain) >= 0)) {\n                        if (!config.bypassRefresh) {\n                            //Most requests will pass through this block if they dont have anything to do\n                            //with authentication.\n                            return OauthService.updateToken().then(() => {\n                                return appendHeaders(config, OauthService);\n                            }, (err) => {\n                                return $q.reject('User is not logged in, retry after login ' +\n                                    config.url + '[' + err + ']');\n                            });\n                        } else {\n                            return appendHeaders(config, OauthService);\n                        }\n\n                    } else {\n                        //No need for any authentication or other data\n                        return $q.resolve(config);\n                    }\n\n                },\n                responseError: processResponseError\n\n            };\n\n            function appendHeaders(config, OauthService) {\n                var header = OauthService.getOAuthHeader(config);\n                if (!config.headers) {\n                    config.headers = header;\n                } else {\n                    Object.assign(config.headers, header);\n                }\n                return config;\n            }\n\n            /**\n             * This will attempt to recover the session in the event that the oauth keys are invalidated. This can\n             * happen in a variety of circumstances (dormant browser tab doesn't auto refresh), other tab exchanges\n             * token without updating the current tab\n             *\n             * @param  {Object} response A failed response object\n             * @return {Promise}\n             */\n            function processResponseError(response) {\n                if (response.config &&\n                    response.status === 401 &&\n                    !response.config.bypassRefresh && //Do not attempt to refresh if a 400+ response might be expected\n                    (response.config.retryCount === undefined || response.config.retryCount < MAX_RETRY_COUNT)) {\n\n                    let OauthService = $injector.get('OauthService');\n                    return OauthService.updateToken(true).then(() => {\n                        let $http = $injector.get('$http');\n                        if (!response.config.retryCount) {\n                            response.config.retryCount = 0;\n                        }\n                        response.config.retryCount++;\n                        return $http(response.config);\n                    });\n                } else {\n                    return $q.reject(response);\n                }\n            }\n        }]);\n    }\n}());\n"],"sourceRoot":"/source/"}