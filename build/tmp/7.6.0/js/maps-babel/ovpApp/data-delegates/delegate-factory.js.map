{"version":3,"sources":["ovpApp/data-delegates/delegate-factory.js"],"names":[],"mappings":"AAAA;;AAAA,CAAC,YAAY;IACT;;;;;;;;;;;;;IAYA,QACK,OAAO,uBAAuB,CAC3B,gBACA,iBACA,mBACA,uCACA,2CACA,4BACA,8BACA,2BACA,8BACA,0BACA,4BACA,cAEH,QAAQ,mBAAmB;;;IAGhC,SAAS,gBAAgB,MAAM;QAC3B,IAAI,gBAAgB;;QAEpB,IAAI,UAAU;YACV,4BAAA;YACA,gBAAA;;;QAGJ,OAAO;;;;;;;;;;;;;QAaP,SAAS,2BAA2B,YAAY,OAAO;YACnD,cAAc,cAAc,UAAU,EAAC,YAAA,YAAY,OAAA;;;;;;;;;QASvD,SAAS,eAAe,OAAO;YAC3B,IAAI,UAAU,cAAc,OAAO,UAAA,GAAC;gBAZhC,OAYoC,EAAE,MAAM;;YAChD,IAAI,QAAQ,SAAS,GAAG;gBACpB,KAAK,MAAM;gBACX,QAAQ,GAAG,WAAW,eAAe;mBAClC,IAAI,QAAQ,WAAW,GAAG;gBAC7B,KAAK,MAAM;gBACX,OAAO;mBACJ;gBACH,OAAO,QAAQ,GAAG,WAAW,eAAe;;;;KAIvD","file":"ovpApp/data-delegates/delegate-factory.js","sourcesContent":["(function () {\n    'use strict';\n\n    /**\n     * A factory for creating the correct type of data delegate, based on what the data looks like.\n     *\n     * This is useful if you're downloading data that might match multiple types of data. For example,\n     * the product page might get series data or movie data, and this factory handles the task of\n     * deciding which of the two data delegates is appropriate.\n     *\n     * If you know ahead of time exactly what data delegate is required, then it can be instantiated\n     * directly without need of this factory.\n     */\n    angular\n        .module('ovpApp.dataDelegate', [\n            'dataDelegate',\n            'ovpApp.config',\n            'ovpApp.messages',\n            'ovpApp.services.entitlementsService',\n            'ovpApp.services.parentalControlsService',\n            'ovpApp.services.bookmark',\n            'ovpApp.services.dateFormat',\n            'ovpApp.services.channel',\n            'ovpApp.services.errorCodes',\n            'ovpApp.product.service',\n            'ovpApp.filters.titleCase',\n            'ui.router'\n        ])\n        .factory('delegateFactory', delegateFactory);\n\n    /* @ngInject */\n    function delegateFactory($log) {\n        let registrations = [];\n\n        let service = {\n            registerDelegateDefinition,\n            createInstance\n        };\n\n        return service;\n\n        ////////////////\n\n        /**\n         * Called by a data delegate to make the delegate factory aware of it.\n         *\n         * @param  {[type]} definition data delegate definition\n         * @param  {[type]} idFxn      a function that inspects an object and returns a boolean\n         *                             indicating whether the data matches this data delegate. It is\n         *                             important that the developer make this function specific enough\n         *                             that it does not match the data from other data delegates.\n         */\n        function registerDelegateDefinition(definition, idFxn) {\n            registrations[registrations.length] = {definition, idFxn};\n        }\n\n        /**\n         * Create a data delegate around an object.\n         * @param  {[type]} asset the object to install a data delegate around.\n         * @return {[type]}       a data delegate if a matching one was found, or the original object\n         *                        if one was not found.\n         */\n        function createInstance(asset) {\n            let matches = registrations.filter(r => r.idFxn(asset));\n            if (matches.length > 1) {\n                $log.debug('multiple datadelegate matches! your identifier functions are too broad');\n                matches[0].definition.createInstance(asset);\n            } else if (matches.length === 0) {\n                $log.debug('couldn\\'t find a matching datadelegate. Have you registered a definition?');\n                return asset;\n            } else {\n                return matches[0].definition.createInstance(asset);\n            }\n        }\n    }\n})();\n"],"sourceRoot":"/source/"}