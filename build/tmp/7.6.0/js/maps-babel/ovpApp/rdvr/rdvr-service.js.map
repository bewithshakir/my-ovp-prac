{"version":3,"sources":["ovpApp/rdvr/rdvr-service.js"],"names":[],"mappings":"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","file":"ovpApp/rdvr/rdvr-service.js","sourcesContent":["(function () {\n\n    'use strict';\n\n    angular.module('ovpApp.rdvr.rdvrService', [\n        'ovpApp.config',\n        'ovpApp.rdvr.recordingsCache',\n        'ovpApp.rdvr.cacheService',\n        'ovpApp.services.stbService',\n        'ovpApp.services.epgsService',\n        'rx',\n        'ovpApp.services.rxUtils',\n        'ovpApp.dataDelegate',\n        'ovpApp.rdvr.datasource'\n    ])\n    .constant('recordingsListType', {\n        SCHEDULED: 'SCHEDULED',\n        COMPLETED: 'COMPLETED',\n        SERIES_PRIORITY: 'SERIES_PRIORITY',\n        DISK_USAGE: 'DISK_USAGE'\n    })\n    .factory('rdvrService', rdvrService);\n\n    /* @ngInject */\n    function rdvrService($http, $q, $log, config, RecordingsCache, rx, rxhttp, createObservableFunction,\n              recordingsListType, $window, $rootScope, rdvrCacheService, stbService, epgsService,\n              recordingViewModelDefinition, ScheduledRecordingsDatasource, SeriesPriorityDatasource,\n              DiskUsageDatasource, MyRecordingsDatasource, $timeout) {\n\n        const stbs = {};\n        let lastScheduledRecordingsResetTime = Date.now();\n\n        const service = {\n            getSeriesPriorities,\n            setSeriesPriorities,\n            getMyRecordingGroups,\n            getCompletedAndInProgressRecordings,\n            getUsage,\n            resumeCompletedRecording,\n            playCompletedRecording,\n            deleteRecordings,\n            getScheduledRecordings,\n            resetScheduledRecordings,\n            cancelScheduled,\n            scheduleRecording,\n            getScheduledConflicts,\n            isMovie,\n            getSeriesRecordingSettings,\n            getEventRecordingSettings\n        };\n\n        return service;\n\n        //////////////////////\n\n        function initStb(stb) {\n            const key = stb.macAddressNormalized;\n            if (!stbs[key]) {\n                stbs[key] = {\n                    scheduledRecordings: new ScheduledRecordingsDatasource(stb),\n                    myRecordings: new MyRecordingsDatasource(stb),\n                    seriesPriorities: new SeriesPriorityDatasource(stb),\n                    diskUsage: new DiskUsageDatasource(stb)\n                };\n            }\n            return stbs[key];\n        }\n\n        function getDvrBase(rdvrVersion) {\n            return config.services.dvrBase.replace('*', rdvrVersion);\n        }\n\n        /**\n         * On very old shows, metadata is sometimes absent.  mock out data for UI\n         * @param recording\n         */\n        function createEmptyProgramMetadata(recording) {\n            recording.programMetadata = {\n                imageUrl: '/imageserver/program/' + recording.tmsProgramId,\n                mystroServiceId: recording.mystroServiceId,\n                rating: '',\n                title: '',\n                episodeTitle: '',\n                seasonNumber: '',\n                episodeNumber: '',\n                genres: []\n            };\n        }\n\n        function getSeriesPriorities(stb) {\n            return initStb(stb).seriesPriorities.source;\n        }\n\n        function setSeriesPriorities(stb, priorities) {\n            return initStb(stb).seriesPriorities.setSeriesPriorities(priorities);\n        }\n\n        function getMyRecordingGroups(stb) {\n            return initStb(stb).myRecordings.source\n                .map(result => {\n                    let foundSeries = {};\n                    let groupedRecordings = [];\n\n                    result.data.forEach(r => {\n                        const seriesId = r.tmsSeriesId;\n                        if (!(seriesId in foundSeries)) {\n                            let group = {\n                                episodes: [r]\n                            };\n\n                            groupedRecordings.push(group);\n\n                            if (angular.isDefined(seriesId)) {\n                                foundSeries[seriesId] = group;\n                            }\n                        } else {\n                            foundSeries[seriesId].episodes.push(r);\n                        }\n                    });\n\n                    return angular.extend({}, result, {data: groupedRecordings});\n                });\n        }\n\n        function getCompletedAndInProgressRecordings(stb) {\n            return initStb(stb).myRecordings.source;\n        }\n\n        function deleteRecordings(stb, recordings) {\n            return initStb(stb).myRecordings.deleteRecordings(recordings)\n                .then(result => {\n                    if (result.data.failedDeletions.length < recordings.length) {\n                        initStb(stb).diskUsage.reset();\n                    }\n                    return result;\n                });\n        }\n\n        function getUsage(stb) {\n            return initStb(stb).diskUsage.source;\n        }\n\n        function resumeCompletedRecording(stb, recording) {\n            return playOrResume(stb, recording, true);\n        }\n\n        function playCompletedRecording(stb, recording) {\n            return playOrResume(stb, recording, false);\n        }\n\n        function playOrResume(stb, recording, resume) {\n            if (!stb || !stb.dvr) {\n                return rx.Observable.empty();\n            }\n\n            const baseUrl = config.piHost + config.nrsApi + getDvrBase(stb.rdvrVersion);\n            const fullUrl = baseUrl + stb.macAddressNormalized +\n                (resume ? config.services.dvrRecordedResume : config.services.dvrRecordedPlay) +\n                recording.mystroServiceId + '/' +\n                recording.tmsProgramId + '/' +\n                recording.startTime;\n\n            return rxhttp.get(fullUrl, {withCredentials: true})\n                .toPromise($q);\n        }\n\n        function getScheduledRecordings(stb) {\n            resetExpiredScheduledRecordings(stb);\n            return initStb(stb).scheduledRecordings.source;\n        }\n\n        /* Private method to reset / refetch recordings after delay */\n        function resetExpiredScheduledRecordings(stb) {\n            let now = Date.now(),\n                delay = parseInt(config.resetScheduledRecordingsDelayInMs);\n            if (lastScheduledRecordingsResetTime && (now - lastScheduledRecordingsResetTime) > delay) {\n                resetScheduledRecordings(stb);\n            }\n        }\n\n        function resetScheduledRecordings(stb) {\n            lastScheduledRecordingsResetTime = Date.now();\n            return initStb(stb).scheduledRecordings.reset();\n        }\n\n        function scheduleRecording(stb, scheduledItem) {\n            return initStb(stb).scheduledRecordings.scheduleRecording(scheduledItem).then(() => {\n                // Get schedule recordings after delay\n                if (scheduledItem.recordSeries) {\n                    $timeout(() => {\n                        resetScheduledRecordings(stb);\n                    }, parseInt(config.resetScheduledRecordingsDelayInMs));\n                }\n            });\n        }\n\n        function cancelScheduled(stb, scheduledItem, cancelSingle) {\n            return initStb(stb).scheduledRecordings.cancelScheduled(scheduledItem, cancelSingle).then(() => {\n                // Get schedule recordings after delay\n                if (!cancelSingle) {\n                    $timeout(() => {\n                        resetScheduledRecordings(stb);\n                    }, parseInt(config.resetScheduledRecordingsDelayInMs));\n                }\n            });\n        }\n\n        function getScheduledConflicts(stb, scheduledItem) {\n            if (!stb || !stb.dvr) {\n                return $q.resolve([]);\n            }\n\n            const baseUrl = config.piHost + config.nrsApi + getDvrBase(stb.rdvrVersion);\n            const fullUrl = baseUrl + stb.macAddressNormalized +\n                config.services.dvrConflicts + '/' +\n                scheduledItem.mystroServiceId + '/' +\n                scheduledItem.tmsProgramId + '/' +\n                scheduledItem.startTime + '/' +\n                (scheduledItem.recordSeries ? 'series' : 'single');\n            const options = {\n                withCredentials: true,\n                params: {\n                    lineupId: scheduledItem.lineupId\n                }\n            };\n\n            return rxhttp.get(fullUrl, options)\n                .retry(2)\n                .map(result => {\n                    result.data.conflictingRecordings = result.data.conflictingRecordings || [];\n                    // If data is missing, fill it up. Also, install a data delegate\n                    return result.data.conflictingRecordings.map(r => {\n                        if (!r.programMetadata) {\n                            createEmptyProgramMetadata(r);\n                        }\n\n                        return recordingViewModelDefinition.createInstance(r);\n                    });\n                })\n                .toPromise($q);\n        }\n\n        // This may be more generic than just RDVR\n        // could potentially live in a more generic\n        // service\n        function isMovie(tmsProgramId) {\n            return tmsProgramId && tmsProgramId.substring(0, 2) === 'MV';\n        }\n\n\n        /**\n         * Take a series and episode \"ViewModel\" and generate a 'recording'\n         * settings model that can be passed to the display popup. This connects\n         * the product page to the dvr data to allow editing series recording\n         *\n         * @param  {seriesViewModelDefinition} recordingSeries\n         * @param  {eventViewModelDefinition} recordingEpisode\n         * @param  {stream object} recordingStream\n         * @return recordingSettings\n         */\n        function getSeriesRecordingSettings({series, episode, stream, settings, isNew, conflicted}) {\n            conflicted = conflicted || false;\n            settings = settings || {\n                deleteWhenSpaceIsNeeded: true,\n                numEpisodesToKeep: 7,\n                priority: 'MIN',\n                recordOnlyAtThisAirTime: false,\n                recordOnlyNewEpisodes: false,\n                startAdjustMinutes: 0,\n                stopAdjustMinutes: 0\n            };\n\n            const props = stream.streamProperties;\n\n            const data = {\n                conflicted: conflicted,\n                mystroServiceId: '' + props.mystroServiceID,\n                displayChannel: props.allChannelNumbers.includes(series.displayChannel) ?\n                    series.displayChannel : props.allChannelNumbers[0],\n                programMetadata: {\n                    episodeNumber: episode.episodeNumber,\n                    episodeTitle: episode.title,\n                    genres: series.genres,\n                    rating: series.rating,\n                    tmsProgramId: series.tmsProgramId,\n                    tmsSeriesId: series.tmsSeriesId,\n                    title: series.title\n                },\n                recordSeries: true,\n                settings: settings,\n                startUnixTimestampSeconds: Math.floor(props.startTime / 1000),\n                tmsProgramId: props.tmsProviderProgramID,\n                isNew: isNew\n            };\n\n            return recordingViewModelDefinition.createInstance(data);\n        }\n\n        /**\n         * creates a recording object with the same structure as though it came from the set top box,\n         * but was in fact created locally.\n         * @return {[type]} [description]\n         */\n        function getEventRecordingSettings({asset, stream, settings, isNew, conflicted}) {\n            conflicted = conflicted || false;\n            settings = settings || {\n                deleteWhenSpaceIsNeeded: true,\n                numEpisodesToKeep: 7,\n                priority: 'MIN',\n                recordOnlyAtThisAirTime: false,\n                recordOnlyNewEpisodes: false,\n                startAdjustMinutes: 0,\n                stopAdjustMinutes: 0\n            };\n\n            const props = stream.streamProperties;\n\n            const data = {\n                conflicted: conflicted,\n                mystroServiceId: '' + props.mystroServiceID,\n                programMetadata: {\n                    episodeNumber: asset.episodeNumber,\n                    episodeTitle: asset.title,\n                    genres: asset.genres,\n                    rating: asset.rating,\n                    tmsProgramId: asset.tmsProgramIds[0],\n                    tmsSeriesId: asset.tmsSeriesId,\n                    title: asset.title\n                },\n                displayChannel: props.allChannelNumbers.includes(asset.displayChannel) ?\n                    asset.displayChannel : props.allChannelNumbers[0],\n                settings: settings,\n                startUnixTimestampSeconds: Math.floor(props.startTime / 1000),\n                tmsProgramId: props.tmsProviderProgramID,\n                isNew: isNew\n            };\n\n            // seriestitle check is required to stub out case where seriesTitle and title are same\n            // ex. ads like It's Supernatural has same seriesTitle and title.\n            if (asset.isEpisode && asset.seriesTitle && asset.seriesTitle !== asset.title) {\n                data.programMetadata.title = asset.seriesTitle;\n                data.programMetadata.episodeTitle = asset.title;\n                data.programMetadata.seasonNumber = asset.seasonNumber;\n                data.programMetadata.episodeNumber = asset.episodeNumber;\n            }\n\n            return recordingViewModelDefinition.createInstance(data);\n        }\n    }\n}());\n"],"sourceRoot":"/source/"}