{"version":3,"sources":["ovpApp/services/nns-service.js"],"names":[],"mappings":"AAAA;;AAAC,CAAA,YAAY;IACT;;;IAEA,QAAQ,OAAO,uBAAuB,CAClC,iBACA,yBACA,2BACA,OAEH,QAAQ,cAAc;;;IAGvB,SAAS,WAAW,QAAQ,IAAI,IAAI,MAAM,UAAU,eAAe,QAAQ,cAAc;QACrF,IAAI,WAAW,cAAc,IAAI;QACjC,IAAI,iBAAc;;QAElB,IAAI,UAAU;YACV,YAAA;YACA,gBAAgB,SAAA,eAAC,OAAK;gBAHlB,OAGuB,iBAAe,OAAO,UAAU;;YAC3D,kBAAA;YACA,4BAAA;YACA,YAAA;;;QAGJ;;QAEA,OAAO;;;;QAIP,SAAS,WAAW;;YAEhB,iBAAiB,CACb,UAAU,KAAK;gBACX,IAAI;oBACA,QAAQ,SAAS;kBACnB,OAAO,GAAG;oBACR,MAAM;oBACN,KAAK,MAAM;;gBAEf,OAAO;;YAGf,iBAAiB,eAAe,OAAO,OAAO,SAAS;;;;;;;;;QAS3D,SAAS,WAAW,QAAQ;YACxB,IAAI,CAAC,UAAU,OAAO,WAAW,GAAG;gBAChC,OAAO,GAAG,WAAW,KAAK,IAAI,UAAU;;;YAG5C,OAAO,GAAG,WAAW,KAAK,QACrB,UAAU,UAAA,OAAS;gBAChB,OAAO,iBAAe,OACjB,MAAM,GAAE,SACF,YAAA;oBANX,OAMiB,GAAG,WAAW,KAAK;;eAEvC,gBAAgB,OAAO,QACvB,QACA,QAAQ,OAAO,GAAG,WAAU,SAAO,+BAC/B,UAAU,YAAA;gBARf,OAQqB,KAAK,MAAM;gBAC/B,UAAU;;;;;;;;QAQnB,SAAS,iBAAe,OAAO;YAC3B,OAAO,GAAG,WAAW,YAAY,mBAAmB,QAC/C,QAAQ,UAAA,KAAG;gBARZ,OAQgB,gBAAgB,OAAO;eACtC,UAAU,UAAA,OAAK;gBAPhB,OAOoB,KAAK,MAAM,wCAAwC;;;;;;;;;;QAS/E,SAAS,2BAA2B,WAAW,QAAQ;YACnD,IAAI,gBAAgB;YACpB,IAAI,OAAO,YAAY,OAAO,SAAS,SAAS;gBAC5C,KAAK,IAAI,IAAI,GAAG,IAAI,OAAO,SAAS,QAAQ,KAAK;oBAC7C,IAAI,UAAU,OAAO,SAAS;oBAC9B,IAAI,QAAQ,QAAQ,mBAAmB;wBACnC,IAAI,mBAAmB,KAAK,MAAM,QAAQ,QAAQ;wBAClD,IAAI,mBAAmB,WAAW;4BAC9B,cAAc,KAAK;;;;;;YAMnC,OAAO;;;QAGX,SAAS,iBAAiB,WAAW,QAAQ;YACzC,IAAI,gBAAgB;gBAAI,UAAU,OAAO;YACzC,KAAK,IAAI,KAAK,SAAS;gBACnB,IAAI,QAAQ,eAAe,IAAI;oBAC3B,IAAI,wBAAwB,2BAA2B,WAAW,QAAQ;oBAC1E,gBAAgB,cAAc,OAAO;;;YAG7C,OAAO;;;QAGX,SAAS,gBAAgB,OAAO,KAAK;YACjC,OAAO,OAAO;gBACV,KAAK,OAAO,SAAS;gBACrB,iBAAiB;gBACjB,OAAO;gBACP,mBAAmB;eACpB,IAAI,UAAA,UAAQ;gBAJX,OAIe,SAAS;;;;;;;;;QAQhC,SAAS,aAAa;YAClB,OAAO,OAAO;gBACV,KAAK,OAAO,SAAS,OAAO,aAAa;gBACzC,iBAAiB;eAEpB,IAAI,UAAA,KAAG;gBAHJ,OAGQ,IAAI;eACf,UAAU;;;;;;;;QAQf,SAAS,mBAAmB,OAAO;;YAE/B,OAAO,aAAa,oBAAoB,KAAK,UAAA,SAAW;gBACpD,IAAI,MAAM;gBACV,IAAI,MAAM,YAAY,MAAM,aAAa;oBACrC,MAAM,QAAQ,OAAO,YAAY,MAAM;uBACpC,IAAI,MAAM,iBAAiB;oBAC9B,MAAM,QAAQ,MAAM,gBAAgB,MAAM;uBACvC;oBACH,MAAM,IAAI,MAAM;;gBAEpB,OAAO;;;;KAKlB","file":"ovpApp/services/nns-service.js","sourcesContent":["(function () {\n    'use strict';\n\n    angular.module('ovpApp.services.nns', [\n        'ovpApp.config',\n        'ovpApp.services.entry',\n        'ovpApp.services.rxUtils',\n        'rx'\n    ])\n    .factory('NNSService', NNSService);\n\n    /* @ngInject */\n    function NNSService(rxhttp, rx, $q, $log, $timeout, $cacheFactory, config, entryService) {\n        let nnsCache = $cacheFactory.get('nnsCache');//This is a very primitive cache\n        let transformQueue;\n\n        let service = {\n            fetchBatch,\n            fetchAssetData: (asset) => fetchAssetData(asset).toPromise($q),\n            getEpisodesSince,\n            getEpisodesFromSeasonSince,\n            getVersion\n        };\n\n        activate();\n\n        return service;\n\n        //////////////////\n\n        function activate() {\n            //Catch malformed JSON, for example, a 404 response from nns returns an error string\n            transformQueue = [\n                function (val) {\n                    try {\n                        angular.fromJson(val);\n                    } catch (e) {\n                        val = '{}';\n                        $log.error('Unable to parse json from server response');\n                    }\n                    return val;\n                }\n            ];\n            transformQueue = transformQueue.concat(rxhttp.defaults.transformResponse);\n        }\n\n        /**\n         * Accepts a list of assets (a result from the bookmarks api) and fetches\n         * them as if it where a single request.\n         * @param  {array} assets list of bookmark response objects\n         * @return {promise}      promise that will result in an array of results\n         */\n        function fetchBatch(assets) {\n            if (!assets || assets.length === 0) {\n                return rx.Observable.just([]).toPromise($q);\n            }\n\n            return rx.Observable.from(assets)\n                .concatMap(asset => {\n                    return fetchAssetData(asset)\n                        .retry(2)\n                        .catch(() => rx.Observable.just(undefined));\n                })\n                .bufferWithCount(assets.length)\n                .first()\n                .timeout(60000, rx.Observable.throw('Timeout fetching all assets')\n                    .doOnError(() => $log.error('Unable to fetch all data within 60 seconds')))\n                .toPromise($q);\n        }\n\n        /*\n            Get asset data, must make sure that we can retrieve the url first,\n            this requires a possible wait on the entryManager initialize task\n            and then again on the actual data\n         */\n        function fetchAssetData(asset) {\n            return rx.Observable.fromPromise(_fetchAssetDataUrl(asset))\n                .flatMap(url => _fetchAssetData(asset, url))\n                .doOnError(error => $log.error('Unable to fetch the asset data url ' + error));\n        }\n\n        /**\n         * Inspect all episodes in a season and determine what is new\n         * @param  {number} sinceDate milliseconds since Jan 1, 1970\n         * @param  {object} season   Season to inspect\n         * @return {array}           List of episodes found since sinceDate\n         */\n        function getEpisodesFromSeasonSince(sinceDate, season) {\n            var foundEpisodes = [];\n            if (season.episodes && season.name !== 'Other') {\n                for (let i = 0; i < season.episodes.length; i++) {\n                    let episode = season.episodes[i];\n                    if (episode.details.original_air_date) {\n                        let episodeTimestamp = Date.parse(episode.details.original_air_date);\n                        if (episodeTimestamp > sinceDate) {\n                            foundEpisodes.push(episode);\n                        }\n                    }\n                }\n            }\n\n            return foundEpisodes;\n        }\n\n        function getEpisodesSince(sinceDate, series) {\n            var foundEpisodes = [], seasons = series.seasons;\n            for (let i in seasons) {\n                if (seasons.hasOwnProperty(i)) {\n                    let currentSeasonEpisodes = getEpisodesFromSeasonSince(sinceDate, seasons[i]);\n                    foundEpisodes = foundEpisodes.concat(currentSeasonEpisodes);\n                }\n            }\n            return foundEpisodes;\n        }\n\n        function _fetchAssetData(asset, url) {\n            return rxhttp({\n                url: config.piHost + url,\n                withCredentials: true,\n                cache: nnsCache,\n                transformResponse: transformQueue\n            }).map(response => response.data);\n        }\n\n        /**\n         * Sets the NNS version to local storage for info on login page in test\n         * API can only be used with credentials.\n         * @returns {*}\n         */\n        function getVersion() {\n            return rxhttp({\n                url: config.piHost + config.nnsVersion + '?short=true',\n                withCredentials: true\n            })\n            .map(res => res.data)\n            .toPromise($q);\n        }\n\n        /**\n         * Get the data url for an asset based on what data is available\n         * @param  {asset}\n         * @return {promise}       promise\n         */\n        function _fetchAssetDataUrl(asset) {\n\n            return entryService.forDefaultProfile().then(service => {\n                let uri = null;\n                if (asset.isSeries && asset.tmsSeriesId) {\n                    uri = service.series.tmsSeriesID(asset.tmsSeriesId);\n                } else if (asset.providerAssetId) {\n                    uri = service.event.providerAssetID(asset.providerAssetId);\n                } else {\n                    throw new Error('Unable to determine the correct entry url for asset');\n                }\n                return uri;\n            });\n\n        }\n    }\n}());\n"],"sourceRoot":"/source/"}