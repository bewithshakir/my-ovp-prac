{"version":3,"sources":["ovpApp/interceptors/httpInterceptor.js"],"names":[],"mappings":"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","file":"ovpApp/interceptors/httpInterceptor.js","sourcesContent":["/* global window*/\n(function () {\n    'use strict';\n\n    angular.module('ovpApp.interceptors.httpInterceptor', ['ovpApp.config'])\n        .config(httpInterceptor);\n\n    /**\n     * Since http interceptors in angular are done before services initialize,\n     * the config must be injected at runtime.\n     *\n     * This is also implemented in the nns-service for jquery http calls.\n     * @param $httpProvider\n     */\n    /* @ngInject */\n    function httpInterceptor($httpProvider) {\n        $httpProvider.interceptors.push(['$q', '$injector', '$log', '$rootScope',\n            function ($q, $injector, $log, $rootScope) {\n                let config = $injector.get('config');\n\n                return {\n                    request: function (request) {\n                        // Add start time to this request\n                        request.started = Date.now();\n                        return request;\n                    },\n\n                    requestError: function (response) {\n                        processResponse(response);\n                        return $q.reject(response);\n                    },\n\n                    responseError: function (response) {\n                        processResponse(response);\n                        return $q.reject(response);\n                    },\n\n                    response: function (response) {\n                        processResponse(response);\n                        return response;\n                    }\n                };\n\n                // Capture given value as a string. Value could be null,\n                // a string, or an object.\n                function getAsString(responseText) {\n                    if (responseText) {\n                        if ('string' === typeof responseText) {\n                            return responseText;\n                        } else if ('object' === typeof responseText) {\n                            return JSON.stringify(responseText);\n                        }\n                    }\n                    return '';\n                }\n\n                function processResponse(response) {\n\n                    // Do nothing if this event is disabled.\n                    if (!config.analytics.venona.enabled || !config.analytics.venona.events.apiCall) {\n                        return;\n                    }\n\n                    // Ignore responses missing required information.\n                    if (!response || !response.config || !response.config.url ||\n                        !response.status) {\n                        return;\n                    }\n\n                    // Ignore cancelled requests\n                    if (response.status === -1) {\n                        return;\n                    }\n\n                    // Detect if request succeeded.\n                    let isSuccess = false; // Assume failure.\n                    let statusCodeInt = parseInt(response.status, 10);\n                    if (!isNaN(statusCodeInt) && statusCodeInt >= 200 && statusCodeInt <= 399) {\n                        isSuccess = true;\n                    }\n\n                    // Determine serviceResult, which can be: success, failure, or timeout.\n                    let serviceResult = isSuccess ? 'success' : 'failure';\n                    if (408 === statusCodeInt) {\n                        serviceResult = 'timeout';\n                    }\n\n                    // Ignore successful relative requests, unless they failed.\n                    // (Relative requests don't have the http[s]: prefix.)\n                    if (isSuccess && response.config.url.indexOf('http') !== 0) {\n                        return;\n                    }\n\n                    // Ignore blacklisted URLs. (Example: there's little point\n                    // in telling the collector that it is unreachable...)\n                    // TODO: Use underscore to process blacklist.\n                    let isBlacklisted = false;\n                    config.analytics.blacklist.urls.forEach(function (element) {\n                        if (!isBlacklisted && response.config.url.indexOf(element) === 0) {\n                            isBlacklisted = true;\n                            // $log.debug('Analytics blacklisted:  ' + response.config.url);\n                        }\n                    });\n                    if (isBlacklisted) {\n                        return;\n                    }\n\n                    // Collect query parameters, if any.\n                    let queryParameters = '';\n                    let queryIdx = response.config.url.indexOf('?');\n                    if (queryIdx > 0) {\n                        queryParameters = response.config.url.substring(queryIdx + 1);\n                    }\n\n                    // Did this response come from the cache? This is unfortunately\n                    // difficult to determine, because the $http doesn't provide\n                    // an indicator of this. Instead, we make our own indicator.\n                    //\n                    // NOTE: Only 'GET' and 'JSONP' requests can be cached.\n                    if (response.config.cache &&\n                        ('GET' === response.config.method || 'JSONP' === response.config.method)) {\n\n                        // Generate URL w/ parameters using same strategy as Angular $http.\n                        let urlWithParams = response.config.url;\n                        if (response.config.params) {\n                            let serializedParams = response.config.paramSerializer(response.config.params);\n                            if (serializedParams.length > 0) {\n                                urlWithParams += ((urlWithParams.indexOf('?') == -1) ? '?' : '&') + serializedParams;\n                            }\n                        }\n\n                        let cachedEntityArray = response.config.cache === true ||\n                        response.config.cache.get(urlWithParams);\n\n                        if (angular.isArray(cachedEntityArray) && angular.isObject(cachedEntityArray[2])) {\n                            if (cachedEntityArray[2]['x-intercept-cache']) {\n                                // This cache entry is already marked by us,\n                                // so we know we've processed it before.\n                                // $log.debug('Ignoring cached request for ' + response.config.url);\n                                return;\n                            }\n\n                            // Mark the cache entry so we'll know if we see it again.\n                            cachedEntityArray[2]['x-intercept-cache'] = 'true';\n                        }\n                    }\n\n                    // Capture the response time in ms for this request/response.\n                    let responseMs = 0;\n                    if (response.config.started) {\n                        responseMs = Date.now() - response.config.started;\n                    }\n\n                    // Parse the URL. The created 'a' element gets garbage collected\n                    // automatically, since it isn't added to the DOM.\n                    var parser = window.document.createElement('a');\n                    parser.href = response.config.url;\n\n                    // Build payload\n                    let apiCallPayload = {\n                        success : isSuccess,\n                        serviceResult : serviceResult,\n                        triggeredBy : 'application',\n                        responseCode : '' + response.status,\n                        responseText : (isSuccess ? '' : getAsString(response.data)),\n                        responseTimeMs : responseMs,\n                        host : parser.hostname,\n                        path : parser.pathname,\n                        httpVerb : response.config.method,\n                        queryParameters: queryParameters,\n                        apiCached : 304 === statusCodeInt ? true : false,\n                        traceId: response.headers('x-trace-id') || ''\n                    };\n\n                    // Set error fields\n                    if (!isSuccess) {\n                        apiCallPayload.errorType = 'api';\n                        apiCallPayload.errorCode = '' + response.status;\n                        apiCallPayload.errorMessage = response.statusText + ': ' +\n                            JSON.stringify(response.data);\n                    }\n\n                    // Publish error message\n                    $rootScope.$emit('Analytics:apiCall', apiCallPayload);\n                }\n            }]);\n    }\n}());\n"],"sourceRoot":"/source/"}